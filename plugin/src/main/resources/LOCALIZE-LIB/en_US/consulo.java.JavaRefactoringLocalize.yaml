0.the.caret.should.be.positioned.at.an.annotation.to.be.refactored.to.be.refactored:
    text: '{0}The caret should be positioned at an annotation to be refactored to be refactored.'
a.class.can.not.be.made.an.inner.class.of.itself:
    text: A class can not be made an inner class of itself.
a.class.can.not.be.made.an.inner.class.of.one.of.it.s.decendents:
    text: A class can not be made an inner class of one of it's decendents.
action.column.header:
    text: Action
action.expand.static.import.text:
    text: Expand Static Import
action.rename.file.description:
    text: Rename selected file
action.rename.file.text:
    text: Rename File…
add.global.library:
    text: Add library dependency
add.module.dependency:
    text: Add module dependency
add.project.library:
    text: Add library dependency
add.property:
    text: Add Property
add.property.command:
    text: Add property {0} to {1}
add.property.dialog.title:
    text: Add property to {0}
add.property.to.constructors.checkbox:
    text: Add property to constructors
annotation:
    text: Annotation
annotation.types.cannot.be.inlined:
    text: Annotation types cannot be inlined
can.not.find.any.available.overriding.methods.for.the.selected.method:
    text: Can not find any available overriding methods for the selected method
can.not.find.any.available.subclasses.for.the.selected.class:
    text: Can not find any available subclasses for the selected class
can.not.find.any.available.super.methods.for.the.selected.method:
    text: Can not find any available super-methods for the selected method
can.not.find.any.available.superclasses.for.the.selected.class:
    text: Can not find any available superclasses for the selected class
can.only.pull.annotations.up.on.methods.parameters.and.classes:
    text: Can only pull annotations up on methods, parameters, and classes
can.only.push.annotations.down.on.methods.parameters.and.classes:
    text: Can only push annotations down on methods, parameters, and classes
cannot.perform.the.refactoring:
    text: |
        Cannot perform the refactoring.
choose.destination.class.label:
    text: Choose destination class
choose.destination.package.label:
    text: Choose Destination Package
class.cannot.be.inlined.because.a.call.to.its.constructor.is.unresolved:
    text: Class cannot be inlined because a call to its constructor is unresolved
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved:
    text: Class cannot be inlined because an interface implemented by it cannot be resolved
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers:
    text: Class cannot be inlined because it has static fields with non-constant initializers
class.cannot.be.inlined.because.it.has.static.initializers:
    text: Class cannot be inlined because it has static initializers
class.cannot.be.inlined.because.it.has.static.inner.classes:
    text: Class cannot be inlined because it has static inner classes
class.cannot.be.inlined.because.it.has.static.methods:
    text: Class cannot be inlined because it has static methods
class.cannot.be.inlined.because.it.has.static.non.final.fields:
    text: Class cannot be inlined because it has static non-final fields
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass:
    text: Class cannot be inlined because it has usages of fields not inherited from its superclass
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal:
    text: Class cannot be inlined because it has usages of its class literal
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes:
    text: Class cannot be inlined because it has usages of its inner classes
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier:
    text: Class cannot be inlined because it is used as a 'this' qualifier
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause:
    text: Class cannot be inlined because it is used in a 'catch' clause
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause:
    text: Class cannot be inlined because it is used in a 'throws' clause
class.cannot.be.inlined.because.its.constructor.contains.return.statements:
    text: Class cannot be inlined because its constructor contains 'return' statements
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved:
    text: Class cannot be inlined because its superclass cannot be resolved
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface:
    text: Class cannot be inlined because there are usages of its methods not inherited from its superclass or interface
class.found.column.header:
    text: Class found
class.references.to.be.made.inner:
    text: Class references to be made inner
class.search.results.title:
    text: Class search results
class.to.be.add.property.to:
    text: Class to be add property to
conflicts.found:
    text: Conflicts found
constructor.calls.to.be.updated.view.descriptor:
    text: Constructor calls to be updated {0}
constructor.returns.can.not.be.wrapped:
    text: Constructor returns can not be wrapped.
control.flow.category:
    text: Control Flow
convert.equality.disjunction.to.set.contains:
    text: Convert Equality Disjunction To Set.contains()
convert.to.MessageFormat.format:
    text: Convert to MessageFormat.format
convert.to.String.format:
    text: Convert to String.format
convert.to.printf:
    text: Convert to printf
convert.to.set.contains:
    text: Convert to Set.contains()
copy.javadoc.to.ancestors:
    text: Copy Javadoc to ancestors
copy.javadoc.to.inheritors:
    text: Copy Javadoc to inheritors
could.not.find.selected.wrapping.class:
    text: Could not find selected wrapping class
create.property.getter.checkbox:
    text: Create property getter
create.property.setter.checkbox:
    text: Create property setter
declare.generated.annotations:
    text: '&Generate annotations'
declare.static.pass.fields.checkbox:
    text: Declare &static (pass fields as params)
delete.all.delegating.methods.radio.button:
    text: Delete all delegating methods
delete.delegating.methods.border:
    text: Delete delegating methods
delete.selected.annotation.checkbox:
    text: Delete selected annotation
dialog.message.nothing.found.to.extract:
    text: Nothing found to extract
do.you.wish.to.continue:
    text: |
        Do you wish to continue?.
do.you.wish.to.invert.all.uses.of.parameter:
    text: Do you wish to invert all uses of parameter {0}?
do.you.wish.to.invert.all.uses.of.variable:
    text: Do you wish to invert all uses of variable {0}?
enums.cannot.be.inlined:
    text: Enums cannot be inlined
existing.wrapper.class.label:
    text: Use Existing Parameter Class
exposed.delegation.command.name:
    text: Exposed delegation to {0}{1}{2}
extract.class:
    text: Extract Class
extract.class.depends.on.0.from.1.tooltip:
    text: Depends on {0} from {1}
extract.class.depends.on.0.from.new.class:
    text: Depends on {0} from new class {1}
extract.class.from.label:
    text: Extract class from {0}
extract.class.title:
    text: Extract Class
extract.delegate.as.enum.checkbox:
    text: Extract as enum
extract.delegate.create.nested.checkbox:
    text: Create nested class
extract.delegate.generate.accessors.checkbox:
    text: '&Generate accessors'
extract.delegate.unable.create.warning.message:
    text: Unable to create class with the given name
extracted.class.command.name:
    text: Extracted Class {0}
extracted.class.should.have.unique.name:
    text: Extracted class should have unique name. Name ''{0}'' is already in use by one of the inner classes
extracting.from.class:
    text: 'Extracting from class:'
field.label:
    text: Field {0}
field.selected.is.not.used.as.a.delegate:
    text: Field selected is not used as a delegate.
generate.array.access.methods.title:
    text: Choose members to generate array access methods for
generate.array.methods.undo.string:
    text: Generate Array Methods
generate.collection.access.methods.title:
    text: Choose members to generate collection access methods for
generate.collection.methods.undo.string:
    text: Generate Collection Methods
genericize.uses.border:
    text: Genericize uses of {0}
genericize.uses.in.border:
    text: Genericize uses of {0} in {1}
global.library.source:
    text: 'Global Library: {0}'
initialization.expression.checkbox:
    text: 'Initialization expression (optional):'
inline.anonymous.conflict.progress:
    text: Searching for class "{0}" inheritors…
inline.conflicts.progress:
    text: Check if inline is possible…
inline.constant.field.not.supported.for.enum.constants:
    text: '{0} is not supported for enum constants'
inline.field.used.in.javadoc:
    text: Inlined field is used in javadoc
inline.field.used.in.reflection:
    text: Inlined field is used reflectively
inline.local.unable.try.catch.warning.message:
    text: Unable to inline outside try/catch statement
inline.local.variable.declared.outside.cannot.refactor.message:
    text: Variable is declared outside a code block
inline.method.multiline.method.in.ctor.call:
    text: Inline cannot be applied to multiline method in constructor call
inline.method.used.in.javadoc:
    text: Inlined method is used in javadoc
inline.parameter.cannot.find.initializer.warning.message:
    text: Cannot find constant initializer for parameter
inline.parameter.no.usages.warning.message:
    text: Method has no usages
inline.parameter.not.accessible.warning.message:
    text: Constant initializer is not accessible in method body
inline.super.class:
    text: Inline Super Class
inline.super.class.action.name:
    text: Inline Super Class\u2026
inline.super.class.label:
    text: Class {0}
inline.super.no.anonymous.class:
    text: Cannot inline into anonymous class.
inline.super.no.inner.class:
    text: Cannot inline into the inner class. Move ''{0}'' to upper level
inline.super.non.project.class.warning.message:
    text: Cannot inline non-project class
interfaces.cannot.be.inlined:
    text: Interfaces cannot be inlined
introduce.parameter.object:
    text: Introduce Parameter Object
introduce.parameter.object.title:
    text: Introduce Parameter Object
introduce.type.parameter:
    text: Introduce Type Parameter
introduce.type.parameter.title:
    text: Introduce Type Parameter
introduced.parameter.class.command.name:
    text: Introduced parameter class {0} for {1}.{2}()
introduced.type.parameter.command.name:
    text: Introduced type {0} as parameter to class {1}
invalid.extracted.class.name:
    text: '''''{0}'''' is invalid extracted class name'
invalid.license.data:
    text: Invalid License Data
invalid.license.data.please.try.again:
    text: Invalid license data. Please, try again.
invalid.type.for.weaken.type.refactoring:
    text: Invalid type for Weaken Type refactoring
invert.boolean:
    text: Invert Boolean
invert.boolean.title:
    text: Invert boolean
invert.parameter.command.name:
    text: Inverted {0}({1})
invert.variable.command.name:
    text: Inverted
javadoced.class:
    text: Javadoced class
library.classes.cannot.be.inlined:
    text: Library classes cannot be inlined
make.class.an.inner.class.border:
    text: Make class {0} an inner class
make.class.inner:
    text: Make Class Inner
make.class.inner.command.name:
    text: Move class {0} inside class {1}
make.class.inner.title:
    text: Make Class Inner
make.property.final.checkbox:
    text: Make property final
members.to.extract.label:
    text: Mem&bers to Extract
merge.loops.family.name:
    text: Merge Loops
merge.loops.text:
    text: Merge loops
method.selected.has.no.parameters:
    text: Method selected has no parameters.
method.selected.returns.void:
    text: Method selected returns 'void'.
method.to.extract.parameters.from.label:
    text: Method to extract parameters from
method.to.wrap.returns.from.label:
    text: 'Method to wrap returns from:'
method.whose.parameters.are.to.wrapped:
    text: Method whose parameters are to wrapped
method.whose.return.are.to.wrapped:
    text: Method whose return are to wrapped
methods.to.copy.javadoc.from:
    text: Methods to copy javadoc from
methods.to.pull.up.javadoc.from.panel:
    text: Methods to pull up javadoc from
module.source:
    text: 'Module: {0}'
name.for.new.class.label:
    text: '&Name for new class:'
name.for.new.parameter.label:
    text: 'Name for new parameter:'
name.for.new.type.parameter.label:
    text: 'Name for new type parameter:'
name.for.wrapper.class.label:
    text: 'Class name:'
no.class.found:
    text: No class found
only.outer.classes.and.static.inner.classes.may.be.made.inner:
    text: Only outer classes and static inner classes may be made inner.
other.category:
    text: Other
outer.class.label:
    text: 'Outer class:'
package.for.new.class.label:
    text: '&Package name:'
package.for.wrapper.class.label:
    text: 'Package name:'
parameter:
    text: Parameter
parameter.selected.is.not.boolean:
    text: Parameter selected is not boolean.
parameterize.class.radio.button:
    text: Parameterize class {0}
parameterize.method.radio.button:
    text: Parameterize method {0}()
parameters.to.extract.border:
    text: Parameters to Extract
preview:
    text: Preview
primitive.types.can.not.be.introduced.as.type.parameters:
    text: Primitive types can not be introduced as type parameters.
project.library.source:
    text: 'Project Library: {0}'
property.name.field.label:
    text: 'Property name:'
property.to.be.removed:
    text: Property to be removed
property.type.field.label:
    text: 'Property type:'
pull.annotation.up:
    text: Pull Annotation Up
pull.annotation.up.from.label:
    text: 'Pull annotation up from:'
pull.annotation.up.title:
    text: Pull Annotation Up
pull.javadoc.up:
    text: Pull Javadoc Up
pull.javadoc.up.title:
    text: Pull Javadoc Up
pull.up.annotation.command.name:
    text: Pull up annotation
pull.up.annotation.from.label:
    text: 'Pull up annotation from {0} to:'
pull.up.javadoc.command.name:
    text: Pull up Javadoc
pull.up.javadoc.from.label:
    text: 'Pull up javadoc from {0} to:'
push.annotation.down:
    text: Push Annotation Down
push.annotation.down.from.label:
    text: 'Push annotation down from:'
push.annotation.down.title:
    text: Push Annotation Down
push.down.annotation.command.name:
    text: Push down annotation
push.javadoc.down:
    text: Push Javadoc Down
push.javadoc.down.from.label:
    text: 'Push Javadoc down from:'
push.javadoc.down.title:
    text: Push Javadoc Down
push.up.javadoc.command.name:
    text: Push up Javadoc
records.cannot.be.inlined:
    text: Record classes cannot be inlined
refactor:
    text: Refactor
reference:
    text: reference
references.to.be.changed.usage.view:
    text: References to be changed {0}
references.to.be.inverted.0:
    text: References to be inverted {0}
references.to.be.made.inner.usage.view:
    text: References to be made inner {0}
references.to.be.made.removed.usage.view:
    text: References to be made removed {0}
references.to.be.modified:
    text: References to be modified
references.to.be.modified.usage.view:
    text: References to be modified {0, choice, 0#(Not found)|1#{0} reference|2#{0} references}{1, choice, 0#|1# in {1} file|2# in {1} files}
references.to.expose.usage.view:
    text: References to expose {0, choice, 0#(Not found)|1#{0} reference|2#{0} references}{1, choice, 0#|1# in {1} file|2# in {1} files}
references.to.extract:
    text: References to extract ({0, choice, 0#(Not found)|1#{0} reference|2#{0} references}{1, choice, 0#|1# in {1} file|2# in {1} files})
remove.middleman:
    text: Remove Middleman
remove.middleman.column.header:
    text: Delete
remove.middleman.deleted.hierarchy.conflict:
    text: '{0} will be deleted. Hierarchy will be broken'
remove.middleman.field.header:
    text: 'Remove middleman field:'
remove.middleman.methods.to.inline.title:
    text: '&Methods to Inline'
remove.middleman.title:
    text: Remove Middleman
remove.middleman.tooltip.warning:
    text: Deletion will break type hierarchy
remove.property:
    text: Remove Property
remove.property.border:
    text: Remove property {0}
remove.property.command.name:
    text: Remove property {0}
remove.property.getter.checkbox:
    text: Remove property getter
remove.property.setter.checkbox:
    text: Remove property setter
remove.property.title:
    text: Remove Property
remove.type.parameter:
    text: Remove Type Parameter
removed.type.parameter.from.class.command.name:
    text: Removed type parameter {0} from class {1}
removed.type.parameter.from.method.command.name:
    text: Removed type parameter {0} from method {1}()
rename.overloads:
    text: Rename &overloads
replace.existing.annotations.checkbox:
    text: Replace existing annotations
replace.existing.comments.checkbox:
    text: Replace existing comments
replacement.expression.label:
    text: 'Replacement expression (optional):'
retain.all.delegating.methods.radio.button:
    text: Retain all delegating methods
review.license.terms:
    text: Review License terms
search.for.class.family.name:
    text: Search For Class
search.for.class.text:
    text: Search for class
select.wrapper.class:
    text: Select Parameter Class
source.column.header:
    text: Source
split.loop.family.name:
    text: Split Loop
split.loop.text:
    text: Split loop
split.string:
    text: Split string
subclass.elements.to.be.annotated:
    text: Subclass elements to be annotated
superclass.elements.to.be.annotated:
    text: Superclass elements to be annotated
superclass.methods.to.be.javadoced:
    text: Superclass methods to be javadoced
the.caret.should.be.positioned.at.an.annotation.to.be.refactored.to.be.refactored:
    text: The caret should be positioned at an annotation to be refactored to be refactored.
the.caret.should.be.positioned.at.on.a.class.to.be.made.into.an.inner.class:
    text: The caret should be positioned at a class to be made into an inner class.
the.caret.should.be.positioned.at.on.a.property.to.be.removed:
    text: The caret should be positioned at a property to be removed.
the.caret.should.be.positioned.at.on.a.type.to.be.parameterized:
    text: The caret should be positioned at a type to be parameterized.
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored:
    text: The caret should be positioned at the name of the field to be refactored.
the.caret.should.be.positioned.at.the.name.of.the.method.to.be.refactored:
    text: The caret should be positioned at the name of the method to be refactored, inside parameters list or inside method call.
the.caret.should.be.positioned.at.the.name.of.the.type.parameter.to.be.refactored:
    text: The caret should be positioned at the name of the type parameter to be refactored.
the.caret.should.be.positioned.at.the.name.of.the.variable.or.parameter.to.be.refactored:
    text: The caret should be positioned at the name of the variable or parameter to be refactored.
the.caret.should.be.positioned.at.the.name.of.the.variable.parameter.or.method.to.be.refactored:
    text: The caret should be positioned at the name of the variable, parameter, or method to be refactored.
the.caret.should.be.positioned.in.the.class.to.add.to.property.to:
    text: The caret should be positioned in the class to add to property to.
the.caret.should.be.positioned.within.a.class.to.be.refactored:
    text: The caret should be positioned within a class to be refactored.
the.refactoring.is.not.supported.on.non.static.inner.classes:
    text: The refactoring is not supported on non-static inner classes.
the.selected.class.has.no.members.to.extract:
    text: The selected class has no members to extract.
the.selected.class.has.no.overridden.methods.with.javadoc:
    text: The selected class has no overriden methods with javadoc.
the.selected.class.is.an.annotation.type:
    text: The selected class is an annotation interface.
the.selected.class.is.an.enumeration:
    text: The selected class is an enum class.
the.selected.class.is.an.interface:
    text: The selected class is an interface.
the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class:
    text: The selected method cannot be wrapped because it is defined in a non-project class
the.selected.type.cannot.be.weakened:
    text: The selected type cannot be weakened
the.selected.type.cannot.be.weakened.because.the.method.is.declared.in.a.non.project.class:
    text: The selected type cannot be weakened because the method is declared in a non-project class
there.already.exists.a.class.with.the.chosen.name:
    text: There already exists a class with the chosen name.
there.already.exists.a.class.with.the.selected.name:
    text: There already exists a class with the selected name
there.already.exists.an.incompatible.class.with.the.chosen.name:
    text: There already exists an incompatible class with the chosen name
there.are.non.genericizable.instances.of.the.type.you.selected:
    text: |
        There are non-genericizable instances of the type you selected.
type.parameter.question.label:
    text: Do you wish to remove type parameter {0} and all uses of it?
type.parameter.selected.extends.multiple.types:
    text: Type parameter selected extends multiple types.
type.parameter.to.be.introduced:
    text: Type parameter to be introduced
type.parameter.to.be.remove:
    text: Type parameter to be remove
type.parameters.can.not.be.introduced.as.type.parameters:
    text: Type parameters can not be introduced as type parameters.
type.parameters.cannot.be.inlined:
    text: Type parameters cannot be inlined
type.selected.is.not.in.class.context:
    text: Type selected is not in class context.
unable.to.find.the.requested.class:
    text: Unable to find the requested class
use.inheritdoc.comments:
    text: Use @inheritdoc comments
user.name:
    text: '&User Name:'
variable.selected.is.not.boolean:
    text: Variable selected is not boolean.
variable.to.be.inverted:
    text: Variable to be inverted
weaken.type:
    text: Weaken Type
weaken.type.command.name:
    text: Weaken type
weaken.type.label:
    text: 'Weaken the type of ''''{0}'''' from {1} to:'
weaken.type.refactoring.is.not.supported.for.arrays:
    text: Weaken type refactoring is not supported for arrays
weaken.type.refactoring.is.not.supported.for.constructors:
    text: Weaken type refactoring is not supported for constructors
weaken.type.refactoring.is.not.supported.for.primitive.types:
    text: Weaken type refactoring is not supported for primitive types
weaken.type.refactoring.is.not.supported.for.type.parameters:
    text: Weaken type refactoring is not supported for type parameters
wrap.return.value:
    text: Wrap Return Value
wrap.return.value.title:
    text: Wrap Return Value
wrapped.return.command.name:
    text: Wrapped return as {0} for {1}{2}{3}()
