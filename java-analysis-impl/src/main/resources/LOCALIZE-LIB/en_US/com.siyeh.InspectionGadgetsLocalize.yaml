0.will.have.incompatible.access.privileges.with.super.1:
    text: '{0} will have incompatible access privileges with super {1}'
0.will.no.longer.be.overridable.by.1:
    text: '{0} will no longer be overridable by {1}'
0.will.no.longer.be.visible.from.overriding.1:
    text: '{0} will no longer be visible from overriding {1}'
absolute.alignment.in.user.interface.display.name:
    text: Absolute alignment in AWT/Swing code
absolute.alignment.in.user.interface.problem.descriptor:
    text: 'Absolute alignment constant <code>{0}.#ref</code> used #loc'
absolute.alignment.in.user.interface.quickfix:
    text: Replace with ''{0}.{1}''
abstract.class.extends.concrete.class.display.name:
    text: Abstract class extends concrete class
abstract.class.extends.concrete.class.problem.descriptor:
    text: 'Class <code>#ref</code> is declared ''abstract'', and extends a concrete class #loc'
abstract.class.naming.convention.display.name:
    text: Abstract class naming convention
abstract.class.naming.convention.element.description:
    text: Abstract class
abstract.class.never.implemented.display.name:
    text: Abstract class which has no concrete subclass
abstract.class.never.implemented.problem.descriptor:
    text: 'Abstract class <code>#ref</code> has no concrete subclass #loc'
abstract.class.with.only.one.direct.inheritor.display.name:
    text: Abstract class with a single direct inheritor
abstract.class.with.only.one.direct.inheritor.problem.descriptor:
    text: 'Abstract class <code>#ref</code> has only one direct inheritor #loc'
abstract.class.without.abstract.methods.display.name:
    text: Abstract class without 'abstract' methods
abstract.class.without.abstract.methods.problem.descriptor:
    text: 'Class <code>#ref</code> is declared ''abstract'', and has no ''abstract'' methods #loc'
abstract.method.call.in.constructor.display.name:
    text: Abstract method called during object construction
abstract.method.call.in.constructor.problem.descriptor:
    text: 'Call to ''abstract'' method <code>#ref()</code> during object construction #loc'
abstract.method.overrides.abstract.method.display.name:
    text: Abstract method overrides abstract method
abstract.method.overrides.abstract.method.ignore.different.annotations.option:
    text: Ignore methods with different annotations than their super methods
abstract.method.overrides.abstract.method.ignore.different.javadoc.option:
    text: Ignore methods with different Javadoc than their super methods
abstract.method.overrides.abstract.method.problem.descriptor:
    text: 'Abstract method <code>#ref()</code> overrides abstract method #loc'
abstract.method.overrides.abstract.method.remove.quickfix:
    text: Remove redundant abstract method declaration
abstract.method.overrides.concrete.method.display.name:
    text: Abstract method overrides concrete method
abstract.method.overrides.concrete.method.problem.descriptor:
    text: 'Abstract method <code>#ref()</code> overrides concrete method #loc'
abstract.method.with.missing.implementations.display.name:
    text: Abstract method with missing implementations
abstract.method.with.missing.implementations.problem.descriptor:
    text: 'Abstract method <code>#ref()</code> is not implemented in every subclass #loc'
access.to.non.thread.safe.static.field.from.instance.class.chooser.title:
    text: Choose Non-Thread-Safe Class
access.to.non.thread.safe.static.field.from.instance.display.name:
    text: Non-thread-safe 'static' field access
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor:
    text: 'Access to non-thread-safe static field <code>#ref</code> of type ''''{0}'''' #loc'
access.to.non.thread.safe.static.field.from.instance.option.title:
    text: Non-thread-safe classes
access.to.static.field.locked.on.instance.display.name:
    text: Access to 'static' field locked on instance data
access.to.static.field.locked.on.instance.problem.descriptor:
    text: 'Access to static field <code>#ref</code> locked on instance data #loc'
accessing.non.public.field.of.another.object.display.name:
    text: Accessing a non-public field of another object
accessing.non.public.field.of.another.object.problem.descriptor:
    text: 'Direct access to non-public field <code>#ref</code> of another object #loc'
add.0.to.ignore.if.annotated.by.list.quickfix:
    text: Add ''{0}'' to ''Ignore if annotated by'' list
add.serialversionuidfield.quickfix:
    text: Add 'serialVersionUID' field
add.this.qualifier.quickfix:
    text: Add 'this' qualifier
all.levels.option:
    text: all log levels
allow.resource.to.be.opened.inside.a.try.block:
    text: Allow resource to be opened inside a 'try' block
ambiguous.field.access.display.name:
    text: Access to inherited field looks like access to element from surrounding code
ambiguous.field.access.hides.field.problem.descriptor:
    text: 'Access of field <code>#ref</code> from superclass ''''{0}'''' looks like access of field from surrounding class #loc'
ambiguous.field.access.hides.local.variable.problem.descriptor:
    text: 'Access of field <code>#ref</code> from superclass ''''{0}'''' looks like access of local variable #loc'
ambiguous.field.access.hides.parameter.problem.descriptor:
    text: 'Access of field <code>#ref</code> from superclass ''''{0}'''' looks like access of parameter #loc'
ambiguous.field.access.quickfix:
    text: Add 'super' qualifier to field access
ambiguous.method.call.display.name:
    text: Call to inherited method looks like call to local method
ambiguous.method.call.problem.descriptor:
    text: 'Call to method <code>#ref()</code> from superclass ''''{0}'''' looks like call to method from class ''''{1}'''' #loc'
ambiguous.method.call.quickfix:
    text: Add 'super' qualifier to method call
annotation.class.display.name:
    text: Annotation interface
annotation.class.problem.descriptor:
    text: 'Annotation interface <code>#ref</code> #loc'
annotation.display.name:
    text: Annotation
annotation.naming.convention.display.name:
    text: Annotation naming convention
annotation.naming.convention.element.description:
    text: Annotation interface
annotation.naming.convention.problem.descriptor.long:
    text: 'Annotation name <code>#ref</code> is too long #loc'
annotation.naming.convention.problem.descriptor.regex.mismatch:
    text: 'Annotation name <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
annotation.naming.convention.problem.descriptor.short:
    text: 'Annotation name <code>#ref</code> is too short #loc'
annotation.problem.descriptor:
    text: 'Annotation <code>#ref</code> #loc'
anonymous.class.field.hides.containing.method.variable.problem.descriptor:
    text: 'Anonymous class field <code>#ref</code> hides variable in containing method #loc'
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor:
    text: 'Anonymous class parameter <code>#ref</code> hides variable in containing method #loc'
anonymous.class.variable.hides.containing.method.variable.display.name:
    text: Anonymous class variable hides variable in containing method
anonymous.class.variable.hides.containing.method.variable.problem.descriptor:
    text: 'Anonymous class local variable <code>#ref</code> hides variable in containing method #loc'
anonymous.extends.concrete.collection.problem.descriptor:
    text: 'Anonymous class explicitly extends ''''{0}'''' #loc'
anonymous.extends.thread.problem.descriptor:
    text: 'Anonymous class directly extends ''java.lang.Thread'' #loc'
anonymous.extends.throwable.problem.descriptor:
    text: 'Anonymous class directly extends ''java.lang.Throwable'' #loc'
anonymous.inner.class.display.name:
    text: Anonymous class can be replaced with inner class
anonymous.inner.class.problem.descriptor:
    text: 'Anonymous class <code>#ref</code> #loc'
anonymous.inner.class.with.too.many.methods.display.name:
    text: Anonymous class with too many methods
anonymous.inner.class.with.too.many.methods.problem.descriptor:
    text: 'Anonymous class with too many methods (method count = {0}) #loc'
anonymous.inner.may.be.named.static.inner.class.display.name:
    text: Anonymous class may be a named 'static' inner class
anonymous.inner.may.be.named.static.inner.class.problem.descriptor:
    text: 'Anonymous class <code>#ref</code> may be a named ''static'' inner class #loc'
anonymous.inner.may.be.named.static.inner.class.quickfix:
    text: Convert to named 'static' inner class
any.method.may.close.resource.argument:
    text: Any method may close resource argument
archaic.system.property.accessors.display.name:
    text: Use of archaic system property accessors
archaic.system.property.accessors.problem.descriptor.Boolean:
    text: 'Call to <code>Boolean.#ref()</code> accesses system properties, perhaps confusingly #loc'
archaic.system.property.accessors.problem.descriptor.Integer:
    text: 'Call to <code>Integer.#ref()</code> accesses system properties, perhaps confusingly #loc'
archaic.system.property.accessors.problem.descriptor.Long:
    text: 'Call to <code>Long.#ref()</code> accesses system properties, perhaps confusingly #loc'
archaic.system.property.accessors.replace.parse.quickfix:
    text: Replace with parse method
archaic.system.property.accessors.replace.standard.quickfix:
    text: Replace with standard property access
array.allocation.zero.length.display.name:
    text: Zero-length array allocation
array.allocation.zero.length.problem.descriptor:
    text: 'Allocation of zero length array #loc'
array.comparison.display.name:
    text: Array comparison using '==', instead of 'Arrays.equals()'
array.comparison.problem.descriptor:
    text: 'Array objects are compared using <code>#ref</code>, not ''Arrays.equals()'' #loc'
array.creation.without.new.keyword.family.quickfix:
    text: Add 'new' expression
array.creation.without.new.keyword.name:
    text: Array creation without 'new' expression
array.creation.without.new.keyword.quickfix:
    text: Add ''new {0}''
array.hash.code.display.name:
    text: '''hashCode()'' called on array'
array.hash.code.problem.descriptor:
    text: '<code>#ref()</code> called on array should probably be ''Arrays.hashCode()'' #loc'
array.length.in.loop.condition.display.name:
    text: Array.length in loop condition
array.length.in.loop.condition.problem.descriptor:
    text: 'Check of array <code>#ref</code> in loop condition #loc'
array.objects.deep.equals.problem.descriptor:
    text: '<code>Objects.#ref()</code> on arrays should probably be ''Arrays.deepEquals()'' #loc'
array.objects.equals.display.name:
    text: '''Objects.equals()'' called on arrays'
array.objects.equals.problem.descriptor:
    text: '<code>Objects.#ref()</code> on arrays should probably be ''Arrays.equals()'' #loc'
arrays.as.list.with.one.argument.problem.descriptor:
    text: 'Call to <code>#ref()</code> with only one argument #loc'
arrays.as.list.with.one.argument.quickfix:
    text: Replace with call to 'Collections.singletonList()'
arrays.as.list.with.zero.arguments.problem.descriptor:
    text: 'Call to <code>#ref()</code> to create an empty List #loc'
arrays.as.list.with.zero.arguments.quickfix:
    text: Replace with call to 'Collections.emptyList()'
arrays.as.list.with.zero.or.one.argument.display.name:
    text: Call to 'Arrays.asList()' with too few arguments
arrays.deep.hash.code.quickfix:
    text: Replace with 'Arrays.deepHashCode()'
arrays.hash.code.quickfix:
    text: Replace with 'Arrays.hashCode()'
assert.can.be.if.quickfix:
    text: Replace 'assert' with 'if' statement
assert.keyword.is.considered.an.assertion:
    text: '''assert'' keyword is considered an assertion'
assert.message.not.string.display.name:
    text: '''assert'' message is not a string'
assert.message.not.string.only.warn.boolean.option:
    text: Only warn when 'assert' message is 'boolean' or 'java.lang.Boolean'
assert.message.of.type.boolean.problem.descriptor:
    text: '''''assert'''' message of type ''''{0}'''' #loc'
assert.statement.display.name:
    text: '''assert'' statement'
assert.with.side.effects.display.name:
    text: '''assert'' statement with side effects'
assert.with.side.effects.problem.descriptor:
    text: '<code>#ref</code> has side effects #loc'
assertequals.between.inconvertible.types.display.name:
    text: '''assertEquals()'' between objects of inconvertible types'
assertequals.between.inconvertible.types.problem.descriptor:
    text: '<code>#ref()</code> between objects of inconvertible types ''''{0}'''' and ''''{1}'''' #loc'
assertequals.called.on.arrays.display.name:
    text: '''assertEquals()'' called on array'
assertequals.called.on.arrays.problem.descriptor:
    text: '<code>#ref()</code> called on array #loc'
assertequals.called.on.arrays.quickfix:
    text: Replace with 'assertArrayEquals()'
assertequals.may.be.assertsame.display.name:
    text: '''assertEquals()'' may be ''assertSame()'''
assertequals.may.be.assertsame.problem.descriptor:
    text: '<code>#ref()</code> may be ''assertSame()'' #loc'
assertequals.may.be.assertsame.quickfix:
    text: Replace with 'assertSame()'
assertion.can.be.if.name:
    text: Assertion can be replaced with 'if' statement
asserts.without.messages.display.name:
    text: Message missing on assertion
asserts.without.messages.problem.descriptor:
    text: 'JUnit <code>#ref()</code> without message #loc'
assignment.collection.array.field.from.parameter.display.name:
    text: Assignment to Collection or array field from parameter
assignment.collection.array.field.from.parameter.problem.descriptor.array:
    text: 'Assignment to array field <code>#ref</code> from parameter ''''{0}'''' #loc'
assignment.collection.array.field.from.parameter.problem.descriptor.collection:
    text: 'Assignment to Collection field <code>#ref</code> from parameter ''''{0}'''' #loc'
assignment.collection.array.field.option:
    text: Ignore assignments in 'private' methods
assignment.replaceable.with.operator.assignment.display.name:
    text: Assignment can be replaced with operator assignment
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option:
    text: Ignore conditional operators
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option:
    text: Ignore the obscure ^ and % operators
assignment.replaceable.with.operator.assignment.problem.descriptor:
    text: '<code>#ref</code> can be simplified to ''''{0}'''' #loc'
assignment.replaceable.with.operator.replace.quickfix:
    text: Replace ''='' with ''{0}=''
assignment.to.catch.block.parameter.display.name:
    text: Assignment to 'catch' block parameter
assignment.to.catch.block.parameter.problem.descriptor:
    text: 'Assignment to ''catch'' block parameter <code>#ref</code> #loc'
assignment.to.date.calendar.field.from.parameter.display.name:
    text: Assignment to Date or Calendar field from parameter
assignment.to.date.calendar.field.from.parameter.problem.descriptor:
    text: 'Assignment to ''''{0}'''' field <code>#ref</code> from parameter {1} #loc'
assignment.to.for.loop.parameter.check.foreach.option:
    text: Check enhanced 'for' loop parameters
assignment.to.for.loop.parameter.display.name:
    text: Assignment to 'for' loop parameter
assignment.to.for.loop.parameter.problem.descriptor:
    text: 'Assignment to for-loop parameter <code>#ref</code> #loc'
assignment.to.lambda.parameter.display.name:
    text: Assignment to lambda parameter
assignment.to.lambda.parameter.problem.descriptor:
    text: 'Assignment to lambda parameter <code>#ref</code> #loc'
assignment.to.method.parameter.display.name:
    text: Assignment to method parameter
assignment.to.method.parameter.ignore.transformation.option:
    text: <html>Ignore if assignment is a transformation of the original parameter</html>
assignment.to.method.parameter.problem.descriptor:
    text: 'Assignment to method parameter <code>#ref</code> #loc'
assignment.to.null.display.name:
    text: '''null'' assignment'
assignment.to.null.option:
    text: Ignore assignments to fields
assignment.to.null.problem.descriptor:
    text: '''null'' assigned to variable <code>#ref</code> #loc'
assignment.to.static.field.from.instance.method.display.name:
    text: Assignment to static field from instance context
assignment.to.static.field.from.instance.method.problem.descriptor:
    text: 'Assignment to static field <code>#ref</code> from instance context #loc'
assignment.to.superclass.field.display.name:
    text: Constructor assigns value to field defined in superclass
assignment.to.superclass.field.problem.descriptor:
    text: 'Assignment to field ''''{0}'''' defined in superclass ''''{1}'''' #loc'
assignment.used.as.condition.display.name:
    text: Assignment used as condition
assignment.used.as.condition.problem.descriptor:
    text: 'Assignment <code>#ref</code> used as condition #loc'
assignment.used.as.condition.replace.quickfix:
    text: Replace '=' with '=='
atomic.field.updater.issues.display.name:
    text: Inconsistent 'AtomicFieldUpdater' declaration
atomic.field.updater.not.static.final.display.name:
    text: '''AtomicFieldUpdater'' field not declared ''static final'''
atomic.field.updater.not.static.final.problem.descriptor:
    text: '{0} field <code>#ref</code> is not declared ''''static final'''' #loc'
auto.boxing.display.name:
    text: Auto-boxing
auto.boxing.ignore.added.to.collection.option:
    text: Ignore expressions added to a collection
auto.boxing.make.boxing.explicit.quickfix:
    text: Make boxing explicit
auto.boxing.problem.descriptor:
    text: 'Auto-boxing <code>#ref</code> #loc'
auto.closeable.resource.display.name:
    text: AutoCloseable used without 'try'-with-resources
auto.closeable.resource.problem.descriptor:
    text: '''''{0}'''' used without ''''try''''-with-resources statement #loc'
auto.closeable.resource.quickfix:
    text: Ignore 'AutoCloseable' returned by this method
auto.closeable.resource.returned.option:
    text: Ignore AutoCloseable instances returned from all method calls
auto.unboxing.display.name:
    text: Auto-unboxing
auto.unboxing.make.unboxing.explicit.quickfix:
    text: Make unboxing explicit
auto.unboxing.problem.descriptor:
    text: 'Auto-unboxing <code>#ref</code> #loc'
await.not.in.loop.display.name:
    text: '''await()'' not called in loop'
await.not.in.loop.problem.descriptor:
    text: 'Call to <code>#ref()</code> is not in loop #loc'
await.without.corresponding.signal.display.name:
    text: '''await()'' without corresponding ''signal()'''
await.without.corresponding.signal.problem.descriptor:
    text: 'Call to <code>#ref()</code> without corresponding <code>signal()</code> or <code>signalAll()</code> #loc'
bad.exception.caught.display.name:
    text: Prohibited 'Exception' caught
bad.exception.caught.problem.descriptor:
    text: 'Prohibited exception <code>#ref</code> caught #loc'
bad.exception.declared.display.name:
    text: Prohibited exception declared
bad.exception.declared.problem.descriptor:
    text: 'Prohibited exception <code>#ref</code> declared #loc'
bad.exception.thrown.display.name:
    text: Prohibited exception thrown
bad.exception.thrown.problem.descriptor:
    text: 'Prohibited exception ''''{0}'''' thrown #loc'
bad.oddness.display.name:
    text: Suspicious oddness check
bad.oddness.problem.descriptor:
    text: 'Test for oddness <code>#ref</code> will fail on negative values #loc'
before.class.or.after.class.is.public.static.void.no.arg.display.name:
    text: Malformed @BeforeClass/@BeforeAll or @AfterClass/@AfterAll method
before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor:
    text: '<code>#ref()</code> has incorrect signature for a @{0} method #loc'
before.or.after.is.public.void.no.arg.display.name:
    text: Malformed @Before or @After method
before.or.after.is.public.void.no.arg.problem.descriptor:
    text: '<code>#ref()</code> has incorrect signature for a @Before or @After method #loc'
big.decimal.equals.display.name:
    text: '''equals()'' called on ''BigDecimal'''
big.decimal.equals.problem.descriptor:
    text: '<code>#ref()</code> between BigDecimal values should probably be ''compareTo()'' #loc'
big.decimal.equals.replace.quickfix:
    text: Replace with 'compareTo()==0'
big.decimal.method.without.rounding.called.display.name:
    text: Call to 'BigDecimal' method without a rounding mode argument
big.decimal.method.without.rounding.called.problem.descriptor:
    text: '''BigDecimal.#ref()'' called without a rounding mode argument'
bigdecimal.legacy.method.display.name:
    text: '''BigDecimal'' legacy method called'
bigdecimal.legacy.method.problem.descriptor:
    text: Call to 'BigDecimal.#ref()' can use 'RoundingMode' enum constant
bigdecimal.legacy.method.quickfix:
    text: Use 'RoundingMode' enum constant
boolean.constructor.display.name:
    text: Boolean constructor call
boolean.constructor.problem.descriptor:
    text: 'Boolean constructor call #loc'
boolean.constructor.simplify.quickfix:
    text: Simplify
boolean.expression.can.be.simplified.problem.descriptor:
    text: '<code>#ref</code> can be simplified to ''''{0}'''' #loc'
boolean.expression.may.be.conditional.display.name:
    text: Boolean expression can be replaced with conditional expression
boolean.field.always.inverted.problem.descriptor:
    text: 'Boolean field <code>#ref</code> is always inverted #loc'
boolean.method.name.must.start.with.question.display.name:
    text: Boolean method name must start with question word
boolean.method.name.must.start.with.question.problem.descriptor:
    text: 'Boolean method name <code>#ref</code> does not start with question word #loc'
boolean.method.name.must.start.with.question.table.column.name:
    text: Boolean method name prefix
boolean.parameter.constructor.problem.descriptor:
    text: '''public'' constructor <code>#ref()</code> with ''boolean'' parameter #loc'
boolean.parameter.display.name:
    text: '''public'' method with ''boolean'' parameter'
boolean.parameter.only.report.multiple.option:
    text: Only report methods with multiple boolean parameters
boolean.parameter.problem.descriptor:
    text: '''public'' method <code>#ref()</code> with ''boolean'' parameter #loc'
boolean.parameters.constructor.problem.descriptor:
    text: '''public'' constructor <code>#ref()</code> with ''boolean'' parameters #loc'
boolean.parameters.problem.descriptor:
    text: '''public'' method <code>#ref()</code> with ''boolean'' parameters #loc'
boolean.variable.always.inverted.display.name:
    text: Boolean variable is always inverted
boolean.variable.always.inverted.problem.descriptor:
    text: 'Boolean variable <code>#ref</code> is always inverted #loc'
boolean.variable.always.inverted.quickfix:
    text: Invert ''{0}''
boxing.boxed.value.display.name:
    text: Boxing of already boxed value
boxing.boxed.value.problem.descriptor:
    text: 'Boxing of already boxed <code>#ref</code> #loc'
boxing.boxed.value.quickfix:
    text: Remove unnecessary boxing
break.statement.display.name:
    text: '''break'' statement'
break.statement.with.label.display.name:
    text: '''break'' statement with label'
break.statement.with.label.problem.descriptor:
    text: '<code>#ref</code> statement with label #loc'
busy.wait.display.name:
    text: Busy wait
busy.wait.problem.descriptor:
    text: 'Call to <code>Thread.#ref()</code> in a loop, probably busy-waiting #loc'
c.style.array.declaration.display.name:
    text: C-style array declaration
c.style.array.declaration.problem.descriptor:
    text: 'C-style array declaration <code>#ref</code> #loc'
c.style.array.declaration.replace.quickfix:
    text: Replace with Java-style array declaration
cached.number.constructor.call.display.name:
    text: Number constructor call with primitive argument
cached.number.constructor.call.ignore.string.arguments.option:
    text: Ignore new number expressions with a String argument
cached.number.constructor.call.problem.descriptor:
    text: 'Number constructor call with primitive argument #loc'
cached.number.constructor.call.quickfix:
    text: Replace with ''{0}.valueOf()'' call
call.to.date.tostring.display.name:
    text: Call to 'Date.toString()'
call.to.date.tostring.problem.descriptor:
    text: '<code>Date.#ref()</code> used in an internationalized context #loc'
call.to.native.method.while.locked.display.name:
    text: Call to a 'native' method while locked
call.to.native.method.while.locked.problem.descriptor:
    text: 'Call to native method <code>#ref()</code> in a synchronized context #loc'
call.to.numeric.tostring.display.name:
    text: Call to 'Number.toString()'
call.to.numeric.tostring.problem.descriptor:
    text: '<code>Number.#ref()</code> called in an internationalized context #loc'
call.to.private.setter.in.class.option:
    text: Only report when setter is 'private'
call.to.private.simple.getter.in.class.option:
    text: Only report when getter is 'private'
call.to.simple.getter.in.class.display.name:
    text: Call to simple getter from within class
call.to.simple.getter.in.class.ignore.option:
    text: Ignore getter calls on other objects
call.to.simple.getter.in.class.inline.quickfix:
    text: Inline call to getter
call.to.simple.getter.in.class.problem.descriptor:
    text: 'Call to simple getter <code>#ref()</code> from within class #loc'
call.to.simple.setter.in.class.display.name:
    text: Call to simple setter from within class
call.to.simple.setter.in.class.ignore.option:
    text: Ignore setter calls on other objects
call.to.simple.setter.in.class.inline.quickfix:
    text: Inline call to setter
call.to.simple.setter.in.class.problem.descriptor:
    text: 'Call to simple setter <code>#ref()</code> from within class #loc'
call.to.string.concat.can.be.replaced.by.operator.display.name:
    text: Call to 'String.concat()' can be replaced with '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor:
    text: 'Call to <code>#ref()</code> can be replaced with ''+'' expression #loc'
call.to.string.concat.can.be.replaced.by.operator.quickfix:
    text: Replace 'concat()' call with '+'
call.to.suspicious.string.method.display.name:
    text: Call to suspicious 'String' method
call.to.suspicious.string.method.problem.descriptor:
    text: '<code>String.#ref()</code> called in internationalized context #loc'
cast.conflicts.with.instanceof.display.name:
    text: Cast conflicts with 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor:
    text: 'Cast <code>#ref</code> conflicts with surrounding ''instanceof'' check #loc'
cast.conflicts.with.instanceof.quickfix1:
    text: Replace ''{0}'' with ''{1}'' in cast
cast.conflicts.with.instanceof.quickfix2:
    text: Replace ''{0}'' with ''{1}'' in instanceof
cast.that.loses.precision.display.name:
    text: Numeric cast that loses precision
cast.that.loses.precision.negative.problem.descriptor:
    text: 'Cast from ''''{0}'''' to <code>#ref</code> may result in loss of precision for negative argument #loc'
cast.that.loses.precision.option:
    text: Ignore casts from int to char
cast.that.loses.precision.problem.descriptor:
    text: 'Cast from ''''{0}'''' to <code>#ref</code> may result in loss of precision #loc'
cast.to.concrete.class.display.name:
    text: Cast to a concrete class
cast.to.concrete.class.ignore.equals.option:
    text: Ignore in equals()
cast.to.concrete.class.option:
    text: Ignore casts to an abstract class type
cast.to.concrete.class.problem.descriptor:
    text: 'Cast to concrete class <code>{0}</code> #loc'
casting.to.incompatible.interface.display.name:
    text: Cast to incompatible type
casting.to.incompatible.interface.problem.descriptor:
    text: 'Cast to incompatible interface <code>#ref</code> #loc'
caught.exception.immediately.rethrown.display.name:
    text: Caught exception is immediately rethrown
caught.exception.immediately.rethrown.problem.descriptor:
    text: 'Caught exception <code>#ref</code> is immediately rethrown #loc'
chain.of.class.equality.checks.problem.descriptor:
    text: 'Chain of class equality checks indicates abstraction failure #loc'
chain.of.instanceof.checks.display.name:
    text: Chain of 'instanceof' checks
chain.of.instanceof.checks.problem.descriptor:
    text: 'Chain of ''instanceof'' checks indicates abstraction failure #loc'
chained.equality.comparisons.display.name:
    text: Chained equality comparisons
chained.equality.comparisons.problem.descriptor:
    text: 'Chained equality comparison <code>#ref</code> #loc'
chained.method.call.display.name:
    text: Chained method calls
chained.method.call.ignore.option:
    text: Ignore chained method calls in field initializers
chained.method.call.ignore.this.super.option:
    text: Ignore chained method calls in 'this()' and 'super()' calls
chained.method.call.problem.descriptor:
    text: 'Chained method call <code>#ref()</code> #loc'
change.modifier.quickfix:
    text: Make ''{0}''
channel.opened.not.closed.display.name:
    text: '''Channel'' opened but not safely closed'
channel.opened.not.closed.problem.descriptor:
    text: '''''{0}'''' should be opened in front of a ''''try'''' block and closed in the corresponding ''''finally'''' block #loc'
char.used.in.arithmetic.context.cast.quickfix:
    text: Insert cast to {0}
char.used.in.arithmetic.context.display.name:
    text: '''char'' expression used in arithmetic context'
char.used.in.arithmetic.context.problem.descriptor:
    text: '''char'' <code>#ref</code> used in arithmetic context #loc'
char.used.in.arithmetic.context.quickfix:
    text: Convert to String literal
character.comparison.display.name:
    text: Character comparison
character.comparison.problem.descriptor:
    text: 'Character comparison <code>#ref</code> in an internationalized context #loc'
checked.exception.class.display.name:
    text: Checked exception class
checked.exception.class.problem.descriptor:
    text: 'Checked exception class <code>#ref</code> #loc'
choose.autocloseable.type.to.ignore.title:
    text: Choose AutoCloseable Resource Type to Ignore
choose.class:
    text: Choose Class
choose.class.type.to.ignore:
    text: Choose Class to Ignore
choose.exception.class:
    text: Choose Exception Class
choose.io.resource.type.to.ignore:
    text: Choose I/O Resource Type to Ignore
choose.logger.class:
    text: Choose Logger Class
choose.super.class.to.ignore:
    text: Choose class
class.escapes.defined.scope.display.module.option:
    text: Report non-exported classes exposed in module API (Java 9+)
class.escapes.defined.scope.display.name:
    text: Class is exposed outside of its visibility scope
class.escapes.defined.scope.display.package.option:
    text: Report private classes exposed in package-local API
class.escapes.defined.scope.display.public.option:
    text: Report non-accessible classes exposed in public API
class.escapes.defined.scope.java9.modules.descriptor:
    text: Class <code>#ref</code> is not exported from module ''{0}''
class.escapes.defined.scope.problem.descriptor:
    text: 'Class <code>#ref</code> is exposed outside its defined visibility scope #loc'
class.extends.utility.class.display.name:
    text: Class extends utility class
class.extends.utility.class.ignore.utility.class.option:
    text: Ignore if overriding class is a utility class
class.extends.utility.class.problem.descriptor:
    text: 'Class <code>#ref</code> extends utility class ''''{0}'''' #loc'
class.independent.of.module.display.name:
    text: Class independent of its module
class.independent.of.module.problem.descriptor:
    text: 'Class <code>#ref</code> has no dependencies or dependents in its module #loc'
class.initializer.display.name:
    text: Non-'static' initializer
class.initializer.may.be.static.display.name:
    text: Class initializer may be 'static'
class.initializer.may.be.static.problem.descriptor:
    text: 'Class initializer may be ''static'' #loc'
class.initializer.move.code.to.constructor.quickfix:
    text: Move initializer code to constructor
class.initializer.option:
    text: Only warn when the class has one or more constructors
class.initializer.problem.descriptor:
    text: 'Non-''static'' initializer #loc'
class.loader.instantiation.display.name:
    text: '''ClassLoader'' instantiation'
class.loader.instantiation.problem.descriptor:
    text: 'Instantiation of <code>#ref</code> may pose security concerns #loc'
class.may.be.interface.convert.quickfix:
    text: Convert class to interface
class.may.be.interface.display.name:
    text: Abstract 'class' may be 'interface'
class.may.be.interface.java8.option:
    text: Report classes containing non-abstract methods when using Java 8
class.may.be.interface.problem.descriptor:
    text: 'Abstract class <code>#ref</code> may be interface #loc'
class.name:
    text: Class Name
class.name.convention.problem.descriptor.long:
    text: 'Class name <code>#ref</code> is too long #loc'
class.name.convention.problem.descriptor.regex.mismatch:
    text: 'Class name <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
class.name.convention.problem.descriptor.short:
    text: 'Class name <code>#ref</code> is too short #loc'
class.name.differs.from.file.name.display.name:
    text: Class name differs from file name
class.name.differs.from.file.name.problem.descriptor:
    text: 'Class name <code>#ref</code> differs from file name #loc'
class.name.prefixed.with.package.name.display.name:
    text: Class name prefixed with package name
class.name.prefixed.with.package.name.problem.descriptor:
    text: 'Class name <code>#ref</code> begins with its package name #loc'
class.name.same.as.ancestor.name.display.name:
    text: Class name same as ancestor name
class.name.same.as.ancestor.name.problem.descriptor:
    text: 'Class name <code>#ref</code> is the same as one of its superclass'' names #loc'
class.naming.convention.display.name:
    text: Class naming convention
class.naming.convention.element.description:
    text: Class
class.new.instance.display.name:
    text: Unsafe call to 'Class.newInstance()'
class.new.instance.problem.descriptor:
    text: 'Call to <code>#ref()</code> may throw undeclared checked exceptions #loc'
class.new.instance.quickfix:
    text: Replace with 'Class.getConstructor().newInstance()' call
class.only.used.from.test.code.problem.descriptor:
    text: 'class <code>#ref</code> only used from test code #loc'
class.only.used.in.one.module.display.name:
    text: Class only used from one other module
class.only.used.in.one.module.problem.descriptor:
    text: 'Class <code>#ref</code> has only dependencies on and/or dependents in module ''''{0}'''' #loc'
class.only.used.in.one.package.display.name:
    text: Class only used from one other package
class.only.used.in.one.package.problem.descriptor:
    text: 'Class <code>#ref</code> has only dependencies on and/or dependents in package ''''{0}'''' #loc'
class.references.subclass.display.name:
    text: Class references one of its subclasses
class.references.subclass.problem.descriptor:
    text: 'Class ''''{0}'''' references subclass <code>#ref</code> #loc'
class.references.subclass.problem.descriptor.anonymous:
    text: 'Anonymous class references subclass <code>#ref</code> #loc'
class.too.deep.display.name:
    text: Class too deep in inheritance tree
class.too.deep.inheritance.depth.limit.option:
    text: 'Inheritance depth limit:'
class.too.deep.problem.descriptor:
    text: '<code>#ref</code> is too deep in inheritance tree (inheritance depth = {0}) #loc'
class.unconnected.to.package.display.name:
    text: Class independent of its package
class.unconnected.to.package.problem.descriptor:
    text: Class <code>#ref</code> has no dependencies or dependents in its package
class.with.only.private.constructors.display.name:
    text: Class with only 'private' constructors should be declared 'final'
class.with.only.private.constructors.problem.descriptor:
    text: Class <code>#ref</code> with only 'private' constructors should be declared 'final'
class.with.too.many.dependencies.display.name:
    text: Class with too many dependencies
class.with.too.many.dependencies.max.option:
    text: Maximum number of dependencies
class.with.too.many.dependencies.problem.descriptor:
    text: Class ''{0}'' has too many dependencies ({1} > {2})
class.with.too.many.dependents.display.name:
    text: Class with too many dependents
class.with.too.many.dependents.max.option:
    text: Maximum number of dependents
class.with.too.many.dependents.problem.descriptor:
    text: Class ''{0}'' has too many dependents ({1} > {2})
class.with.too.many.transitive.dependencies.display.name:
    text: Class with too many transitive dependencies
class.with.too.many.transitive.dependencies.max.option:
    text: Maximum number of transitive dependencies
class.with.too.many.transitive.dependencies.problem.descriptor:
    text: Class ''{0}'' has too many transitive dependencies ({1} > {2})
class.with.too.many.transitive.dependents.display.name:
    text: Class with too many transitive dependents
class.with.too.many.transitive.dependents.max.option:
    text: Maximum number of transitive dependents
class.with.too.many.transitive.dependents.problem.descriptor:
    text: Class ''{0}'' has too many transitive dependencies ({1} > {2})
class.without.constructor.create.quickfix:
    text: Generate empty constructor
class.without.constructor.display.name:
    text: Class without constructor
class.without.constructor.problem.descriptor:
    text: 'Class <code>#ref</code> has no constructor #loc'
class.without.no.arg.constructor.display.name:
    text: Class without no-arg constructor
class.without.no.arg.constructor.ignore.option:
    text: Ignore if class has default constructor
class.without.no.arg.constructor.problem.descriptor:
    text: 'Class <code>#ref</code> is missing a no-arg constructor #loc'
class.without.tostring.display.name:
    text: Class without 'toString()'
class.without.tostring.problem.descriptor:
    text: 'Class <code>#ref</code> should probably implement ''toString()'', for debugging purposes #loc'
clone.doesnt.call.super.clone.display.name:
    text: '''clone()'' does not call ''super.clone()'''
clone.doesnt.call.super.clone.problem.descriptor:
    text: '<code>#ref()</code> does not call ''super.clone()'' #loc'
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix:
    text: Add 'CloneNotSupportedException' to throws clause
clone.doesnt.declare.clonenotsupportedexception.display.name:
    text: '''clone()'' does not declare ''CloneNotSupportedException'''
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor:
    text: '<code>#ref()</code> #loc does not declare ''CloneNotSupportedException'''
clone.instantiates.objects.with.constructor.display.name:
    text: '''clone()'' instantiates objects with constructor'
clone.instantiates.objects.with.constructor.problem.descriptor:
    text: '''clone()'' creates new <code>#ref</code> instances #loc'
clone.method.in.non.cloneable.class.display.name:
    text: '''clone()'' method in non-Cloneable class'
clone.method.in.non.cloneable.class.problem.descriptor:
    text: '<code>#ref()</code> defined in non-Cloneable class ''''{0}'''' #loc'
clone.method.in.non.cloneable.interface.problem.descriptor:
    text: '<code>#ref()</code> defined in non-Cloneable interface ''''{0}'''' #loc'
clone.returns.class.type.display.name:
    text: '''clone()'' should have return type equal to the class it contains'
clone.returns.class.type.family.quickfix:
    text: Change return type to class type
clone.returns.class.type.problem.descriptor:
    text: '''''clone()'''' should have return type ''''{0}'''' #loc'
clone.returns.class.type.quickfix:
    text: Change return type to ''{0}''
cloneable.class.in.secure.context.display.name:
    text: Cloneable class in secure context
cloneable.class.in.secure.context.problem.descriptor:
    text: 'Class <code>#ref</code> may be cloned, compromising security #loc'
cloneable.class.without.clone.display.name:
    text: Cloneable class without 'clone()' method
cloneable.class.without.clone.ignore.option:
    text: Ignore classes cloneable due to inheritance
cloneable.class.without.clone.problem.descriptor:
    text: '<code>#ref</code> is ''Cloneable'' but does not define ''clone()'' method #loc'
cloneable.class.without.clone.quickfix:
    text: Generate 'clone()' method
collection.added.to.self.display.name:
    text: Collection added to itself
collection.added.to.self.problem.descriptor:
    text: 'Collection <code>#ref</code> is added to self #loc'
collection.contains.url.display.name:
    text: Map or Set may contain 'java.net.URL' objects
collection.contains.url.problem.decriptor:
    text: '{0} <code>#ref</code> may contain URL objects #loc'
collection.declared.by.class.display.name:
    text: Collection declared by class, not interface
collection.declared.by.class.ignore.locals.option:
    text: Ignore local variables
collection.declared.by.class.ignore.private.members.option:
    text: Ignore 'private' fields and methods
collection.declared.by.class.problem.descriptor:
    text: 'Declaration of <code>#ref</code> should probably be weakened to ''''{0}'''' #loc'
collections.field.access.replaceable.by.method.call.display.name:
    text: Reference to empty collection field can be replaced with method call
collections.field.access.replaceable.by.method.call.problem.descriptor:
    text: '<code>#ref</code> can be replaced with ''''Collections.{0}'''' #loc'
collections.field.access.replaceable.by.method.call.quickfix:
    text: Replace with ''{0}''
collections.must.have.initial.capacity.display.name:
    text: Collection without initial capacity
collections.must.have.initial.capacity.problem.descriptor:
    text: '<code>new #ref()</code> without initial capacity #loc'
comparable.implemented.but.equals.not.overridden.display.name:
    text: '''Comparable'' implemented but ''equals()'' not overridden'
comparable.implemented.but.equals.not.overridden.problem.descriptor:
    text: 'Class <code>#ref</code> implements ''java.lang.Comparable'' but does not override ''equals()'' #loc'
comparator.method.parameter.not.used.display.name:
    text: '''Comparator.compare()'' method does not use parameter'
comparator.method.parameter.not.used.problem.descriptor:
    text: '''compare()'' parameter <code>#ref</code> is not used #loc'
comparator.not.serializable.display.name:
    text: '''Comparator'' class not declared ''Serializable'''
comparator.not.serializable.problem.descriptor:
    text: 'Comparator class <code>#ref</code> is not declared as Serializable #loc'
comparison.of.short.and.char.display.name:
    text: Comparison of 'short' and 'char' values
comparison.of.short.and.char.problem.descriptor:
    text: 'Equality comparison <code>#ref</code> of short and char values #loc'
comparison.to.nan.display.name:
    text: Comparison to 'Double.NaN' or 'Float.NaN'
comparison.to.nan.problem.descriptor1:
    text: 'Comparison to <code>#ref</code> is always false #loc'
comparison.to.nan.problem.descriptor2:
    text: 'Comparison to <code>#ref</code> is always true #loc'
comparison.to.nan.replace.quickfix:
    text: Replace with 'isNaN()'
concrete.class.method.parameter.display.name:
    text: Method parameter of concrete class
concrete.class.method.parameter.problem.descriptor:
    text: 'Parameter ''''{0}'''' of concrete class <code>#ref</code> #loc'
condition.signal.display.name:
    text: Call to 'signal()' instead of 'signalAll()'
condition.signal.problem.descriptor:
    text: '<code>#ref</code> should probably be replaced with ''signalAll()'' #loc'
condition.signal.replace.quickfix:
    text: Replace with 'signalAll()'
conditional.can.be.pushed.inside.expression.display.name:
    text: Conditional can be pushed inside branch expression
conditional.can.be.pushed.inside.expression.option:
    text: Ignore when conditional will be only argument of a method call
conditional.can.be.pushed.inside.expression.problem.descriptor:
    text: 'Conditional expression can be pushed inside branch #loc'
conditional.can.be.pushed.inside.expression.quickfix:
    text: Push conditional expression inside branch
conditional.expression.display.name:
    text: Conditional expression (?:)
conditional.expression.option:
    text: Ignore for simple assignments and returns
conditional.expression.problem.descriptor:
    text: 'Conditional expression <code>#ref</code> #loc'
conditional.expression.with.identical.branches.collapse.quickfix:
    text: Collapse conditional expression
conditional.expression.with.identical.branches.display.name:
    text: Conditional expression with identical branches
conditional.expression.with.identical.branches.problem.descriptor:
    text: 'Conditional expression <code>#ref</code> with identical branches #loc'
conditional.expression.with.identical.branches.push.inside.quickfix:
    text: Push conditional inside expression
conditional.expression.with.similar.branches.problem.descriptor:
    text: 'Conditional expression <code>#ref</code> with similar branches #loc'
confusing.else.display.name:
    text: Confusing 'else' branch
confusing.else.option:
    text: Report when there are no more statements after the 'if' statement
confusing.else.problem.descriptor:
    text: '<code>#ref</code> branch may be unwrapped, as the ''if'' branch never completes #loc'
confusing.else.unwrap.quickfix:
    text: Remove redundant 'else'
confusing.floating.point.literal.change.quickfix:
    text: Change to canonical form
confusing.floating.point.literal.display.name:
    text: Confusing floating-point literal
confusing.floating.point.literal.option:
    text: Ignore floating-point literals in scientific notation
confusing.floating.point.literal.problem.descriptor:
    text: 'Confusing floating-point literal <code>#ref</code> #loc'
confusing.main.method.display.name:
    text: Confusing 'main()' method
confusing.main.method.problem.descriptor:
    text: 'Method <code>#ref()</code> does not have signature ''public static void main(String[])'' #loc'
confusing.octal.escape.sequence.display.name:
    text: Confusing octal escape sequence
confusing.octal.escape.sequence.problem.descriptor:
    text: 'Octal escape sequence <code>#ref</code> immediately followed by a digit #loc'
connection.opened.not.safely.closed.display.name:
    text: Connection opened but not safely closed
consider.static.final.fields.constant.option:
    text: Consider 'static final' fields constant
constant.assert.condition.display.name:
    text: Constant condition in 'assert' statement
constant.assert.condition.problem.descriptor:
    text: 'Assert condition <code>#ref</code> is constant #loc'
constant.conditional.expression.display.name:
    text: Constant conditional expression
constant.conditional.expression.problem.descriptor:
    text: '<code>#ref</code> can be simplified to ''''{0}'''' #loc'
constant.conditional.expression.simplify.quickfix:
    text: Simplify
constant.declared.in.abstract.class.display.name:
    text: Constant declared in 'abstract' class
constant.declared.in.abstract.class.problem.descriptor:
    text: 'Constant <code>#ref</code> declared in abstract class #loc'
constant.declared.in.interface.display.name:
    text: Constant declared in interface
constant.declared.in.interface.problem.descriptor:
    text: 'Constant <code>#ref</code> declared in interface #loc'
constant.for.zero.length.array.display.name:
    text: Unnecessary zero length array usage
constant.for.zero.length.array.problem.descriptor:
    text: 'Zero length array can be changed to constant #loc'
constant.for.zero.length.array.quickfix.family:
    text: Replace with constant
constant.if.statement.display.name:
    text: Constant 'if' statement
constant.if.statement.problem.descriptor:
    text: '<code>#ref</code> statement can be simplified #loc'
constant.junit.assert.argument.display.name:
    text: Constant assert argument
constant.junit.assert.argument.problem.descriptor:
    text: 'Argument <code>#ref</code> is constant #loc'
constant.math.call.display.name:
    text: Constant call to 'Math'
constant.math.call.problem.descriptor:
    text: 'Constant call to <code>#ref()</code> can be simplified #loc'
constant.naming.convention.display.name:
    text: Constant naming convention
constant.naming.convention.element.description:
    text: Constant
constant.naming.convention.immutables.option:
    text: Only check 'static final' fields with immutable types
constant.naming.convention.problem.descriptor.long:
    text: 'Constant name <code>#ref</code> is too long #loc'
constant.naming.convention.problem.descriptor.regex.mismatch:
    text: 'Constant <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
constant.naming.convention.problem.descriptor.short:
    text: 'Constant name <code>#ref</code> is too short #loc'
constant.on.lhs.of.comparison.display.name:
    text: Constant on left side of comparison
constant.on.lhs.of.comparison.problem.descriptor:
    text: 'Constant <code>#ref</code> on the left side of the comparison #loc'
constant.on.rhs.of.comparison.display.name:
    text: Constant on right side of comparison
constant.on.rhs.of.comparison.problem.descriptor:
    text: 'Constant <code>#ref</code> on the right side of the comparison #loc'
constant.string.intern.display.name:
    text: Call to 'intern()' on String constant
constant.string.intern.problem.descriptor:
    text: '<code>.#ref()</code> on compile-time constant is unnecessary #loc'
constant.string.intern.quickfix:
    text: Remove 'intern()' call
constant.value.variable.use.display.name:
    text: Use of variable whose value is known to be constant
constant.value.variable.use.problem.descriptor:
    text: 'Value of <code>#ref</code> is known to be constant #loc'
constructor.visibility.option:
    text: 'Ignore constructors with visibility:'
continue.or.break.from.finally.block.display.name:
    text: '''continue'' or ''break'' inside ''finally'' block'
continue.or.break.from.finally.block.problem.descriptor:
    text: '<code>#ref</code> inside ''finally'' block #loc'
continue.statement.display.name:
    text: '''continue'' statement'
continue.statement.with.label.display.name:
    text: '''continue'' statement with label'
continue.statement.with.label.problem.descriptor:
    text: '<code>#ref</code> statement with label #loc'
control.flow.statement.without.braces.add.quickfix:
    text: Add braces to statement
control.flow.statement.without.braces.display.name:
    text: Control flow statement without braces
control.flow.statement.without.braces.message:
    text: Add braces to ''{0}'' statement
control.flow.statement.without.braces.problem.descriptor:
    text: '<code>#ref</code> without braces #loc'
convention.max.length.option:
    text: 'Max length:'
convention.min.length.option:
    text: 'Min length:'
convention.pattern.option:
    text: 'Pattern:'
convert.junit3.test.class.quickfix:
    text: Convert JUnit 3 class ''{0}'' to JUnit 4
convert.octal.literal.to.decimal.literal.quickfix:
    text: Convert octal literal to decimal literal
convert.to.variable.arity.method.quickfix:
    text: Convert to varargs method
covariant.compareto.display.name:
    text: Covariant 'compareTo()'
covariant.compareto.problem.descriptor:
    text: '<code>#ref()</code> should take ''Object'' as its argument #loc'
covariant.equals.display.name:
    text: Covariant 'equals()'
covariant.equals.problem.descriptor:
    text: '<code>#ref()</code> should take ''Object'' as its argument #loc'
cstyle.array.method.declaration.problem.descriptor:
    text: C-style array declaration of the return type of method <code>#ref()</code>#loc
cstyle.array.variable.declaration.problem.descriptor:
    text: 'C-style array declaration of {0, choice, 1#field|2#parameter|3#local variable} <code>#ref</code> #loc'
custom.classloader.display.name:
    text: Custom 'ClassLoader' is declared
custom.classloader.problem.descriptor:
    text: 'Custom ClassLoader class <code>#ref</code> #loc'
custom.security.manager.display.name:
    text: Custom 'SecurityManager'
custom.security.manager.problem.descriptor:
    text: 'Custom SecurityManager class <code>#ref</code> #loc'
cyclic.class.dependency.1.problem.descriptor:
    text: Class ''{0}'' is cyclically dependent on class ''{1}''
cyclic.class.dependency.2.problem.descriptor:
    text: Class ''{0}'' is cyclically dependent on classes ''{1}'' and ''{2}''
cyclic.class.dependency.display.name:
    text: Cyclic class dependency
cyclic.class.dependency.problem.descriptor:
    text: Class ''{0}'' is cyclically dependent on {1} other classes
cyclic.class.initialization.display.name:
    text: Cyclic class initialization dependency
cyclic.class.initialization.problem.descriptor:
    text: Initialization of class ''{0}'' is cyclically dependent on {1} other classes
cyclic.package.dependency.1.problem.descriptor:
    text: Package ''{0}'' is cyclically dependent on package ''{1}''
cyclic.package.dependency.2.problem.descriptor:
    text: Package ''{0}'' is cyclically dependent on packages ''{1}'' and ''{2}''
cyclic.package.dependency.display.name:
    text: Cyclic package dependency
cyclic.package.dependency.problem.descriptor:
    text: Package ''{0}'' is cyclically dependent on {1} other packages
cyclomatic.complexity.display.name:
    text: Overly complex method
cyclomatic.complexity.limit.option:
    text: 'Cyclomatic complexity limit:'
cyclomatic.complexity.problem.descriptor:
    text: 'Overly complex method <code>#ref()</code> (cyclomatic complexity = {0}) #loc'
dangling.javadoc.convert.quickfix:
    text: Replace with block comment
dangling.javadoc.delete.quickfix:
    text: Remove dangling comment
dangling.javadoc.display.name:
    text: Dangling Javadoc comment
dangling.javadoc.problem.descriptor:
    text: 'Dangling Javadoc comment #loc'
debug.level.and.lower.option:
    text: debug level and lower
declare.collection.as.interface.quickfix:
    text: Weaken to ''{0}''
default.not.last.case.in.switch.display.name:
    text: '''default'' not last case in ''switch'''
default.not.last.case.in.switch.problem.descriptor:
    text: '<code>#ref</code> branch not last case in ''switch'' statement #loc'
default.tostring.call.display.name:
    text: Call to default 'toString()'
default.tostring.call.problem.descriptor:
    text: 'Call to default ''toString()'' on <code>#ref</code> #loc'
delete.catch.section.quickfix:
    text: Delete 'catch' section
delete.import.quickfix:
    text: Delete unnecessary import
deserializable.class.in.secure.context.display.name:
    text: Deserializable class in secure context
deserializable.class.in.secure.context.problem.descriptor:
    text: 'Class <code>#ref</code> may be deserialized, compromising security #loc'
design.for.extension.display.name:
    text: Design for extension
design.for.extension.problem.descriptor:
    text: 'Method <code>#ref()</code> may be overridden and its functionality ignored #loc'
diamond.can.be.replaced.with.explicit.type.arguments.name:
    text: Diamond can be replaced with explicit type arguments
diamond.can.be.replaced.with.explicit.type.arguments.quickfix:
    text: Replace '<>' with explicit type arguments
disjoint.package.display.name:
    text: Package with disjoint dependency graph
disjoint.package.problem.descriptor:
    text: Package {0} can be decomposed into {1} independent packages
divide.by.zero.display.name:
    text: Division by zero
divide.by.zero.problem.descriptor:
    text: 'Division by zero #loc'
dollar.sign.in.name.display.name:
    text: Use of '$' in identifier
dollar.sign.in.name.problem.descriptor:
    text: 'Identifier <code>#ref</code> contains ''$'' #loc'
double.brace.initialization.display.name:
    text: Double brace initialization
double.brace.initialization.quickfix:
    text: Replace with regular initialization
double.checked.locking.display.name:
    text: Double-checked locking
double.checked.locking.ignore.on.volatiles.option:
    text: Ignore double-checked locking on volatile fields
double.checked.locking.problem.descriptor:
    text: 'Double-checked locking #loc'
double.checked.locking.quickfix:
    text: Make ''{0}'' volatile
double.literal.may.be.float.literal.display.name:
    text: Cast to 'float' can be 'float' literal
double.literal.may.be.float.literal.problem.descriptor:
    text: '<code>#ref</code> could be replaced with ''''{0}'''' #loc'
double.literal.may.be.float.literal.quickfix:
    text: Replace with ''{0}''
double.negation.display.name:
    text: Double negation
double.negation.problem.descriptor:
    text: 'Double negation in <code>#ref</code> #loc'
double.negation.quickfix:
    text: Remove double negation
drivermanager.call.display.name:
    text: Use of 'DriverManager' to get JDBC connection
drivermanager.call.problem.descriptor:
    text: 'Call to <code>DriverManager.#ref()</code> #loc'
dumpstack.call.display.name:
    text: Call to 'Thread.dumpStack()'
dumpstack.call.problem.descriptor:
    text: 'Call to <code>Thread.#ref()</code> should probably be replaced with more robust logging #loc'
duplicate.boolean.branch.display.name:
    text: Duplicate condition on '\&\&' or '||'
duplicate.boolean.branch.problem.descriptor:
    text: 'Duplicate branch <code>#ref</code> #loc'
duplicate.condition.display.name:
    text: Duplicate condition in 'if' statement
duplicate.condition.ignore.method.calls.option:
    text: Ignore conditions with possible side effects
duplicate.condition.problem.descriptor:
    text: 'Duplicate condition <code>#ref</code> #loc'
dynamic.regex.replaceable.by.compiled.pattern.display.name:
    text: Dynamic regular expression can be replaced by compiled 'Pattern'
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor:
    text: '<code>#ref()</code> can be replaced with compiled ''java.util.regex.Pattern'' construct #loc'
dynamic.regex.replaceable.by.compiled.pattern.quickfix:
    text: Replace with call to method of compiled 'Pattern' constant
element.only.used.from.test.code.display.name:
    text: Symbol only used from test code
empty.anonymous.class.problem.descriptor:
    text: 'Anonymous class is empty #loc'
empty.catch.block.comments.option:
    text: Comments count as content
empty.catch.block.display.name:
    text: Empty 'catch' block
empty.catch.block.ignore.ignore.option:
    text: Ignore when 'catch' parameter is named 'ignore' or 'ignored'
empty.catch.block.ignore.option:
    text: Ignore empty 'catch' blocks in tests
empty.catch.block.problem.descriptor:
    text: 'Empty <code>#ref</code> block #loc'
empty.class.display.name:
    text: Empty class
empty.class.file.without.class.problem.descriptor:
    text: 'Java file does not declare any class #loc'
empty.class.ignore.parameterization.option:
    text: Ignore class if it is a parameterization of a super type
empty.class.initializer.delete.quickfix:
    text: Delete empty class initializer
empty.class.initializer.display.name:
    text: Empty class initializer
empty.class.initializer.problem.descriptor:
    text: 'Empty class initializer #loc'
empty.class.problem.descriptor:
    text: 'Class <code>#ref</code> is empty #loc'
empty.directories.delete.quickfix:
    text: Delete empty directory ''{0}''
empty.directories.only.under.source.roots.option:
    text: Only report empty directories located under a source folder
empty.directories.problem.descriptor:
    text: Empty directory <code>{0}</code>
empty.directory.display.name:
    text: Empty directory
empty.finally.block.display.name:
    text: Empty 'finally' block
empty.finally.block.problem.descriptor:
    text: 'Empty <code>#ref</code> block #loc'
empty.synchronized.statement.display.name:
    text: Empty 'synchronized' statement
empty.synchronized.statement.problem.descriptor:
    text: 'Empty <code>#ref</code> statement #loc'
empty.try.block.display.name:
    text: Empty 'try' block
empty.try.block.problem.descriptor:
    text: 'Empty <code>#ref</code> block #loc'
encapsulate.variable.quickfix:
    text: Encapsulate field ''{0}''
enum.switch.statement.which.misses.cases.display.name:
    text: Enum 'switch' statement that misses case
enum.switch.statement.which.misses.cases.option:
    text: Ignore switch statements with a default branch
enum.switch.statement.which.misses.cases.problem.descriptor:
    text: '<code>#ref</code> statement on enum type ''''{0}'''' misses cases #loc'
enumerated.class.display.name:
    text: Enumerated class
enumerated.class.naming.convention.display.name:
    text: Enumerated class naming convention
enumerated.class.naming.convention.element.description:
    text: Enum class
enumerated.class.naming.convention.problem.descriptor.long:
    text: 'Enumerated class name <code>#ref</code> is too long #loc'
enumerated.class.naming.convention.problem.descriptor.regex.mismatch:
    text: 'Enumerated class name <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
enumerated.class.naming.convention.problem.descriptor.short:
    text: 'Enumerated class name <code>#ref</code> is too short #loc'
enumerated.class.problem.descriptor:
    text: 'Enumerated class <code>#ref</code> #loc'
enumerated.constant.naming.convention.display.name:
    text: Enumerated constant naming convention
enumerated.constant.naming.convention.element.description:
    text: Enum constant
enumerated.constant.naming.convention.problem.descriptor.long:
    text: 'Enumerated constant name <code>#ref</code> is too long #loc'
enumerated.constant.naming.convention.problem.descriptor.regex.mismatch:
    text: 'Enumerated constant <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
enumerated.constant.naming.convention.problem.descriptor.short:
    text: 'Enumerated constant name <code>#ref</code> is too short #loc'
enumeration.can.be.iteration.display.name:
    text: Enumeration can be iteration
enumeration.can.be.iteration.problem.descriptor:
    text: '<code>#ref()</code> can be replaced with ''''{0}'''' construct #loc'
enumeration.can.be.iteration.quickfix:
    text: Replace with 'Iterator' construct
equality.operator.compares.objects.descriptor:
    text: Objects compared with ''{0}''
equality.operator.compares.objects.family.quickfix:
    text: Replace equality operator with equals()
equality.operator.compares.objects.name:
    text: Objects compared with '=='
equality.operator.compares.objects.quickfix:
    text: Replace ''{0}'' with ''{1}equals()''
equality.operator.compares.objects.safe.family.quickfix:
    text: Replace equality operator with safe equals()
equality.operator.compares.objects.safe.quickfix:
    text: Replace ''{0}'' with safe ''{1}equals()''
equals.between.inconvertible.types.display.name:
    text: '''equals()'' between objects of inconvertible types'
equals.between.inconvertible.types.problem.descriptor:
    text: '<code>#ref()</code> between objects of inconvertible types ''''{0}'''' and ''''{1}'''' #loc'
equals.called.on.array.display.name:
    text: '''equals()'' called on array'
equals.called.on.array.problem.descriptor:
    text: '<code>#ref()</code> between arrays should probably be ''Arrays.equals()'' #loc'
equals.called.on.enum.constant.display.name:
    text: '''equals()'' called on enum value'
equals.called.on.enum.constant.problem.descriptor:
    text: '<code>#ref()</code> called on enum value #loc'
equals.called.on.enum.constant.quickfix:
    text: Replace 'equals()' with '=='
equals.called.on.suspicious.object.display.name:
    text: '''equals()'' called on classes which don''t override it'
equals.called.on.suspicious.object.problem.descriptor:
    text: Suspicious call to ''equals()'' on ''{0}'' object
equals.doesnt.check.class.parameter.display.name:
    text: '''equals()'' method that does not check the class of its parameter'
equals.doesnt.check.class.parameter.problem.descriptor:
    text: '<code>#ref()</code> should check the class of its parameter #loc'
equals.hashcode.called.on.url.display.name:
    text: '''equals()'' or ''hashCode()'' called on ''java.net.URL'' object'
equals.hashcode.called.on.url.problem.descriptor:
    text: 'Call to <code>#ref()</code> on URL object #loc'
equals.replaceable.by.objects.call.display.name:
    text: '''equals()'' expression replaceable by ''Objects.equals()'' expression'
equals.replaceable.by.objects.call.problem.descriptor:
    text: '<code>#ref</code> replaceable by ''Objects.equals()'' expression #loc'
equals.replaceable.by.objects.call.quickfix:
    text: Replace with 'Objects.equals()' expression
equals.replaceable.by.objects.check.not.null.option:
    text: Report only null safe 'equals' calls
equals.to.equality.quickfix:
    text: Replace 'equals()' with '=='
equals.with.itself.display.name:
    text: '''equals()'' called on itself'
equals.with.itself.problem.descriptor:
    text: <code>#ref()</code> called on itself
error.rethrown.display.name:
    text: '''Error'' not rethrown'
error.rethrown.problem.descriptor:
    text: 'Error <code>#ref</code> not rethrown #loc'
exception.class.column.name:
    text: Exception class
exception.from.catch.which.doesnt.wrap.display.name:
    text: '''throw'' inside ''catch'' block which ignores the caught exception'
exception.from.catch.which.doesnt.wrap.problem.descriptor:
    text: '<code>#ref</code> inside ''catch'' block ignores the caught exception #loc'
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option:
    text: Ignore if thrown exception cannot wrap an exception
exception.from.catch.which.doesntwrap.ignore.option:
    text: Ignore if result of exception method call is used
exception.name.doesnt.end.with.exception.display.name:
    text: Exception class name does not end with 'Exception'
exception.name.doesnt.end.with.exception.problem.descriptor:
    text: 'Exception class name <code>#ref</code> does not end with ''Exception'' #loc'
expected.exception.never.thrown.display.name:
    text: Expected exception never thrown in test method body
expected.exception.never.thrown.problem.descriptor:
    text: 'Expected <code>#ref</code> never thrown in body of ''''{0}()'''' #loc'
explicit.array.to.string.problem.descriptor:
    text: 'Call to ''#ref()'' on array #loc'
expression.can.be.replaced.problem.descriptor:
    text: '<code>#ref</code> can be replaced with ''''{0}'''' #loc'
extended.for.statement.display.name:
    text: Enhanced 'for' statement
extended.for.statement.problem.descriptor:
    text: 'Extended <code>#ref</code> statement #loc'
extended.for.statement.replace.quickfix:
    text: Replace with old-style 'for' statement
extends.annotation.display.name:
    text: Class extends annotation interface
extends.annotation.interface.problem.descriptor:
    text: 'Interface ''''{0}'''' extends annotation interface <code>#ref</code> #loc'
extends.annotation.problem.descriptor:
    text: 'Class ''''{0}'''' implements annotation interface <code>#ref</code> #loc'
extends.concrete.collection.display.name:
    text: Class explicitly extends a 'Collection' class
extends.concrete.collection.problem.descriptor:
    text: 'Class <code>#ref</code> explicitly extends ''''{0}'''' #loc'
extends.object.display.name:
    text: Class explicitly extends 'Object'
extends.object.problem.descriptor:
    text: 'Class <code>#ref</code> explicitly extends ''java.lang.Object'' #loc'
extends.object.remove.quickfix:
    text: Remove redundant 'extends Object'
extends.thread.display.name:
    text: Class directly extends 'Thread'
extends.thread.problem.descriptor:
    text: 'Class <code>#ref</code> directly extends ''java.lang.Thread'' #loc'
extends.throwable.display.name:
    text: Class directly extends 'Throwable'
extends.throwable.problem.descriptor:
    text: 'Class <code>#ref</code> directly extends ''java.lang.Throwable'' #loc'
externalizable.with.serialization.methods.display.name:
    text: Externalizable class with 'readObject()' or 'writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both:
    text: 'Externalizable class <code>#ref</code> defines ''readObject()'' and ''writeObject()'' #loc'
externalizable.with.serialization.methods.problem.descriptor.read:
    text: 'Externalizable class <code>#ref</code> defines ''readObject()'' #loc'
externalizable.with.serialization.methods.problem.descriptor.write:
    text: 'Externalizable class <code>#ref</code> defines ''writeObject()'' #loc'
externalizable.without.public.no.arg.constructor.display.name:
    text: '''Externalizable'' class without ''public'' no-arg constructor'
externalizable.without.public.no.arg.constructor.problem.descriptor:
    text: 'Externalizable class <code>#ref</code> has no ''public'' no-arg constructor #loc'
extract.method.quickfix:
    text: Extract method
extract.parameter.as.local.variable.quickfix:
    text: Extract parameter as local variable
fallthru.in.switch.statement.display.name:
    text: Fallthrough in 'switch' statement
fallthru.in.switch.statement.problem.descriptor:
    text: 'Fallthrough in ''switch'' statement #loc'
fallthru.in.switch.statement.quickfix:
    text: Add 'break'
feature.envy.display.name:
    text: Feature envy
feature.envy.ignore.test.cases.option:
    text: Ignore feature envy in tests
feature.envy.problem.descriptor:
    text: 'Class ''''{0}'''' accessed repeatedly in method <code>#ref()</code> #loc'
field.accessed.synchronized.and.unsynchronized.display.name:
    text: Field accessed in both 'synchronized' and unsynchronized contexts
field.accessed.synchronized.and.unsynchronized.option:
    text: Simple getters and setters are considered field accesses too
field.accessed.synchronized.and.unsynchronized.problem.descriptor:
    text: 'Field <code>#ref</code> is accessed in both synchronized and unsynchronized contexts #loc'
field.count.inspection.include.constant.fields.in.count.checkbox:
    text: Include constant fields in count
field.count.inspection.include.enum.constants.in.count:
    text: Include enum constants in count
field.count.inspection.static.final.fields.count.as.constant.checkbox:
    text: '''static final'' fields count as constant'
field.has.setter.but.no.getter.display.name:
    text: Field has setter but no getter
field.has.setter.but.no.getter.problem.descriptor:
    text: 'Field <code>#ref</code> has setter but no getter #loc'
field.has.static.modifier.problem.descriptor:
    text: Field ''{0}'' has ''static'' modifier
field.incorrect.type.problem.descriptor:
    text: Field ''{0}'' does not have type ''{1}''
field.may.be.final.display.name:
    text: Field may be 'final'
field.may.be.final.problem.descriptor:
    text: 'Field <code>#ref</code> may be ''final'' #loc'
field.may.be.static.display.name:
    text: Field can be made 'static'
field.may.be.static.problem.descriptor:
    text: 'Field <code>#ref</code> may be ''static'' #loc'
field.missing.volatile.modifier.problem.descriptor:
    text: Field ''{0}'' does not have ''volatile'' modifier
field.name.hides.in.superclass.display.name:
    text: Subclass field hides superclass field
field.name.hides.in.superclass.ignore.option:
    text: Ignore non-accessible fields
field.name.hides.in.superclass.problem.descriptor:
    text: 'Field <code>#ref</code> hides field in superclass #loc'
field.not.found.in.class.problem.descriptor:
    text: No field named ''{0}'' found in class ''{1}''
field.only.used.from.test.code.problem.descriptor:
    text: 'field <code>#ref</code> only accessed from test code #loc'
field.repeatedly.accessed.in.method.display.name:
    text: Field repeatedly accessed in method
field.repeatedly.accessed.in.method.ignore.option:
    text: Ignore 'final' fields
field.repeatedly.accessed.in.method.problem.descriptor:
    text: 'Field ''''{0}'''' accessed repeatedly in method <code>#ref()</code> #loc'
final.class.display.name:
    text: Class is closed to inheritance
final.class.problem.descriptor:
    text: 'Class declared <code>#ref</code> #loc'
final.method.display.name:
    text: Method can't be overridden
final.method.in.final.class.display.name:
    text: '''final'' method in ''final'' class'
final.method.in.final.class.problem.descriptor:
    text: 'Method declared <code>#ref</code> in ''final'' class #loc'
final.method.problem.descriptor:
    text: 'Method declared <code>#ref</code> #loc'
final.private.method.display.name:
    text: '''private'' method declared ''final'''
final.private.method.problem.descriptor:
    text: '''private'' method declared <code>#ref</code> #loc'
final.static.method.display.name:
    text: '''static'' method declared ''final'''
final.static.method.problem.descriptor:
    text: '''static'' method declared <code>#ref</code> #loc'
finalize.called.explicitly.display.name:
    text: '''finalize()'' called explicitly'
finalize.called.explicitly.problem.descriptor:
    text: '<code>#ref()</code> called explicitly #loc'
finalize.declaration.display.name:
    text: '''finalize()'' should not be overridden'
finalize.declaration.problem.descriptor:
    text: '''finalize()'' should not be overridden #loc'
finalize.doesnt.call.super.display.name:
    text: '''finalize()'' does not call ''super.finalize()'''
finalize.doesnt.call.super.ignore.option:
    text: Ignore for direct subclasses of 'java.lang.Object'
finalize.doesnt.call.super.problem.descriptor:
    text: '<code>#ref()</code> #loc does not call ''super.finalize()'''
finalize.not.declared.protected.display.name:
    text: '''finalize()'' should be protected, not public'
finalize.not.declared.protected.problem.descriptor:
    text: '''finalize()'' should have protected access, not public #loc'
finally.block.cannot.complete.normally.display.name:
    text: '''finally'' block which can not complete normally'
finally.block.cannot.complete.normally.problem.descriptor:
    text: '<code>#ref</code> block can not complete normally #loc'
flip.comparison.quickfix:
    text: Flip comparison
floating.point.equality.display.name:
    text: Floating-point equality comparison
floating.point.equality.problem.descriptor:
    text: '<code>#ref</code>: floating-point values compared for exact equality #loc'
for.can.be.foreach.display.name:
    text: '''for'' loop can be replaced with enhanced for loop'
for.can.be.foreach.option:
    text: Report indexed 'java.util.List' loops
for.can.be.foreach.option2:
    text: Do not report iterations over untyped collections
for.can.be.foreach.problem.descriptor:
    text: '<code>#ref</code> loop can be replaced with enhanced ''for'' #loc'
for.loop.not.use.loop.variable.display.name:
    text: '''for'' loop where update or condition does not use loop variable'
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update:
    text: '<code>#ref</code> statement has condition and update which do not use the for loop variable #loc'
for.loop.not.use.loop.variable.problem.descriptor.condition:
    text: '<code>#ref</code> statement has condition which does not use the for loop variable #loc'
for.loop.not.use.loop.variable.problem.descriptor.update:
    text: '<code>#ref</code> statement has update which does not use the for loop variable #loc'
for.loop.replaceable.by.while.display.name:
    text: '''for'' loop may be replaced with ''while'' loop'
for.loop.replaceable.by.while.ignore.option:
    text: Ignore 'infinite' for loops without conditions
for.loop.replaceable.by.while.problem.descriptor:
    text: '<code>#ref</code> loop statement may be replace by ''while'' loop #loc'
for.loop.replaceable.by.while.replace.quickfix:
    text: Replace with 'while'
for.loop.with.missing.component.collection.loop.option:
    text: Ignore collection iterations
for.loop.with.missing.component.display.name:
    text: '''for'' loop with missing components'
for.loop.with.missing.component.problem.descriptor1:
    text: '<code>#ref</code> statement lacks initializer #loc'
for.loop.with.missing.component.problem.descriptor2:
    text: '<code>#ref</code> statement lacks condition #loc'
for.loop.with.missing.component.problem.descriptor3:
    text: '<code>#ref</code> statement lacks update #loc'
for.loop.with.missing.component.problem.descriptor4:
    text: '<code>#ref</code> statement lacks initializer and condition #loc'
for.loop.with.missing.component.problem.descriptor5:
    text: '<code>#ref</code> statement lacks initializer and update #loc'
for.loop.with.missing.component.problem.descriptor6:
    text: '<code>#ref</code> statement lacks condition and update #loc'
for.loop.with.missing.component.problem.descriptor7:
    text: '<code>#ref</code> statement lacks initializer, condition and update #loc'
foreach.replace.quickfix:
    text: Replace with enhanced 'for'
format.decode.any:
    text: any
format.decode.char:
    text: char
format.decode.date.time:
    text: Date/Time
format.decode.error.requires.both.0.and.1:
    text: requires both {0} and {1}
format.decode.floating.point:
    text: floating point
format.decode.integer.type:
    text: integer type
gc.call.display.name:
    text: Call to 'System.gc()' or 'Runtime.gc()'
gc.call.problem.descriptor:
    text: '<code>#ref</code> should not be called in production code #loc'
hardcoded.file.separator.display.name:
    text: Hardcoded file separator
hardcoded.file.separator.include.option:
    text: Include 'example/*' in recognized MIME media types
hardcoded.file.separator.problem.descriptor:
    text: 'Hardcoded file separator <code>#ref</code> #loc'
hardcoded.line.separator.display.name:
    text: Hardcoded line separator
hardcoded.line.separator.problem.descriptor:
    text: 'Hardcoded line separator <code>#ref</code> #loc'
hibernate.resource.opened.not.closed.display.name:
    text: Hibernate resource opened but not safely closed
hibernate.resource.opened.not.closed.problem.descriptor:
    text: '''''{0}'''' should be opened in front of a ''''try'''' block and closed in the corresponding ''''finally'''' block #loc'
html.tag.can.be.javadoc.tag.display.name:
    text: '''<code></code>'' can be replaced with ''{@code }'''
html.tag.can.be.javadoc.tag.problem.descriptor:
    text: '<code>#ref\&lt;/code\&gt;</code> can be replaced with ''{@code }'' #loc'
html.tag.can.be.javadoc.tag.quickfix:
    text: Replace with '{@code ...}'
i.o.resource.opened.not.closed.display.name:
    text: I/O resource opened but not safely closed
if.can.be.assertion.name:
    text: If statement can be replaced with assertion
if.can.be.assertion.quickfix:
    text: Replace 'if' with 'assert' statement
if.can.be.switch.display.name:
    text: '''if'' can be replaced with ''switch'''
if.can.be.switch.enum.option:
    text: Suggest switch on enums
if.can.be.switch.int.option:
    text: Suggest switch on numbers
if.can.be.switch.minimum.branch.option:
    text: 'Minimum number of ''if'' condition branches:'
if.can.be.switch.null.safe.option:
    text: Only suggest on null-safe expressions
if.can.be.switch.problem.descriptor:
    text: '<code>#ref</code> statement can be replaced with ''switch'' statement #loc'
if.can.be.switch.quickfix:
    text: Replace with 'switch'
if.may.be.conditional.display.name:
    text: '''if'' statement could be replaced with conditional expression'
if.may.be.conditional.problem.descriptor:
    text: '<code>#ref</code> can be replaced with conditional expression #loc'
if.may.be.conditional.quickfix:
    text: Replace with conditional expression
if.may.be.conditional.report.method.calls.option:
    text: Report if statements containing method calls
if.statement.with.identical.branches.collapse.quickfix:
    text: Collapse 'if' statement
if.statement.with.identical.branches.display.name:
    text: '''if'' statement with identical branches'
if.statement.with.identical.branches.problem.descriptor:
    text: '<code>#ref</code> statement with identical branches #loc'
if.statement.with.too.many.branches.display.name:
    text: '''if'' statement with too many branches'
if.statement.with.too.many.branches.max.option:
    text: 'Maximum number of branches:'
if.statement.with.too.many.branches.problem.descriptor:
    text: '<code>#ref</code> has too many branches ({0}) #loc'
ignore.accesses.from.equals.method:
    text: Ignore accesses from 'equals()' method
ignore.accesses.from.the.same.class:
    text: Ignore accesses from the same class
ignore.anonymous.inner.classes:
    text: Ignore anonymous inner classes
ignore.as.initial.capacity:
    text: Ignore initial capacity argument when constructing StringBuilders and Collections
ignore.boolean.methods.in.an.interface.option:
    text: Ignore boolean methods in an @&interface
ignore.branches.of.switch.statements:
    text: Ignore branches of 'switch' statements
ignore.calls.to.property.getters:
    text: Ignore calls to property getters
ignore.calls.to.static.methods:
    text: Ignore calls to static methods
ignore.classes.extending.throwable.option:
    text: Ignore classes extending 'Throwable'
ignore.classes.in.hierarchy.column.name:
    text: 'Ignore subclasses of:'
ignore.cloneable.option:
    text: Ignore 'java.lang.Cloneable'
ignore.equals.hashcode.and.tostring:
    text: Ignore 'equals()', 'hashCode()' and 'toString()' methods
ignore.exceptions.declared.in.tests.option:
    text: Ignore exceptions declared in &tests
ignore.exceptions.declared.on.library.override.option:
    text: Ignore exceptions declared on methods overriding a &library method
ignore.for.equals.methods.option:
    text: Ignore for '&equals()' methods
ignore.guard.clauses.option:
    text: Ignore &guard clauses
ignore.if.annotated.by:
    text: 'Ignore if annotated by:'
ignore.in.annotations:
    text: Ignore in annotations
ignore.in.module.statements.option:
    text: Ignore in Java 9 module statements
ignore.in.test.code:
    text: Ignore in &test code
ignore.in.tostring:
    text: Ignore inside toString() methods
ignore.instanceof.on.library.classes:
    text: Ignore instanceof on library classes
ignore.iterator.loop.variables:
    text: Ignore 'java.util.Iterator' loop variables
ignore.methods.in.anonymous.classes:
    text: Ignore methods in anonymous classes
ignore.methods.overriding.super.method:
    text: Ignore methods &overriding/implementing a super method
ignore.methods.with.boolean.return.type.option:
    text: Ignore methods with 'java.lang.&Boolean' return type
ignore.nullable.parameters.option:
    text: Ignore @Nullable parameters
ignore.overflowing.byte.casts.option:
    text: Ignore casts from int 128-255 to byte
ignore.parameter.if.annotated.by:
    text: Ignore parameter if it is annotated by
ignore.parentheses.around.single.no.formal.type.lambda.parameter:
    text: Ignore parentheses around single no formal type lambda parameter
ignore.serializable.option:
    text: Ignore 'java.io.Serializable'
ignore.single.field.static.imports.option:
    text: Ignore single &field static imports
ignore.single.method.static.imports.option:
    text: Ignore single &method static imports
ignore.static.methods.accessed.from.a.non.static.inner.class:
    text: Ignore '&static' methods accessed from a non-'static' inner class
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor:
    text: 'JUnit 3 test method <code>#ref()</code> annotated with ''@Ignore'' won''t be ignored #loc'
ignore.test.method.in.class.extending.junit3.testcase.quickfix:
    text: Remove ''@Ignore'' and rename method to ''{0}''
ignore.trivial.finalizers.option:
    text: Ignore for trivial 'finalize()' implementations
ignored.autocloseable.types.column.label:
    text: Ignored AutoCloseable resource types
ignored.class.names:
    text: Ignore Classes (Including Subclasses)
ignored.classes.table:
    text: Ignored classes
ignored.io.resource.types:
    text: Ignored I/O resource types
ignored.junit.test.classproblem.descriptor:
    text: 'Test class ''''{0}'''' annotated with <code>#ref</code> #loc'
ignored.junit.test.display.name:
    text: JUnit test annotated with '@Ignore'/'@Disabled'
ignored.junit.test.method.problem.descriptor:
    text: 'Test method ''''{0}()'''' annotated with <code>#ref</code> #loc'
implicit.array.to.string.display.name:
    text: Call to 'toString()' on array
implicit.array.to.string.method.call.problem.descriptor:
    text: 'Implicit call to ''toString()'' on array returned by call to <code>#ref</code> #loc'
implicit.array.to.string.problem.descriptor:
    text: 'Implicit call to ''toString()'' on array <code>#ref</code> #loc'
implicit.array.to.string.quickfix:
    text: Wrap with ''{0}'' expression
implicit.call.to.super.display.name:
    text: Implicit call to 'super()'
implicit.call.to.super.ignore.option:
    text: Ignore for direct subclasses of 'java.lang.Object'
implicit.call.to.super.make.explicit.quickfix:
    text: Make call to 'super()' explicit
implicit.call.to.super.problem.descriptor:
    text: 'Implicit call to ''super()'' #loc'
implicit.default.charset.usage.constructor.problem.descriptor:
    text: '<code>new #ref()</code> call uses the platform''s default charset'
implicit.default.charset.usage.display.name:
    text: Implicit usage of platform's default charset
implicit.default.charset.usage.problem.descriptor:
    text: Call to <code>#ref()</code> uses the platform's default charset
implicit.numeric.conversion.convert.quickfix:
    text: Convert to ''{0}''
implicit.numeric.conversion.display.name:
    text: Implicit numeric conversion
implicit.numeric.conversion.ignore.char.conversion.option:
    text: Ignore conversions from and to 'char'
implicit.numeric.conversion.ignore.constant.conversion.option:
    text: Ignore conversions from constants and literals
implicit.numeric.conversion.ignore.widening.conversion.option:
    text: Ignore widening conversions
implicit.numeric.conversion.make.explicit.quickfix:
    text: Make conversion explicit
implicit.numeric.conversion.problem.descriptor:
    text: 'Implicit numeric conversion of <code>#ref</code> from ''''{0}'''' to ''''{1}'''' #loc'
import.display.name:
    text: '''*'' import'
import.from.same.package.display.name:
    text: Unnecessary import from the same package
import.from.same.package.problem.descriptor:
    text: 'Unnecessary import from the same package <code>#ref</code> #loc'
import.problem.descriptor:
    text: 'Package import <code>#ref</code> #loc'
include.java.system.classes.option:
    text: Include couplings to java system classes
include.library.classes.option:
    text: Include couplings to library classes
incompatible.mask.operation.display.name:
    text: Incompatible bitwise mask operation
incompatible.mask.operation.problem.descriptor.always.false:
    text: '<code>#ref</code> is always false #loc'
incompatible.mask.operation.problem.descriptor.always.true:
    text: '<code>#ref</code> is always true #loc'
increment.decrement.display.name:
    text: Result of '++' or '--' used
increment.decrement.used.as.expression.quickfix:
    text: Extract ''{0}'' to separate statement
indexof.replaceable.by.contains.display.name:
    text: '''indexOf()'' expression is replaceable with ''contains()'''
infinite.loop.statement.display.name:
    text: Infinite loop statement
infinite.loop.statement.problem.descriptor:
    text: '<code>#ref</code> statement cannot complete without throwing an exception #loc'
infinite.recursion.display.name:
    text: Infinite recursion
infinite.recursion.problem.descriptor:
    text: 'Method <code>#ref()</code> recurses infinitely, and can only end by throwing an exception #loc'
info.level.and.lower.option:
    text: info level and lower
inline.call.quickfix:
    text: Inline call
inline.variable.quickfix:
    text: Inline variable
inner.class.field.hides.outer.display.name:
    text: Inner class field hides outer class field
inner.class.field.hides.outer.ignore.option:
    text: Ignore outer fields not visible from inner class
inner.class.field.hides.outer.problem.descriptor:
    text: 'Inner class field <code>#ref</code> hides outer class field #loc'
inner.class.may.be.static.display.name:
    text: Inner class may be 'static'
inner.class.may.be.static.problem.descriptor:
    text: 'Inner class <code>#ref</code> may be ''static'' #loc'
inner.class.on.interface.display.name:
    text: Inner class of interface
inner.class.on.interface.ignore.option:
    text: Ignore inner interfaces of interfaces
inner.class.on.interface.problem.descriptor:
    text: 'Interface ''''{0}'''' has inner class <code>#ref</code> #loc'
inner.class.referenced.via.subclass.display.name:
    text: Inner class referenced via subclass
inner.class.referenced.via.subclass.problem.descriptor:
    text: 'Inner class <code>#ref</code> declared in class ''''{0}'''' but referenced via subclass ''''{1}'''' #loc'
inner.class.referenced.via.subclass.quickfix:
    text: Rationalize inner class access
inner.class.too.deeply.nested.display.name:
    text: Inner class too deeply nested
inner.class.too.deeply.nested.nesting.limit.option:
    text: 'Nesting limit:'
inner.class.too.deeply.nested.problem.descriptor:
    text: '<code>#ref</code> is too deeply nested (nesting level = {0}) #loc'
inspection.option.ignore.as.initial.capacity:
    text: Ignore initial capacity for StringBuilders and Collections
inspection.option.ignore.assert:
    text: Ignore for assert statement description arguments
inspection.option.ignore.constant.initializers:
    text: Ignore for initializers of constant fields
inspection.option.ignore.exceptions:
    text: Ignore for constructor arguments of Throwable subclasses
inspection.option.ignore.in.annotations:
    text: Ignore in annotations
inspection.option.ignore.in.hashcode:
    text: Ignore constants in 'hashCode()' methods
inspection.option.ignore.in.tostring:
    text: Ignore inside toString() methods
inspection.option.ignore.nonnls:
    text: Ignore when annotated via @NonNls
inspection.option.ignore.system.err:
    text: Ignore for 'System.err.print' arguments
inspection.option.ignore.system.out:
    text: Ignore for 'System.out.print' arguments
inspection.suppression.annotation.display.name:
    text: Inspection suppression annotation
inspection.suppression.annotation.problem.descriptor:
    text: 'Inspection suppression annotation <code>#ref</code> #loc'
instance.Variable.may.not.be.initialized.problem.descriptor.junit:
    text: 'Instance field <code>#ref</code> may not be initialized during object construction or ''setUp()'' call #loc'
instance.method.name.convention.problem.descriptor.long:
    text: 'Instance method name <code>#ref</code> is too long #loc'
instance.method.name.convention.problem.descriptor.regex.mismatch:
    text: 'Instance method name <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
instance.method.name.convention.problem.descriptor.short:
    text: 'Instance method name <code>#ref</code> is too short #loc'
instance.method.naming.convention.display.name:
    text: Instance method naming convention
instance.method.naming.convention.element.description:
    text: Instance method
instance.variable.may.not.be.initialized.display.name:
    text: Instance field may not be initialized
instance.variable.may.not.be.initialized.problem.descriptor:
    text: 'Instance field <code>#ref</code> may not be initialized during object construction #loc'
instance.variable.name.convention.problem.descriptor.long:
    text: 'Instance field name <code>#ref</code> is too long #loc'
instance.variable.name.convention.problem.descriptor.regex.mismatch:
    text: 'Instance field <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
instance.variable.name.convention.problem.descriptor.short:
    text: 'Instance field name <code>#ref</code> is too short #loc'
instance.variable.naming.convention.display.name:
    text: Instance field naming convention
instance.variable.naming.convention.element.description:
    text: Instance field
instance.variable.of.concrete.class.display.name:
    text: Type of instance field is concrete class
instance.variable.of.concrete.class.option:
    text: Ignore instance fields whose type is an abstract class
instance.variable.of.concrete.class.problem.descriptor:
    text: 'Type of field ''''{0}'''' is concrete class <code>#ref</code> #loc'
instance.variable.used.before.initialized.display.name:
    text: Instance field used before initialization
instance.variable.used.before.initialized.problem.descriptor:
    text: 'Instance field <code>#ref</code> used before initialized #loc'
instanceof.catch.parameter.display.name:
    text: '''instanceof'' on ''catch'' parameter'
instanceof.catch.parameter.problem.descriptor:
    text: '''instanceof'' on ''catch'' parameter <code>#ref</code> #loc'
instanceof.check.for.this.display.name:
    text: '''instanceof'' check for ''this'''
instanceof.check.for.this.problem.descriptor:
    text: '''instanceof'' check for <code>#ref</code> #loc'
instanceof.concrete.class.display.name:
    text: '''instanceof'' a concrete class'
instanceof.concrete.class.problem.descriptor:
    text: '''instanceof'' concrete class <code>#ref</code> #loc'
instanceof.interfaces.option:
    text: Ignore instanceof abstract class
instanceof.with.incompatible.interface.display.name:
    text: '''instanceof'' with incompatible type'
instanceof.with.incompatible.interface.problem.descriptor:
    text: '''instanceof'' incompatible interface <code>#ref</code> #loc'
instantiating.object.to.get.class.object.display.name:
    text: Instantiating object to get Class object
instantiating.object.to.get.class.object.problem.descriptor:
    text: 'Instantiating object to get Class object #loc'
instantiating.object.to.get.class.object.replace.quickfix:
    text: Replace with direct class object access
instantiating.simpledateformat.without.locale.display.name:
    text: '''SimpleDateFormat'' without locale'
instantiating.simpledateformat.without.locale.problem.descriptor:
    text: 'Instantiating a <code>#ref</code> without specifying a Locale in an internationalized context #loc'
instantiation.utility.class.display.name:
    text: Instantiation of utility class
instantiation.utility.class.problem.descriptor:
    text: 'Instantiation of utility class <code>#ref</code> #loc'
int.literal.may.be.long.literal.display.name:
    text: Cast to 'long' can be 'long' literal
int.literal.may.be.long.literal.problem.descriptor:
    text: '<code>#ref</code> can be replaced with ''''{0}'''' #loc'
int.literal.may.be.long.literal.quickfix:
    text: Replace with ''{0}''
integer.division.in.floating.point.context.display.name:
    text: Integer division in floating-point context
integer.division.in.floating.point.context.problem.descriptor:
    text: '<code>#ref</code>: integer division in floating-point context #loc'
integer.multiplication.implicit.cast.to.long.display.name:
    text: Integer multiplication or shift implicitly cast to 'long'
integer.multiplication.implicit.cast.to.long.option:
    text: <html>Ignore compile time constant expressions which do not overflow</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor:
    text: '#ref: integer multiplication implicitly cast to long #loc'
integer.shift.implicit.cast.to.long.problem.descriptor:
    text: '#ref: integer shift implicitly cast to long #loc'
interface.clashes.with.object.class.display.name:
    text: Interface method clashes with method in 'Object'
interface.clashes.with.object.class.problem.descriptor:
    text: <code>#ref()</code> clashes with method in 'java.lang.Object'
interface.may.be.annotated.functional.display.name:
    text: Interface may be annotated as '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor:
    text: Interface <code>#ref</code> may be annotated with @FunctionalInterface
interface.name.convention.problem.descriptor.long:
    text: 'Interface name <code>#ref</code> is too long #loc'
interface.name.convention.problem.descriptor.regex.mismatch:
    text: 'Interface name <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
interface.name.convention.problem.descriptor.short:
    text: 'Interface name <code>#ref</code> is too short #loc'
interface.naming.convention.display.name:
    text: Interface naming convention
interface.naming.convention.element.description:
    text: Interface
interface.never.implemented.display.name:
    text: Interface which has no concrete subclass
interface.never.implemented.option:
    text: Ignore interfaces which only declare constants
interface.never.implemented.problem.descriptor:
    text: 'Interface <code>#ref</code> has no concrete subclass #loc'
interface.one.inheritor.display.name:
    text: Interface with a single direct inheritor
interface.one.inheritor.problem.descriptor:
    text: 'Interface <code>#ref</code> has only one direct inheritor #loc'
introduce.constant.quickfix:
    text: Introduce constant
introduce.holder.class.quickfix:
    text: Introduce holder class
introduce.variable.may.change.semantics.quickfix:
    text: Introduce variable (may change semantics)
introduce.variable.quickfix:
    text: Introduce variable
invert.method.quickfix:
    text: Invert method
invert.quickfix:
    text: Invert ''{0}''
invert.quickfix.family.name:
    text: Invert boolean
iterator.hasnext.which.calls.next.display.name:
    text: '''Iterator.hasNext()'' which calls ''next()'''
iterator.hasnext.which.calls.next.problem.descriptor:
    text: '<code>Iterator.#ref()</code> contains call to ''next()'' #loc'
iterator.next.does.not.throw.nosuchelementexception.display.name:
    text: '''Iterator.next()'' which can''t throw ''NoSuchElementException'''
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor:
    text: '<code>Iterator.#ref()</code> which can''t throw ''NoSuchElementException'' #loc'
java.lang.import.display.name:
    text: Unnecessary import from the 'java.lang' package
java.lang.import.problem.descriptor:
    text: 'Unnecessary import from the ''java.lang'' package #loc'
java.lang.reflect.display.name:
    text: Use of 'java.lang.reflect'
java.lang.reflect.problem.descriptor:
    text: 'Use of type <code>#ref</code> from ''java.lang.reflect'' #loc'
jdbc.execute.with.non.constant.string.display.name:
    text: Call to 'Statement.execute()' with non-constant string
jdbc.execute.with.non.constant.string.problem.descriptor:
    text: 'Call to <code>Statement.#ref()</code> with non-constant argument #loc'
jdbc.prepare.statement.with.non.constant.string.display.name:
    text: Call to 'Connection.prepare*()' with non-constant string
jdbc.prepare.statement.with.non.constant.string.problem.descriptor:
    text: 'Call to <code>Connection.#ref()</code> with non-constant argument #loc'
jdbc.resource.opened.not.closed.display.name:
    text: JDBC resource opened but not safely closed
jdbc.resource.opened.not.closed.problem.descriptor:
    text: 'JDBC ''''{0}'''' should be opened in front of a ''''try'''' block and closed in the corresponding ''''finally'''' block #loc'
jndi.resource.opened.not.closed.display.name:
    text: JNDI resource opened but not safely closed
junit.abstract.test.class.naming.convention.display.name:
    text: JUnit abstract test class naming convention
junit.abstract.test.class.naming.convention.element.description:
    text: Abstract JUnit test class
junit.abstract.test.class.naming.convention.problem.descriptor.long:
    text: 'Abstract JUnit test class name <code>#ref</code> is too long #loc'
junit.abstract.test.class.naming.convention.problem.descriptor.regex.mismatch:
    text: 'Abstract JUnit test class name <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
junit.abstract.test.class.naming.convention.problem.descriptor.short:
    text: 'Abstract JUnit test class name <code>#ref</code> is too short #loc'
junit.datapoint.display.name:
    text: Malformed @DataPoint field
junit.datapoint.problem.descriptor:
    text: '{1}s annotated with @DataPoint should be {0}'
junit.rule.display.name:
    text: Malformed @Rule/@ClassRule field
junit.rule.problem.descriptor:
    text: Fields annotated with ''@{0}'' should be {1}
junit.rule.type.problem.descriptor:
    text: Field type should be subtype of 'org.junit.rules.TestRule'
junit.test.class.naming.convention.display.name:
    text: JUnit test class naming convention
junit.test.class.naming.convention.element.description:
    text: Test class
junit.test.class.naming.convention.problem.descriptor.long:
    text: 'JUnit test class name <code>#ref</code> is too long #loc'
junit.test.class.naming.convention.problem.descriptor.regex.mismatch:
    text: 'JUnit test class name <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
junit.test.class.naming.convention.problem.descriptor.short:
    text: 'JUnit test class name <code>#ref</code> is too short #loc'
junit3.method.naming.convention.display.name:
    text: JUnit 3 test method naming convention
junit3.method.naming.convention.element.description:
    text: JUnit 3 test method
junit3.style.test.method.in.junit4.class.display.name:
    text: Old style JUnit test method in JUnit 4 class
junit3.style.test.method.in.junit4.class.problem.descriptor:
    text: 'Old style JUnit test method <code>#ref()</code> in JUnit 4 class #loc'
junit4.method.naming.convention.display.name:
    text: JUnit 4+ test method naming convention
junit4.method.naming.convention.element.description:
    text: JUnit 4+ test method
junit4.test.method.in.class.extending.junit3.testcase.display.name:
    text: JUnit 4 test method in class extending JUnit 3 TestCase
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor:
    text: 'Method <code>#ref()</code> annotated with ''@Test'' inside class extending JUnit 3 TestCase #loc'
junit5.assertions.converter.display.name:
    text: Obsolete assertions in JUnit 5 tests
junit5.assertions.converter.familyName:
    text: Replace with JUnit 5 compatible call
junit5.assertions.converter.problem.descriptor:
    text: 'Call to <code>#ref()</code> from ''''{0}'''' should be replaced with call to method from ''''{1}'''' #loc'
junit5.assertions.converter.quickfix:
    text: Replace with ''{0}'' method call
junit5.converter.display.name:
    text: JUnit 4 test can be JUnit 5
junit5.converter.fix.name:
    text: Migrate to JUnit 5
junit5.malformed.repeated.test.display.name:
    text: JUnit 5 malformed repeated test
junit5.platform.runner.display.name:
    text: '@RunWith(JUnitPlatform.class) without test methods'
junit5.valid.parameterized.configuration.display.name:
    text: JUnit 5 malformed parameterized test
key.set.iteration.may.use.entry.set.display.name:
    text: Iteration over 'keySet()' may be replaced with 'entrySet()' iteration
key.set.iteration.may.use.entry.set.problem.descriptor:
    text: 'Iteration over <code>#ref</code> may be replaced with ''entrySet()'' iteration #loc'
key.set.iteration.may.use.entry.set.quickfix:
    text: Replace with 'entrySet()' iteration
labeled.statement.display.name:
    text: Labeled statement
labeled.statement.problem.descriptor:
    text: 'Labeled statement <code>#ref:</code> #loc'
lambda.body.can.be.code.block.name:
    text: Lambda body can be code block
lambda.body.can.be.code.block.quickfix:
    text: Expand lambda body to '{'...'}'
lambda.can.be.replaced.with.anonymous.name:
    text: Lambda can be replaced with anonymous class
lambda.can.be.replaced.with.anonymous.quickfix:
    text: Replace lambda with anonymous class
lambda.parameter.hides.member.variable.display.name:
    text: Lambda parameter hides field
lambda.parameter.hides.member.variable.ignore.invisible.option:
    text: Ignore fields not actually visible from the lambda
lambda.parameter.hides.member.variable.problem.descriptor:
    text: 'Lambda parameter <code>#ref</code> hides field in class ''''{0}'''' #loc'
lambda.parameter.naming.convention.display.name:
    text: Lambda parameter naming convention
lambda.parameter.naming.convention.element.description:
    text: Lambda parameter
lambda.parameter.type.can.be.specified.descriptor:
    text: Lambda can be expanded to {0} -> '{'...'}'
lambda.parameter.type.can.be.specified.family.quickfix:
    text: Specify lambda parameter type
lambda.parameter.type.can.be.specified.name:
    text: Lambda parameter type can be specified
lambda.parameter.type.can.be.specified.quickfix:
    text: Expand lambda to {0} -> '{'...'}'
lambda.unfriendly.constructor.overload.problem.descriptor:
    text: Lambda-unfriendly overload of constructor <code>#ref()</code>
lambda.unfriendly.method.overload.display.name:
    text: Lambda-unfriendly method overload
lambda.unfriendly.method.overload.problem.descriptor:
    text: Lambda-unfriendly overload of method <code>#ref()</code>
large.array.allocation.no.outofmemoryerror.display.name:
    text: Large array allocation with no OutOfMemoryError check
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option:
    text: 'Maximum number of elements:'
large.array.allocation.no.outofmemoryerror.problem.descriptor:
    text: 'Large array allocation which is not checked for out-of-memory condition #loc'
large.initializer.primitive.type.array.display.name:
    text: Overly large initializer for array of primitive type
large.initializer.primitive.type.array.maximum.number.of.elements.option:
    text: 'Maximum number of elements:'
large.initializer.primitive.type.array.problem.descriptor:
    text: 'Primitive array initializer with too many elements ({0}) #loc'
law.of.demeter.display.name:
    text: Method call violates Law of Demeter
law.of.demeter.ignore.library.calls.option:
    text: Ignore calls on library methods
law.of.demeter.problem.descriptor:
    text: '<code>#ref()</code> call violates Law of Demeter #loc'
length.one.string.in.indexof.display.name:
    text: Single character string argument in 'String.indexOf()' call
length.one.strings.in.concatenation.display.name:
    text: Single character string concatenation
length.one.strings.in.concatenation.replace.quickfix:
    text: Replace with character
limited.scope.inner.class.display.name:
    text: Limited-scope inner class
limited.scope.inner.class.problem.descriptor:
    text: 'Limited-scope inner class <code>#ref</code> #loc'
listener.may.use.adapter.display.name:
    text: Class may extend adapter instead of implementing listener
listener.may.use.adapter.emtpy.methods.option:
    text: '&Only warn when empty implementing methods are found'
listener.may.use.adapter.problem.descriptor:
    text: 'Class ''''{0}'''' may extend ''''{1}'''' instead of implementing <code>#ref</code> #loc'
listener.may.use.adapter.quickfix:
    text: Replace with ''extends {0}''
literal.as.arg.to.string.equals.display.name:
    text: '''expression.equals("literal")'' rather than ''"literal".equals(expression)'''
literal.as.arg.to.string.equals.flip.quickfix:
    text: Flip 'equals()'
literal.as.arg.to.string.equals.problem.descriptor:
    text: '<code>#ref</code> is argument of ''''{0}()'''', instead of its target #loc'
load.library.with.non.constant.string.display.name:
    text: Call to 'System.loadLibrary()' with non-constant string
load.library.with.non.constant.string.problem.descriptor:
    text: 'Call to <code>{0}.#ref()</code> with non-constant argument #loc'
local.variable.hides.member.variable.display.name:
    text: Local variable hides field
local.variable.hides.member.variable.ignore.option:
    text: Ignore local variables in a static context
local.variable.hides.member.variable.problem.descriptor:
    text: 'Local variable <code>#ref</code> hides field in class ''''{0}'''' #loc'
local.variable.naming.convention.display.name:
    text: Local variable naming convention
local.variable.naming.convention.element.description:
    text: Local variable
local.variable.naming.convention.ignore.catch.option:
    text: Ignore 'catch' block parameters
local.variable.naming.convention.ignore.option:
    text: Ignore for-loop parameters
local.variable.naming.convention.problem.descriptor.long:
    text: 'Local variable name <code>#ref</code> is too long #loc'
local.variable.naming.convention.problem.descriptor.regex.mismatch:
    text: 'Local variable name <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
local.variable.naming.convention.problem.descriptor.short:
    text: 'Local variable name <code>#ref</code> is too short #loc'
local.variable.of.concrete.class.display.name:
    text: Local variable of concrete class
local.variable.of.concrete.class.option:
    text: Ignore local variables whose type is an abstract class
local.variable.of.concrete.class.problem.descriptor:
    text: 'Local variable ''''{0}'''' of concrete class <code>#ref</code> #loc'
log.condition.text:
    text: Log Condition Text
log.method.name:
    text: Logging Method Name
log.statement.guarded.by.log.condition.display.name:
    text: Logging call not guarded by log condition
log.statement.guarded.by.log.condition.flag.all.unguarded.option:
    text: Flag all unguarded logging calls
log.statement.guarded.by.log.condition.problem.descriptor:
    text: '<code>#ref()</code> logging calls not guarded by log condition #loc'
log.statement.guarded.by.log.condition.quickfix:
    text: Surround with log condition
logger.class.name:
    text: Logger class name
logger.factory.class.name:
    text: Logger Factory Class Name
logger.factory.method.name:
    text: Logger Factory Method Name
logger.initialized.with.foreign.class.display.name:
    text: Logger initialized with foreign class
logger.initialized.with.foreign.class.problem.descriptor:
    text: 'Logger initialized with foreign class <code>#ref</code> #loc'
logger.initialized.with.foreign.class.quickfix:
    text: Replace with ''{0}.class''
logger.name.option:
    text: 'Logger &class name:'
logging.condition.disagrees.with.log.statement.display.name:
    text: Log condition does not match logging call
logging.condition.disagrees.with.log.statement.problem.descriptor:
    text: 'Log condition <code>#ref()</code> does not match ''''{0}()'''' logging call #loc'
long.literals.ending.with.lowercase.l.display.name:
    text: '''long'' literal ending with ''l'' instead of ''L'''
long.literals.ending.with.lowercase.l.problem.descriptor:
    text: '''long'' literal <code>#ref</code> ends with lowercase ''l'' #loc'
long.literals.ending.with.lowercase.l.replace.quickfix:
    text: Replace 'l' with 'L'
loop.condition.not.updated.inside.loop.display.name:
    text: Loop variable not updated inside loop
loop.condition.not.updated.inside.loop.problem.descriptor:
    text: 'Condition ''#ref'' is not updated inside loop #loc'
loop.statements.that.dont.loop.display.name:
    text: Loop statement that does not loop
loop.statements.that.dont.loop.problem.descriptor:
    text: '<code>#ref</code> statement does not loop #loc'
loop.variable.not.updated.inside.loop.problem.descriptor:
    text: 'Variable ''#ref'' is not updated inside loop #loc'
loop.with.implicit.termination.condition.display.name:
    text: Loop with implicit termination condition
loop.with.implicit.termination.condition.dowhile.problem.descriptor:
    text: '<code>#ref-while</code> loop with implicit termination condition #loc'
loop.with.implicit.termination.condition.problem.descriptor:
    text: '<code>#ref</code> loop with implicit termination condition #loc'
loop.with.implicit.termination.condition.quickfix:
    text: Make condition explicit
magic.character.display.name:
    text: Magic character
magic.character.problem.descriptor:
    text: 'Magic character <code>#ref</code> in an internationalized context #loc'
magic.number.display.name:
    text: Magic number
magic.number.ignore.option:
    text: Ignore constants in 'hashCode()' methods
magic.number.problem.descriptor:
    text: 'Magic number <code>#ref</code> #loc'
make.class.cloneable.quickfix:
    text: Make class 'Cloneable'
make.class.final.fix.name:
    text: Make class ''{0}'' ''final''
make.class.serializable.quickfix:
    text: Make class 'Serializable'
make.constructor.public:
    text: Make constructor 'public'
make.field.final.quickfix:
    text: Make ''{0}'' ''final''
make.initialization.explicit.quickfix:
    text: Make initialization explicit
make.interface.cloneable.quickfix:
    text: Make interface 'Cloneable'
make.method.ctr.quickfix:
    text: Make method constructor
make.method.final.fix.name:
    text: Make method ''{0}()'' ''final''
make.private.quickfix:
    text: Make 'private'
make.protected.quickfix:
    text: Make 'protected'
make.static.final.quickfix:
    text: Make ''{0}'' static final
make.static.quickfix:
    text: Make 'static'
malformed.format.string.display.name:
    text: Malformed format string
malformed.format.string.problem.descriptor.arguments.do.not.match.type:
    text: 'Format string <code>#ref</code> does not match the type of its arguments #loc'
malformed.format.string.problem.descriptor.illegal:
    text: 'Illegal format string specifier: {0} #loc'
malformed.format.string.problem.descriptor.malformed:
    text: 'Format string <code>#ref</code> is malformed #loc'
malformed.format.string.problem.descriptor.too.few.arguments:
    text: 'Too few arguments for format string <code>#ref</code> #loc'
malformed.format.string.problem.descriptor.too.many.arguments:
    text: 'Too many arguments for format string <code>#ref</code> #loc'
malformed.regular.expression.display.name:
    text: Malformed regular expression
malformed.regular.expression.problem.descriptor1:
    text: 'Regular expression <code>#ref</code> is malformed #loc'
malformed.regular.expression.problem.descriptor2:
    text: 'Regular expression <code>#ref</code> is malformed: {0} #loc'
malformed.set.up.tear.down.display.name:
    text: Malformed 'setUp()' or 'tearDown()' method
malformed.set.up.tear.down.problem.descriptor:
    text: '''#ref()'' has incorrect signature #loc'
malformed.xpath.expression.display.name:
    text: Malformed XPath expression
malformed.xpath.expression.problem.description:
    text: 'XPath expression <code>#ref</code> is malformed #loc'
manual.array.copy.display.name:
    text: Manual array copy
manual.array.copy.problem.descriptor:
    text: 'Manual array copy #loc'
manual.array.copy.replace.quickfix:
    text: Replace with 'System.arraycopy()'
manual.array.to.collection.copy.display.name:
    text: Manual array to collection copy
manual.array.to.collection.copy.problem.descriptor:
    text: 'Manual array to collection copy #loc'
manual.array.to.collection.copy.replace.quickfix:
    text: Replace with 'Collections.addAll(...,...)'
map.replaceable.by.enum.map.display.name:
    text: '''Map'' can be replaced with ''EnumMap'''
map.replaceable.by.enum.map.problem.descriptor:
    text: '<code>#ref</code> can be replaced with ''EnumMap'' #loc'
marker.interface.display.name:
    text: Marker interface
marker.interface.problem.descriptor:
    text: 'Marker interface <code>#ref</code> #loc'
math.random.cast.to.int.display.name:
    text: '''Math.random()'' cast to ''int'''
math.random.cast.to.int.problem.descriptor:
    text: '<code>#ref</code> cast to ''int'' is always rounded down to ''0'' #loc'
math.random.cast.to.int.quickfix:
    text: Add parentheses to perform multiplication before cast
meta.annotation.without.runtime.retention:
    text: Non-runtime annotation to be used by reflection
method.call.in.loop.condition.display.name:
    text: Method call in loop condition
method.call.in.loop.condition.problem.descriptor:
    text: 'Call to method <code>#ref()</code> in loop condition #loc'
method.can.be.variable.arity.method.display.name:
    text: Method can have varargs parameter
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option:
    text: Ignore all primitive array types
method.can.be.variable.arity.method.ignore.byte.short.option:
    text: Ignore parameters with type byte[] or short[]
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option:
    text: Ignore multidimensional array parameters
method.can.be.variable.arity.method.ignore.multiple.arrays.option:
    text: Ignore methods with multiple array parameters
method.can.be.variable.arity.method.ignore.overriding.methods:
    text: Ignore methods overriding a super method
method.can.be.variable.arity.method.problem.descriptor:
    text: '<code>#ref()</code> can be converted to varargs method #loc'
method.complexity.limit.option:
    text: 'Method complexity limit:'
method.count.ignore.getters.setters.option:
    text: '&Ignore simple getter and setter methods'
method.count.limit.option:
    text: 'Method count limit:'
method.coupling.display.name:
    text: Overly coupled method
method.coupling.limit.option:
    text: 'Method coupling limit:'
method.coupling.problem.descriptor:
    text: '<code>#ref</code> is overly coupled (# referenced classes = {0}) #loc'
method.may.be.static.display.name:
    text: Method can be made 'static'
method.may.be.static.empty.option:
    text: Ignore empty methods
method.may.be.static.only.option:
    text: Only check 'private' or 'final' methods
method.may.be.static.problem.descriptor:
    text: 'Method <code>#ref()</code> may be ''static'' #loc'
method.may.be.synchronized.display.name:
    text: Method with single 'synchronized' block can be replaced with 'synchronized' method
method.may.be.synchronized.problem.descriptor:
    text: 'Method <code>#ref()</code> with synchronized block can be synchronized method #loc'
method.may.be.synchronized.quickfix:
    text: Make method synchronized and remove synchronized block
method.missing.return.statement.display.name:
    text: Method contains logic but is missing a 'return' statement
method.missing.return.statement.problem.descriptor:
    text: Method <code>#ref</code> contains logic but is missing a 'return' statement
method.name.pattern:
    text: Method name pattern
method.name.regex:
    text: Method Name Regex
method.name.same.as.class.name.display.name:
    text: Method name same as class name
method.name.same.as.class.name.problem.descriptor:
    text: 'Method name <code>#ref</code> is the same as its class name #loc'
method.name.same.as.parent.name.display.name:
    text: Method name same as parent class name
method.name.same.as.parent.name.problem.descriptor:
    text: 'Method name <code>#ref</code> is the same as its parent class name #loc'
method.names.differ.only.by.case.display.name:
    text: Method names differing only by case
method.names.differ.only.by.case.ignore.override.option:
    text: Ignore if method is override of super method
method.names.differ.only.by.case.problem.descriptor:
    text: 'Method name <code>#ref</code> and method name ''''{0}'''' differ only by case #loc'
method.only.used.from.inner.class.display.name:
    text: Private method only used from inner class
method.only.used.from.inner.class.ignore.option:
    text: Ignore methods accessed from an &anonymous class
method.only.used.from.inner.class.problem.descriptor:
    text: 'Method <code>#ref()</code>#loc is only used from inner class ''''{0}'''' #loc'
method.only.used.from.inner.class.problem.descriptor.anonymous.extending:
    text: 'Method <code>#ref()</code>#loc is only used from an anonymous class extending ''''{0}'''' #loc'
method.only.used.from.inner.class.problem.descriptor.anonymous.implementing:
    text: 'Method <code>#ref()</code>#loc is only used from an anonymous class implementing ''''{0}'''' #loc'
method.only.used.from.test.code.problem.descriptor:
    text: 'method <code>#ref()</code> only called from test code #loc'
method.overloads.display.name:
    text: Possibly unintended overload of method from superclass
method.overloads.problem.descriptor:
    text: 'Method <code>#ref()</code> overloads a compatible method of a superclass, when overriding might have been intended #loc'
method.overloads.report.incompatible.option:
    text: Report even if parameter types are not compatible
method.overrides.inaccessible.method.display.name:
    text: Method overrides inaccessible method of superclass
method.overrides.package.local.method.display.name:
    text: Method overrides package-private method of superclass located in other package
method.overrides.package.local.method.problem.descriptor:
    text: 'Method <code>#ref()</code> overrides a package-private method of a superclass located in another package #loc'
method.overrides.private.display.name:
    text: Method overrides 'private' method of superclass
method.overrides.private.display.name.problem.descriptor:
    text: 'Method <code>#ref()</code> overrides a ''private'' method of a superclass #loc'
method.overrides.static.display.name:
    text: Method tries to override 'static' method of superclass
method.overrides.static.problem.descriptor:
    text: 'Method <code>#ref()</code> tries to override a static method of a superclass #loc'
method.ref.can.be.replaced.with.lambda.name:
    text: Method reference can be replaced with lambda
method.ref.can.be.replaced.with.lambda.quickfix:
    text: Replace method reference with lambda
method.return.always.constant.display.name:
    text: Method returns per-class constant
method.return.always.constant.problem.descriptor:
    text: Method <code>#ref()</code> and all its derivables always return constants
method.return.concrete.class.display.name:
    text: Method return of concrete class
method.return.concrete.class.problem.descriptor:
    text: 'Method returns a concrete class <code>#ref</code> #loc'
method.return.of.concrete.class.option:
    text: Ignore methods whose return type is an abstract class
method.with.multiple.loops.display.name:
    text: Method with multiple loops
method.with.multiple.loops.problem.descriptor:
    text: '<code>#ref</code> contains {0} loops #loc'
mismatched.read.write.array.display.name:
    text: Mismatched read and write of array
mismatched.read.write.array.problem.descriptor.read.not.write:
    text: 'Contents of array <code>#ref</code> are read, but never written to #loc'
mismatched.read.write.array.problem.descriptor.write.not.read:
    text: 'Contents of array <code>#ref</code> are written to, but never read #loc'
mismatched.string.builder.queried.problem.descriptor:
    text: 'Contents of <code>{0} #ref</code> are queried, but never updated #loc'
mismatched.string.builder.query.update.display.name:
    text: Mismatched query and update of 'StringBuilder'
mismatched.string.builder.updated.problem.descriptor:
    text: 'Contents of <code>{0} #ref</code> are updated, but never queried #loc'
mismatched.update.collection.display.name:
    text: Mismatched query and update of collection
mismatched.update.collection.problem.description.queried.not.updated:
    text: 'Contents of collection <code>#ref</code> are queried, but never updated #loc'
mismatched.update.collection.problem.descriptor.updated.not.queried:
    text: 'Contents of collection <code>#ref</code> are updated, but never queried #loc'
misordered.assert.equals.arguments.display.name:
    text: Misordered 'assertEquals()' arguments
misordered.assert.equals.arguments.flip.quickfix:
    text: Flip compared arguments
misordered.assert.equals.arguments.problem.descriptor:
    text: 'Arguments to <code>#ref()</code> in wrong order #loc'
misordered.assert.equals.parameters.display.name:
    text: Misordered 'assertEquals()' arguments
misordered.assert.equals.parameters.flip.quickfix:
    text: Flip compared arguments
misordered.assert.equals.parameters.problem.descriptor:
    text: 'Arguments to <code>#ref()</code> in wrong order #loc'
missing.deprecated.annotation.add.quickfix:
    text: Add '@Deprecated' annotation
missing.deprecated.annotation.display.name:
    text: Missing '@Deprecated' annotation
missing.deprecated.annotation.problem.descriptor:
    text: 'Missing ''@Deprecated'' annotation #loc'
missing.deprecated.tag.option:
    text: Warn on missing @deprecated Javadoc tag explanation
missing.deprecated.tag.problem.descriptor:
    text: 'Missing ''@deprecated'' Javadoc tag explanation #loc'
missing.override.annotation.add.quickfix:
    text: Add @Override annotation
missing.override.annotation.display.name:
    text: Missing '@Override' annotation
missing.override.annotation.problem.descriptor:
    text: 'Missing ''@Override'' annotation on <code>#ref()</code> #loc'
missing.package.html.problem.descriptor:
    text: Package ''{0}'' is missing a <code>package.html</code> file
missing.package.info.display.name:
    text: Missing 'package-info.java'
missing.package.info.problem.descriptor:
    text: Package ''{0}'' is missing a <code>package-info.java</code> file
missorted.modifiers.display.name:
    text: Missorted modifiers
missorted.modifiers.problem.descriptor:
    text: 'Missorted modifiers <code>#ref</code> #loc'
missorted.modifiers.require.option:
    text: Require annotations to be sorted before keywords
missorted.modifiers.sort.quickfix:
    text: Sort modifiers
misspelled.compareto.display.name:
    text: '''compareto()'' instead of ''compareTo()'''
misspelled.compareto.problem.descriptor:
    text: '<code>#ref()</code> method should probably be ''compareTo()'' #loc'
misspelled.equals.display.name:
    text: '''equal()'' instead of ''equals()'''
misspelled.equals.problem.descriptor:
    text: '<code>#ref()</code> method should probably be ''equals()'' #loc'
misspelled.hashcode.display.name:
    text: '''hashcode()'' instead of ''hashCode()'''
misspelled.hashcode.problem.descriptor:
    text: '<code>#ref()</code> should probably be ''hashCode()'' #loc'
misspelled.set.up.display.name:
    text: '''setup()'' instead of ''setUp()'''
misspelled.set.up.problem.descriptor:
    text: '<code>#ref()</code> probably be ''setUp()'' #loc'
misspelled.tear.down.display.name:
    text: '''teardown()'' instead of ''tearDown()'''
misspelled.tear.down.problem.descriptor:
    text: '<code>#ref()</code> method should probably be ''tearDown()'' #loc'
misspelled.tostring.display.name:
    text: '''tostring()'' instead of ''toString()'''
misspelled.tostring.problem.descriptor:
    text: '<code>#ref()</code> method should probably be ''toString()'' #loc'
module.with.too.few.classes.display.name:
    text: Module with too few classes
module.with.too.few.classes.min.option:
    text: 'Minimum number of classes:'
module.with.too.few.classes.problem.descriptor:
    text: Module ''{0}'' contains too few classes ({1} < {2})
module.with.too.many.classes.display.name:
    text: Module with too many classes
module.with.too.many.classes.max.option:
    text: 'Maximum number of classes:'
module.with.too.many.classes.problem.descriptor:
    text: Module ''{0}'' contains too many classes ({1} > {2})
move.anonymous.to.inner.quickfix:
    text: Convert to named inner class
move.class.quickfix:
    text: Move class
multi.catch.can.be.split.name:
    text: Multi-catch can be split into separate catch blocks
multi.catch.can.be.split.quickfix:
    text: Split multi-catch into separate 'catch' blocks
multiple.declaration.display.name:
    text: Multiple variables in one declaration
multiple.declaration.option:
    text: Ignore 'for' loop declarations
multiple.declaration.problem.descriptor:
    text: 'Multiple variables in one declaration #loc'
multiple.exceptions.declared.on.test.method.display.name:
    text: Multiple exceptions declared on test method
multiple.exceptions.declared.on.test.method.problem.descriptor:
    text: '<code>#ref</code> could be replaced with ''throws Exception'' #loc'
multiple.exceptions.declared.on.test.method.quickfix:
    text: Replace with 'throws Exception'
multiple.loggers.display.name:
    text: Class with multiple loggers
multiple.loggers.problem.descriptor:
    text: 'Class <code>#ref</code> declares multiple loggers #loc'
multiple.return.points.per.method.display.name:
    text: Method with multiple return points
multiple.return.points.per.method.problem.descriptor:
    text: '<code>#ref</code> has {0} return points #loc'
multiple.top.level.classes.in.file.display.name:
    text: Multiple top level classes in single file
multiple.top.level.classes.in.file.problem.descriptor:
    text: Multiple top level classes in file
multiple.typed.declaration.display.name:
    text: Variables of different types in one declaration
multiple.typed.declaration.problem.descriptor:
    text: 'Variables of different types in one declaration #loc'
multiply.or.divide.by.power.of.two.display.name:
    text: Multiplication or division by power of two
multiply.or.divide.by.power.of.two.divide.option:
    text: Check divisions by a power of two also
multiply.or.divide.by.power.of.two.replace.quickfix:
    text: Replace with shift
naked.notify.display.name:
    text: '''notify()'' or ''notifyAll()'' without corresponding state change'
naked.notify.problem.descriptor:
    text: 'Call to <code>#ref()</code> without corresponding state change #loc'
naming.convention.problem.descriptor.long:
    text: '{0} name <code>#ref</code> is too long ({1} > {2}) #loc'
naming.convention.problem.descriptor.regex.mismatch:
    text: '{0} name <code>#ref</code> doesn''''t match regex ''''{1}'''' #loc'
naming.convention.problem.descriptor.short:
    text: '{0} name <code>#ref</code> is too short ({1} < {2}) #loc'
native.method.display.name:
    text: Native method
native.method.naming.convention.display.name:
    text: '''native'' method naming convention'
native.method.naming.convention.element.description:
    text: '''native'' method'
native.method.problem.descriptor:
    text: 'Methods declared <code>#ref</code> are non-portable #loc'
negated.conditional.display.name:
    text: Conditional expression with negated condition
negated.conditional.expression.display.name:
    text: Negated conditional expression
negated.conditional.expression.problem.descriptor:
    text: 'Negating conditional expression #loc'
negated.conditional.expression.quickfix:
    text: Remove negation
negated.conditional.ignore.option:
    text: Ignore '!= null' comparisons
negated.conditional.invert.quickfix:
    text: Invert condition
negated.conditional.problem.descriptor:
    text: 'Conditional expression with negated condition #loc'
negated.equality.expression.display.name:
    text: Negated equality expression
negated.equality.expression.problem.descriptor:
    text: 'Negating ''''{0}'''' #loc'
negated.equality.expression.quickfix:
    text: Remove negation
negated.if.else.display.name:
    text: '''if'' statement with negated condition'
negated.if.else.ignore.negated.null.option:
    text: Ignore '!= null' comparisons
negated.if.else.ignore.negated.zero.option:
    text: Ignore '!= 0' comparisons
negated.if.else.invert.quickfix:
    text: Invert 'if' condition
negated.if.else.problem.descriptor:
    text: '<code>#ref</code> statement with negated condition #loc'
negatively.named.boolean.variable.display.name:
    text: Negatively named boolean variable
negatively.named.boolean.variable.problem.descriptor:
    text: 'Boolean variable <code>#ref</code> is negatively named #loc'
nested.assignment.display.name:
    text: Result of assignment used
nested.assignment.problem.descriptor:
    text: 'Result of assignment expression used #loc'
nested.conditional.expression.display.name:
    text: Nested conditional expression
nested.conditional.expression.problem.descriptor:
    text: 'Nested conditional expression <code>#ref</code> #loc'
nested.method.call.display.name:
    text: Nested method call
nested.method.call.ignore.option:
    text: Ignore nested method calls in field initializers
nested.method.call.problem.descriptor:
    text: 'Nested method call <code>#ref()</code> #loc'
nested.switch.statement.display.name:
    text: Nested 'switch' statement
nested.switch.statement.problem.descriptor:
    text: 'Nested <code>#ref</code> statement #loc'
nested.synchronized.statement.display.name:
    text: Nested 'synchronized' statement
nested.synchronized.statement.problem.descriptor:
    text: 'Nested <code>#ref</code> statement #loc'
nested.try.statement.display.name:
    text: Nested 'try' statement
nested.try.statement.problem.descriptor:
    text: 'Nested <code>#ref</code> statement #loc'
nesting.depth.display.name:
    text: Overly nested method
nesting.depth.limit.option:
    text: 'Nesting depth limit:'
nesting.depth.problem.descriptor:
    text: '<code>#ref</code> is overly nested (maximum nesting depth = {0}) #loc'
new.exception.without.arguments.display.name:
    text: Exception constructor called without arguments
new.exception.without.arguments.ignore.option:
    text: Ignore for exceptions that have no constructors with parameters
new.exception.without.arguments.problem.descriptor:
    text: '<code>new #ref()</code> without arguments #loc'
new.string.buffer.replaceable.by.string.problem.descriptor:
    text: '<code>#ref</code> can be replaced with ''String'' #loc'
new.string.buffer.with.char.argument.display.name:
    text: StringBuffer constructor call with 'char' argument
new.string.buffer.with.char.argument.problem.descriptor:
    text: '<code>new #ref()</code> with argument of type ''char'' #loc'
new.string.buffer.with.char.argument.quickfix:
    text: Replace char argument with String literal
no.logger.display.name:
    text: Class without logger
no.logger.problem.descriptor:
    text: 'Class <code>#ref</code> does not declare a logger #loc'
non.atomic.operation.on.volatile.field.display.name:
    text: Non-atomic operation on 'volatile' field
non.atomic.operation.on.volatile.field.problem.descriptor:
    text: 'Non-atomic operation on volatile field <code>#ref</code> #loc'
non.boolean.method.name.must.not.start.with.question.display.name:
    text: Non-boolean method name must not start with question word
non.boolean.method.name.must.not.start.with.question.problem.descriptor:
    text: 'Non-boolean method name <code>#ref</code> starts with a question word #loc'
non.comment.source.statements.display.name:
    text: Overly long method
non.comment.source.statements.limit.option:
    text: 'Non-comment source statements limit:'
non.comment.source.statements.problem.descriptor:
    text: '<code>#ref</code> is too long (# Non-comment source statements = {0}) #loc'
non.constant.logger.display.name:
    text: Non-constant logger
non.constant.logger.problem.descriptor:
    text: 'Non-constant logger field <code>#ref</code> #loc'
non.exception.name.ends.with.exception.display.name:
    text: Non-exception class name ends with 'Exception'
non.exception.name.ends.with.exception.problem.descriptor:
    text: 'Non-exception class name <code>#ref</code> ends with ''Exception'' #loc'
non.exception.name.ends.with.exception.quickfix:
    text: Make ''{0}'' extend ''java.lang.Exception''
non.final.clone.display.name:
    text: Non-final 'clone()' in secure context
non.final.clone.problem.descriptor:
    text: 'Non-final <code>#ref()</code> method, compromising security #loc'
non.final.field.compareto.display.name:
    text: Non-final field referenced in 'compareTo()'
non.final.field.compareto.problem.descriptor:
    text: 'Non-final field <code>#ref</code> accessed in ''compareTo()'' #loc'
non.final.field.in.enum.display.name:
    text: Non-final field in 'enum'
non.final.field.in.enum.problem.descriptor:
    text: 'Non-final field <code>#ref</code> in enum ''''{0}'''' #loc'
non.final.field.in.equals.display.name:
    text: Non-final field referenced in 'equals()'
non.final.field.in.equals.problem.descriptor:
    text: 'Non-final field <code>#ref</code> accessed in ''equals()''  #loc'
non.final.field.in.hashcode.display.name:
    text: Non-final field referenced in 'hashCode()'
non.final.field.in.hashcode.problem.descriptor:
    text: 'Non-final field <code>#ref</code> accessed in ''hashCode()'' #loc'
non.final.field.of.exception.display.name:
    text: Non-final field of 'Exception' class
non.final.field.of.exception.problem.descriptor:
    text: 'Non-final field <code>#ref</code> of exception class #loc'
non.final.static.variable.initialization.display.name:
    text: Non-final static field is used during class initialization
non.final.static.variable.initialization.problem.descriptor:
    text: 'Non-final static field <code>#ref</code> used during class initialization #loc'
non.final.utility.class.display.name:
    text: Utility class is not 'final'
non.final.utility.class.problem.descriptor:
    text: 'Utility class <code>#ref</code> is not ''final'' #loc'
non.protected.constructor.in.abstract.class.display.name:
    text: '''public'' constructor in ''abstract'' class'
non.protected.constructor.in.abstract.class.ignore.option:
    text: Ignore for non-public classes
non.protected.constructor.in.abstract.class.problem.descriptor:
    text: 'Constructor <code>#ref()</code> is not declared ''protected'' in ''abstract'' class #loc'
non.public.clone.display.name:
    text: '''clone()'' method not ''public'''
non.public.clone.problem.descriptor:
    text: '<code>#ref()</code> method not ''public'' #loc'
non.reproducible.math.call.display.name:
    text: Non-reproducible call to 'Math'
non.reproducible.math.call.problem.descriptor:
    text: '<code>Math.#ref()</code> may produce non-reproducible results #loc'
non.reproducible.math.call.replace.quickfix:
    text: Replace with 'StrictMath' call
non.serializable.ainterface.with.serialversionuid.problem.descriptor:
    text: 'Non-serializable @interface <code>#ref</code> defines a ''serialVersionUID'' field #loc'
non.serializable.anonymous.with.readwriteobject.problem.descriptor.both:
    text: 'Non-serializable anonymous class extending <code>#ref</code> defines ''readObject()'' and ''writeObject()'' #loc'
non.serializable.anonymous.with.readwriteobject.problem.descriptor.read:
    text: 'Non-serializable anonymous class extending <code>#ref</code> defines ''readObject()'' #loc'
non.serializable.anonymous.with.readwriteobject.problem.descriptor.write:
    text: 'Non-serializable anonymous class extending <code>#ref</code> defines ''writeObject()'' #loc'
non.serializable.anonymous.with.serialversionuid.problem.descriptor:
    text: 'Non-serializable anonymous class derived from <code>#ref</code> defines a ''serialVersionUID'' field #loc'
non.serializable.class.with.readwriteobject.display.name:
    text: Non-serializable class with 'readObject()' or 'writeObject()'
non.serializable.class.with.readwriteobject.problem.descriptor.both:
    text: 'Non-serializable class <code>#ref</code> defines ''readObject()'' and ''writeObject()'' #loc'
non.serializable.class.with.readwriteobject.problem.descriptor.read:
    text: 'Non-serializable class <code>#ref</code> defines ''readObject()'' #loc'
non.serializable.class.with.readwriteobject.problem.descriptor.write:
    text: 'Non-serializable class <code>#ref</code> defines ''writeObject()'' #loc'
non.serializable.class.with.serialversionuid.problem.descriptor:
    text: 'Non-serializable class <code>#ref</code> defines a ''serialVersionUID'' field #loc'
non.serializable.field.in.serializable.class.display.name:
    text: Non-serializable field in a 'Serializable' class
non.serializable.field.in.serializable.class.problem.descriptor:
    text: 'Non-serializable field ''#ref'' in Serializable class #loc'
non.serializable.interface.with.serialversionuid.problem.descriptor:
    text: 'Non-serializable interface <code>#ref</code> defines a ''serialVersionUID'' field #loc'
non.serializable.object.bound.to.http.session.display.name:
    text: Non-serializable object bound to 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor:
    text: 'Non-serializable object bound to HttpSession #loc'
non.serializable.object.passed.to.object.stream.display.name:
    text: Non-serializable object passed to 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor:
    text: 'Non-serializable object passed to ObjectOutputStream #loc'
non.serializable.with.serialversionuid.display.name:
    text: Non-serializable class with 'serialVersionUID'
non.serializable.with.serialversionuid.remove.quickfix:
    text: Remove 'serialVersionUID' field
non.short.circuit.boolean.expression.display.name:
    text: Non-short-circuit boolean expression
non.short.circuit.boolean.expression.problem.descriptor:
    text: 'Non-short-circuit boolean expression <code>#ref</code> #loc'
non.short.circuit.boolean.expression.replace.quickfix:
    text: Replace with short circuit expression
non.static.inner.class.in.secure.context.display.name:
    text: Non-'static' inner class in secure context
non.static.inner.class.in.secure.context.problem.descriptor:
    text: 'Non-''static'' inner class <code>#ref</code>, compromising security #loc'
non.synchronized.method.overrides.synchronized.method.display.name:
    text: Unsynchronized method overrides 'synchronized' method
non.synchronized.method.overrides.synchronized.method.problem.descriptor:
    text: 'Unsynchronized method <code>#ref()</code> overrides synchronized method #loc'
non.thread.safe.lazy.initialization.display.name:
    text: Unsafe lazy initialization of 'static' field
non.thread.safe.lazy.initialization.problem.descriptor:
    text: 'Lazy initialization of ''static'' field <code>#ref</code> is not thread-safe #loc'
none:
    text: none
noop.method.in.abstract.class.display.name:
    text: No-op method in 'abstract' class
noop.method.in.abstract.class.problem.descriptor:
    text: 'No-op Method <code>#ref()</code> should be made abstract #loc'
normalize.declaration.quickfix:
    text: Split into separate declarations
not.equals.to.equality.quickfix:
    text: Replace '!equals()' with '!='
notify.called.on.condition.display.name:
    text: '''notify()''  or ''notifyAll()'' called on ''java.util.concurrent.locks.Condition'' object'
notify.called.on.condition.problem.descriptor:
    text: 'Call to <code>#ref()</code> on Condition object #loc'
notify.not.in.synchronized.context.display.name:
    text: '''notify()'' or ''notifyAll()'' while not synchronized'
notify.not.in.synchronized.context.problem.descriptor:
    text: 'Call to <code>#ref()</code> is made outside of a synchronized context #loc'
notify.without.corresponding.wait.display.name:
    text: '''notify()'' without corresponding ''wait()'''
notify.without.corresponding.wait.problem.descriptor:
    text: 'Call to <code>#ref()</code> without corresponding <code>wait()</code> #loc'
null.argument.to.var.arg.method.display.name:
    text: Confusing argument to varargs method
null.argument.to.var.arg.method.problem.descriptor:
    text: 'Confusing argument <code>#ref</code>, unclear if a varargs or non-varargs call is desired #loc'
null.thrown.display.name:
    text: '''null'' thrown'
null.thrown.problem.descriptor:
    text: '<code>#ref</code> thrown #loc'
null.thrown.quickfix:
    text: Replace with 'new NullPointerException()'
number.comparison.display.name:
    text: Number comparison using '==', instead of 'equals()'
number.comparison.problem.descriptor:
    text: 'Number objects are compared using <code>#ref</code>, not ''equals()'' #loc'
object.allocation.in.loop.display.name:
    text: Object allocation in loop
object.allocation.in.loop.problem.descriptor:
    text: 'Object allocation <code>new #ref()</code> in loop #loc'
object.comparison.display.name:
    text: Object comparison using '==', instead of 'equals()'
object.comparison.enumerated.ignore.option:
    text: Ignore '==' between enum variables
object.comparison.klass.ignore.option:
    text: Ignore '==' on 'java.lang.Class' objects
object.comparison.problem.description:
    text: 'Object values are compared using <code>#ref</code>, not ''equals()'' #loc'
object.comparison.replace.quickfix:
    text: Replace with 'equals()'
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option:
    text: Ignore '==' between objects of a type with only 'private' constructors
object.equals.null.display.name:
    text: Object.equals(null)
object.equals.null.problem.descriptor:
    text: '<code>.equals(#ref)</code> is probably not what was intended #loc'
object.instantiation.inside.equals.or.hashcode.display.name:
    text: Object instantiation inside 'equals()' or 'hashCode()'
object.instantiation.inside.equals.or.hashcode.problem.descriptor:
    text: 'Object instantiation inside ''''{0}()'''' #loc'
object.instantiation.inside.equals.or.hashcode.problem.descriptor2:
    text: Object instantiation inside ''{0}()'' ({1})#loc
object.notify.display.name:
    text: Call to 'notify()' instead of 'notifyAll()'
object.notify.problem.descriptor:
    text: '<code>#ref</code> should probably be replaced with ''notifyAll()'' #loc'
object.notify.replace.quickfix:
    text: Replace with 'notifyAll()'
octal.and.decimal.integers.in.same.array.display.name:
    text: Octal and decimal integers in same array
octal.and.decimal.integers.in.same.array.problem.descriptor:
    text: 'Octal and decimal integers in the same array initializer #loc'
octal.literal.display.name:
    text: Octal integer
octal.literal.problem.descriptor:
    text: 'Octal integer <code>#ref</code> #loc'
only.report.public.methods.option:
    text: Only report 'public' methods
only.report.qualified.static.usages.option:
    text: Only report qualified static access from a static context
only.report.static.methods:
    text: '&Only report ''static'' methods'
only.warn.on.protected.clone.methods:
    text: Only warn on 'protected' clone methods
only.warn.on.public.clone.methods:
    text: Only warn on 'public' clone methods
only.weaken.to.an.interface:
    text: Only weaken to an interface
optional.contains.array.problem.descriptor:
    text: '''Optional'' contains array <code>#ref</code>'
optional.contains.collection.display.name:
    text: '''Optional'' contains array or collection'
optional.contains.collection.problem.descriptor:
    text: '''Optional'' contains collection <code>#ref</code>'
optional.used.as.field.or.parameter.type.display.name:
    text: '''Optional'' used as field or parameter type'
optional.used.as.field.type.problem.descriptor:
    text: <code>#ref</code> used as type for field ''{0}''
optional.used.as.parameter.type.problem.descriptor:
    text: <code>#ref</code> used as type for parameter ''{0}''
orred.not.equal.expression.display.name:
    text: Identical reference in '!=' expression on both sides of '||' expression
orred.not.equal.expression.problem.descriptor:
    text: '<code>#ref</code> is always true #loc'
orred.not.equal.expression.quickfix:
    text: Change '||' to '\&\&'
overloaded.methods.with.same.number.parameters.display.name:
    text: Overloaded methods with same number of parameters
overloaded.methods.with.same.number.parameters.option:
    text: <html>Ignore overloaded methods whose parameter types are definitely incompatible</html>
overloaded.methods.with.same.number.parameters.problem.descriptor:
    text: 'Multiple methods named <code>#ref</code> with the same number of parameters #loc'
overloaded.vararg.constructor.problem.descriptor:
    text: 'Overloaded varargs constructor <code>#ref()</code> #loc'
overloaded.vararg.method.display.name:
    text: Overloaded varargs method
overloaded.vararg.method.problem.descriptor:
    text: 'Overloaded varargs method <code>#ref()</code> #loc'
overly.broad.throws.clause.display.name:
    text: Overly broad 'throws' clause
overly.broad.throws.clause.ignore.thrown.option:
    text: Ignore exceptions which &hide others but are themselves thrown
overly.broad.throws.clause.problem.descriptor1:
    text: '<code>throws #ref</code> is too broad, masking exception ''''{0}'''' #loc'
overly.broad.throws.clause.problem.descriptor2:
    text: '<code>throws #ref</code> is too broad, masking exceptions ''''{0}'''' and ''''{1}'''' #loc'
overly.broad.throws.clause.quickfix1:
    text: Add specific exceptions
overly.broad.throws.clause.quickfix2:
    text: Replace with specific exceptions
overly.complex.anonymous.inner.class.display.name:
    text: Overly complex anonymous class
overly.complex.anonymous.inner.class.problem.descriptor:
    text: 'Overly complex anonymous class (cyclomatic complexity = {0}) #loc'
overly.complex.arithmetic.expression.display.name:
    text: Overly complex arithmetic expression
overly.complex.arithmetic.expression.max.number.option:
    text: 'Maximum number of terms:'
overly.complex.arithmetic.expression.problem.descriptor:
    text: 'Overly complex arithmetic expression #loc'
overly.complex.boolean.expression.display.name:
    text: Overly complex boolean expression
overly.complex.boolean.expression.ignore.option:
    text: Ignore pure conjunctions and disjunctions
overly.complex.boolean.expression.max.terms.option:
    text: 'Maximum number of terms:'
overly.complex.boolean.expression.problem.descriptor:
    text: 'Overly complex boolean expression ({0} terms) #loc'
overly.complex.class.display.name:
    text: Overly complex class
overly.complex.class.problem.descriptor:
    text: 'Overly complex class <code>#ref</code> (cyclomatic complexity = {0}) #loc'
overly.coupled.class.class.coupling.limit.option:
    text: 'Class coupling limit:'
overly.coupled.class.display.name:
    text: Overly coupled class
overly.coupled.class.problem.descriptor:
    text: '<code>#ref</code> is overly coupled (dependencies = {0}) #loc'
overly.long.lambda.display.name:
    text: Overly long lambda expression
overly.long.lambda.problem.descriptor:
    text: 'Lambda expression is too long (# Non-comment source statements = {0}) #loc'
overly.strong.type.cast.display.name:
    text: Overly strong type cast
overly.strong.type.cast.ignore.in.matching.instanceof.option:
    text: Ignore casts with a matching instanceof expression
overly.strong.type.cast.problem.descriptor:
    text: 'Cast to <code>#ref</code> can be weakened to ''''{0}'''' #loc'
overly.strong.type.cast.weaken.quickfix:
    text: Weaken overly strong cast
overridable.method.call.in.constructor.display.name:
    text: Overridable method called during object construction
overridable.method.call.in.constructor.problem.descriptor:
    text: 'Call to overridable method <code>#ref()</code> during object construction #loc'
overridden.method.call.in.constructor.display.name:
    text: Overridden method called during object construction
overridden.method.call.in.constructor.problem.descriptor:
    text: 'Call to overridden method <code>#ref()</code> during object construction #loc'
package.dot.html.convert.command:
    text: package.html to package-info.java conversion
package.dot.html.delete.command:
    text: package.html deletion
package.dot.html.may.be.package.info.convert.quickfix:
    text: Convert to 'package-info.java'
package.dot.html.may.be.package.info.delete.quickfix:
    text: Delete 'package.html'
package.dot.html.may.be.package.info.display.name:
    text: '''package.html'' may be converted to ''package-info.java'''
package.dot.html.may.be.package.info.exists.problem.descriptor:
    text: <code>package.html</code> is ignored because <code>package-info.java</code> exists
package.dot.html.may.be.package.info.problem.descriptor:
    text: <code>package.html</code> may be converted to <code>package-info.java</code>
package.in.multiple.modules.display.name:
    text: Package with classes in multiple modules
package.in.multiple.modules.problem.descriptor:
    text: Package ''{0}'' has classes in multiple modules
package.info.java.without.package.display.name:
    text: '''package-info.java'' without ''package'' statement'
package.info.without.package.family.quickfix:
    text: Add package statement
package.info.without.package.problem.descriptor:
    text: '''package-info.java'' does not have a ''package'' statement'
package.info.without.package.quickfix:
    text: Add ''package {0};''
package.local.field.not.accessible:
    text: Package-private field ''{0}'' is not accessible from here
package.local.private:
    text: package-private \& private
package.naming.convention.display.name:
    text: Package naming convention
package.naming.convention.problem.descriptor.long:
    text: Package name <code>{0}</code> is too long
package.naming.convention.problem.descriptor.regex.mismatch:
    text: Package name <code>{0}</code> doesn''t match regex ''{1}''
package.naming.convention.problem.descriptor.short:
    text: Package name <code>{0}</code> is too short
package.visible.field.display.name:
    text: Package-visible field
package.visible.field.problem.descriptor:
    text: 'Package-visible field <code>#ref</code> #loc'
package.visible.inner.class.display.name:
    text: Package-visible nested class
package.visible.inner.class.ignore.enum.option:
    text: Ignore package-visible inner enums
package.visible.inner.class.ignore.interface.option:
    text: Ignore package-visible inner interfaces
package.visible.inner.class.problem.descriptor:
    text: 'Package-visible nested class <code>#ref</code> #loc'
package.with.too.few.classes.display.name:
    text: Package with too few classes
package.with.too.few.classes.min.option:
    text: 'Minimum number of classes:'
package.with.too.few.classes.problem.descriptor:
    text: Package ''{0}'' contains too few classes ({1} < {2})
package.with.too.many.classes.display.name:
    text: Package with too many classes
package.with.too.many.classes.max.option:
    text: 'Maximum number of classes:'
package.with.too.many.classes.problem.descriptor:
    text: Package ''{0}'' contains too many classes ({1} > {2})
parameter.hides.member.variable.display.name:
    text: Parameter hides field
parameter.hides.member.variable.ignore.abstract.methods.option:
    text: Ignore for abstract methods
parameter.hides.member.variable.ignore.constructors.option:
    text: Ignore for constructors
parameter.hides.member.variable.ignore.setters.option:
    text: Ignore for property setters
parameter.hides.member.variable.ignore.static.parameters.option:
    text: Ignore for static method parameters hiding instance fields
parameter.hides.member.variable.ignore.superclass.option:
    text: Ignore superclass fields not visible from subclass
parameter.hides.member.variable.problem.descriptor:
    text: 'Parameter <code>#ref</code> hides field in class ''''{0}'''' #loc'
parameter.limit.option:
    text: 'Parameter limit:'
parameter.name.differs.from.overridden.parameter.display.name:
    text: Parameter name differs from parameter in overridden method
parameter.name.differs.from.overridden.parameter.ignore.character.option:
    text: Ignore if overridden parameter contains only one character
parameter.name.differs.from.overridden.parameter.ignore.library.option:
    text: Ignore if overridden parameter is from a library
parameter.name.differs.from.overridden.parameter.problem.descriptor:
    text: 'Parameter name <code>#ref</code> is different from parameter ''''{0}'''' overridden #loc'
parameter.naming.convention.display.name:
    text: Method parameter naming convention
parameter.naming.convention.element.description:
    text: Parameter
parameter.naming.convention.problem.descriptor.long:
    text: 'Parameter name <code>#ref</code> is too long #loc'
parameter.naming.convention.problem.descriptor.regex.mismatch:
    text: 'Parameter name <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
parameter.naming.convention.problem.descriptor.short:
    text: 'Parameter name <code>#ref</code> is too short #loc'
parameter.of.concrete.class.option:
    text: Ignore parameters whose type is abstract class
parameter.type.prevents.overriding.display.name:
    text: Parameter type prevents overriding
parameter.type.prevents.overriding.family.quickfix:
    text: Change type of parameter
parameter.type.prevents.overriding.problem.descriptor:
    text: 'Parameter type <code>#ref</code> is located in ''''{0}'''' while super method parameter type is located in ''''{1}'''' preventing overriding #loc'
parameter.type.prevents.overriding.quickfix:
    text: Change type of parameter to ''{0}''
parameters.per.constructor.display.name:
    text: Constructor with too many parameters
parameters.per.constructor.problem.descriptor:
    text: '<code>#ref()</code> has too many parameters (num parameters = {0}) #loc'
parameters.per.method.display.name:
    text: Method with too many parameters
parameters.per.method.problem.descriptor:
    text: '<code>#ref()</code> has too many parameters (num parameters = {0}) #loc'
placeholder.count.matches.argument.count.display.name:
    text: Number of placeholders does not match number of arguments in logging call
placeholder.count.matches.argument.count.fewer.problem.descriptor:
    text: 'Fewer arguments provided ({0}) than placeholders specified ({1}) #loc'
placeholder.count.matches.argument.count.more.problem.descriptor:
    text: 'More arguments provided ({0}) than placeholders specified ({1}) #loc'
pointless.arithmetic.expression.display.name:
    text: Pointless arithmetic expression
pointless.bitwise.expression.display.name:
    text: Pointless bitwise expression
pointless.bitwise.expression.ignore.option:
    text: Ignore named constants in determining pointless expressions
pointless.bitwise.expression.simplify.quickfix:
    text: Simplify
pointless.boolean.expression.display.name:
    text: Pointless boolean expression
pointless.boolean.expression.ignore.option:
    text: Ignore named constants in determining pointless expressions
pointless.indexof.comparison.always.false.problem.descriptor:
    text: '<code>#ref</code> is always false #loc'
pointless.indexof.comparison.always.true.problem.descriptor:
    text: '<code>#ref</code> is always true #loc'
pointless.indexof.comparison.display.name:
    text: Pointless 'indexOf()' comparison
pointless.nullcheck.after.problem.descriptor:
    text: Unnecessary 'null' check after 'instanceof' expression
pointless.nullcheck.display.name:
    text: Unnecessary 'null' check before 'instanceof' expression
pointless.nullcheck.problem.descriptor:
    text: Unnecessary 'null' check before 'instanceof' expression
pointless.nullcheck.simplify.quickfix:
    text: Remove unnecessary ''{0}'' condition
possible.throw.from.finally.block.problem.descriptor:
    text: '<code>{0}</code> might be thrown inside ''''finally'''' block #loc'
press.escape.to.remove.highlighting.message:
    text: Press Escape to remove the highlighting
primitive.array.argument.to.var.arg.method.display.name:
    text: Confusing primitive array argument to varargs method
primitive.array.argument.to.var.arg.method.problem.descriptor:
    text: 'Confusing primitive array argument to varargs method #loc'
primitive.fields.ignore.option:
    text: Ignore primitive fields
printstacktrace.call.display.name:
    text: Call to 'printStackTrace()'
printstacktrace.call.problem.descriptor:
    text: 'Call to <code>#ref()</code> should probably be replaced with more robust logging #loc'
private.field.not.accessible.problem.descriptor:
    text: '''''private'''' field ''''{0}'''' is not accessible from here'
private.member.access.between.outer.and.inner.classes.display.name:
    text: Synthetic accessor call
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix:
    text: Make ''{0}'' constructor package-private
private.member.access.between.outer.and.inner.classes.make.local.quickfix:
    text: Make ''{0}'' package-private
private.member.access.between.outer.and.inner.classes.problem.descriptor:
    text: 'Access to ''private'' member of class ''''{0}'''' requires synthetic accessor call #loc'
private.modifier:
    text: private
problematic.varargs.method.display.name:
    text: Non-varargs method overrides varargs method
problematic.varargs.method.override.problem.descriptor:
    text: 'Non-varargs method <code>#ref()</code> overrides varargs method #loc'
properties.object.as.hashtable.display.name:
    text: Use of 'Properties' object as a 'Hashtable'
properties.object.as.hashtable.get.quickfix:
    text: Replace with call to 'getProperty()'
properties.object.as.hashtable.problem.descriptor:
    text: 'Call to <code>Hashtable.#ref()</code> on properties object #loc'
properties.object.as.hashtable.set.quickfix:
    text: Replace with call to 'setProperty()'
property.value.set.to.itself.display.name:
    text: Property value set to itself
protected.field.display.name:
    text: Protected field
protected.field.not.accessible.problem.descriptor:
    text: '''''protected'''' field ''''{0}'''' is not accessible from here'
protected.field.problem.descriptor:
    text: 'Protected field <code>#ref</code> #loc'
protected.inner.class.display.name:
    text: Protected nested class
protected.inner.class.ignore.enum.option:
    text: Ignore 'protected' inner enums
protected.inner.class.ignore.interface.option:
    text: Ignore 'protected' inner interfaces
protected.inner.class.problem.descriptor:
    text: 'Protected nested class <code>#ref</code> #loc'
protected.member.in.final.class.display.name:
    text: '''protected'' member in ''final'' class'
protected.member.in.final.class.problem.descriptor:
    text: 'Class member declared <code>#ref</code> in ''final'' class #loc'
protected.package.local.private:
    text: protected, package-private \& private
public.constructor.display.name:
    text: '''public'' constructor'
public.constructor.in.non.public.class.display.name:
    text: '''public'' constructor in non-public class'
public.constructor.in.non.public.class.problem.descriptor:
    text: 'Constructor is declared <code>#ref</code> in non-public class ''''{0}'''' #loc'
public.constructor.in.non.public.class.quickfix:
    text: Make constructor ''{0}''
public.constructor.problem.descriptor:
    text: 'Public constructor <code>#ref()</code> #loc'
public.constructor.quickfix:
    text: Replace constructor with factory method
public.default.constructor.problem.descriptor:
    text: Class <code>#ref</code> has 'public' default constructor
public.field.accessed.in.synchronized.context.display.name:
    text: Non-private field accessed in 'synchronized' context
public.field.accessed.in.synchronized.context.problem.descriptor:
    text: 'Non-private field <code>#ref</code> accessed in synchronized context  #loc'
public.field.display.name:
    text: '''public'' field'
public.field.ignore.enum.type.fields.option:
    text: Ignore 'public final' fields of an enum type
public.field.problem.descriptor:
    text: '''public'' field <code>#ref</code> #loc'
public.inner.class.display.name:
    text: '''public'' nested class'
public.inner.class.ignore.enum.option:
    text: Ignore 'public' inner enums
public.inner.class.ignore.interface.option:
    text: Ignore 'public' inner interfaces
public.inner.class.problem.descriptor:
    text: '''public'' nested class <code>#ref</code> #loc'
public.method.not.in.interface.display.name:
    text: '''public'' method not exposed in interface'
public.method.not.in.interface.option:
    text: <html>Ignore if the containing class does not implement a non-library interface</html>
public.method.not.in.interface.problem.descriptor:
    text: '''public'' method <code>#ref()</code> is not exposed via an interface #loc'
public.method.without.logging.display.name:
    text: '''public'' method without logging'
public.method.without.logging.problem.descriptor:
    text: '''public'' method <code>#ref()</code> has no logging call #loc'
public.static.array.field.display.name:
    text: '''public static'' array field'
public.static.array.field.problem.descriptor:
    text: '''public static'' array field <code>#ref</code>, compromising security #loc'
public.static.collection.field.display.name:
    text: '''public static'' collection field'
public.static.collection.field.problem.descriptor:
    text: '''public static'' collection field <code>#ref</code>, compromising security #loc'
query.column.name:
    text: Query names start with
questionable.name.column.title:
    text: Name
questionable.name.display.name:
    text: Questionable name
questionable.name.problem.descriptor:
    text: 'Questionable name <code>#ref</code> #loc'
random.double.for.random.integer.display.name:
    text: Using 'Random.nextDouble()' to get random integer
random.double.for.random.integer.problem.descriptor:
    text: 'Using <code>Random.#ref</code> to create random integer #loc'
random.double.for.random.integer.replace.quickfix:
    text: Replace with 'nextInt()'
raw.use.of.parameterized.type.display.name:
    text: Raw use of parameterized class
raw.use.of.parameterized.type.ignore.new.objects.option:
    text: Ignore construction of new objects
raw.use.of.parameterized.type.ignore.overridden.parameter.option:
    text: Ignore parameter types of overriding methods
raw.use.of.parameterized.type.ignore.type.casts.option:
    text: Ignore type casts
raw.use.of.parameterized.type.ignore.uncompilable.option:
    text: Ignore where a type parameter would not compile
raw.use.of.parameterized.type.problem.descriptor:
    text: 'Raw use of parameterized class <code>#ref</code> #loc'
readobject.initialization.display.name:
    text: Instance field may not be initialized by 'readObject()'
readobject.initialization.problem.descriptor:
    text: 'Instance field <code>#ref</code> may not be initialized during ''readObject()'' call #loc'
readresolve.writereplace.protected.display.name:
    text: '''readResolve()'' or ''writeReplace()'' not declared ''protected'''
readresolve.writereplace.protected.problem.descriptor:
    text: '<code>#ref()</code> not declared ''protected'' #loc'
readwriteobject.private.display.name:
    text: '''readObject()'' or ''writeObject()'' not declared ''private'''
readwriteobject.private.problem.descriptor:
    text: '<code>#ref</code> not declared ''private'' #loc'
recordstore.opened.not.safely.closed.display.name:
    text: '''RecordStore'' opened but not safely closed'
redundant.else.display.name:
    text: Redundant 'else'
redundant.else.problem.descriptor:
    text: '<code>#ref</code> branch may be unwrapped, as the ''if'' branch never completes normally #loc'
redundant.else.unwrap.quickfix:
    text: Remove redundant 'else'
redundant.field.initialization.display.name:
    text: Redundant field initialization
redundant.field.initialization.problem.descriptor:
    text: 'Field initialization to <code>#ref</code> is redundant #loc'
redundant.field.initialization.remove.quickfix:
    text: Remove initializer
redundant.implements.display.name:
    text: Redundant interface declaration
redundant.implements.problem.descriptor:
    text: 'Redundant interface declaration <code>#ref</code> #loc'
redundant.implements.remove.quickfix:
    text: Remove redundant interface declaration
redundant.import.display.name:
    text: Redundant import
redundant.import.problem.descriptor:
    text: 'Redundant import <code>#ref</code> #loc'
redundant.local.variable.annotation.option:
    text: Ignore variables which have an annotation
redundant.local.variable.display.name:
    text: Redundant local variable
redundant.local.variable.ignore.option:
    text: Ignore immediately returned or thrown variables
redundant.method.override.display.name:
    text: Method is identical to its super method
redundant.method.override.problem.descriptor:
    text: 'Method <code>#ref()</code> is identical to its super method #loc'
redundant.method.override.quickfix:
    text: Remove redundant method
redundant.string.format.call.display.name:
    text: Redundant call to 'String.format()'
redundant.string.format.call.problem.descriptor:
    text: 'Redundant call to <code>#ref</code> #loc'
redundant.string.format.call.quickfix:
    text: Remove redundant call to 'String.format()'
reflection.for.unavailable.annotation.display.name:
    text: Reflective access to a source-only annotation
reflection.for.unavailable.annotation.problem.descriptor:
    text: 'Annotation ''#ref'' is not retained for reflective access #loc'
refused.bequest.display.name:
    text: Method does not call super method
refused.bequest.ignore.empty.super.methods.option:
    text: Ignore empty super methods
refused.bequest.problem.descriptor:
    text: 'Method <code>#ref()</code> does not call ''super.#ref()'' #loc'
remove.annotation.parameter.0.fix.name:
    text: Remove annotation parameter ''{0}''
remove.finally.block.quickfix:
    text: Remove 'finally' block
remove.junit4.test.annotation.and.rename.quickfix:
    text: Remove ''@Test'' annotation and rename to ''{0}''
remove.junit4.test.annotation.quickfix:
    text: Remove '@Test' annotation
remove.leading.zero.to.make.decimal.quickfix:
    text: Remove leading zero to make decimal
remove.modifier.quickfix:
    text: Remove ''{0}'' modifier
remove.try.catch.quickfix:
    text: Remove 'try catch' statement
remove.try.finally.block.quickfix:
    text: Remove 'try-finally' block
rename.catch.parameter.to.ignored:
    text: Rename 'catch' parameter to 'ignored'
rename.quickfix:
    text: Rename
renameto.quickfix:
    text: Rename to ''{0}''
replace.all.dot.display.name:
    text: Call to String.replaceAll(".", ...)
replace.all.dot.problem.descriptor:
    text: 'Call to <code>String.#ref(".", ...)</code> #loc'
replace.assertequals.quickfix:
    text: Replace with ''{0}''
replace.indexof.with.contains.quickfix:
    text: Replace 'indexOf()' with 'contains()'
replace.inheritance.with.delegation.quickfix:
    text: Replace inheritance with delegation
replace.reference.with.expression.quickfix:
    text: Replace with ''{0}''
replace.with:
    text: Replace with ''{0}''
replace.with.arrays.deep.equals:
    text: Replace with 'Arrays.deepEquals()'
replace.with.arrays.equals:
    text: Replace with 'Arrays.equals()'
replace.with.catch.clause.for.runtime.exception.quickfix:
    text: Replace with 'catch' clause for 'RuntimeException'
resource.opened.not.closed.problem.descriptor:
    text: '''''{0}'''' should be opened in front of a ''''try'''' block and closed in the corresponding ''''finally'''' block #loc'
result.of.method.call.ignored.class.column.title:
    text: Class Name
result.of.method.call.ignored.display.name:
    text: Result of method call ignored
result.of.method.call.ignored.method.column.title:
    text: Method name regex
result.of.method.call.ignored.non.library.option:
    text: Report all ignored non-library calls
result.of.method.call.ignored.problem.descriptor:
    text: 'Result of <code>{0}.#ref()</code> is ignored #loc'
result.of.object.allocation.ignored.display.name:
    text: Result of object allocation ignored
result.of.object.allocation.ignored.problem.descriptor:
    text: 'Result of <code>new #ref()</code> is ignored #loc'
return.date.calendar.field.display.name:
    text: Return of Date or Calendar field
return.date.calendar.field.problem.descriptor:
    text: 'Return of ''''{0}'''' field <code>#ref</code> #loc'
return.date.calendar.field.quickfix:
    text: Return clone of ''{0}''
return.from.finally.block.display.name:
    text: '''return'' inside ''finally'' block'
return.from.finally.block.problem.descriptor:
    text: '<code>#ref</code> inside ''finally'' block #loc'
return.of.anonymous.class.problem.descriptor:
    text: 'Return of instance of anonymous class #loc'
return.of.collection.array.field.display.name:
    text: Return of Collection or array field
return.of.collection.array.field.option:
    text: Ignore 'private' methods returning an array or collection field
return.of.collection.array.field.problem.descriptor.array:
    text: '''return'' of array field <code>#ref</code> #loc'
return.of.collection.array.field.problem.descriptor.collection:
    text: '''return'' of Collection field <code>#ref</code> #loc'
return.of.collection.field.quickfix:
    text: Replace with ''{0}''
return.of.inner.class.display.name:
    text: Return of instance of anonymous, local or inner class
return.of.inner.class.ignore.non.public.option:
    text: Ignore returns from non-public methods
return.of.inner.class.problem.descriptor:
    text: 'Return of instance of non-static inner class <code>{0}</code> #loc'
return.of.local.class.problem.descriptor:
    text: 'Return of instance of local class <code>{0}</code> #loc'
return.of.null.arrays.option:
    text: Report methods that return arrays
return.of.null.collections.option:
    text: Report methods that return collection objects
return.of.null.display.name:
    text: Return of 'null'
return.of.null.ignore.private.option:
    text: Ignore 'private' methods
return.of.null.objects.option:
    text: Report methods that return objects
return.of.null.optional.quickfix:
    text: Replace with ''{0}.{1}()''
return.of.null.optional.quickfix.family:
    text: Replace with 'Optional.empty()'
return.of.null.problem.descriptor:
    text: 'Return of <code>#ref</code> #loc'
return.of.null.quickfix:
    text: Annotate method as @Nullable
return.point.limit.option:
    text: '&Return point limit:'
return.this.display.name:
    text: Return of 'this'
return.this.problem.descriptor:
    text: 'Return of <code>#ref</code> #loc'
reuse.of.local.variable.display.name:
    text: Reuse of local variable
reuse.of.local.variable.problem.descriptor:
    text: 'Reuse of local variable <code>#ref</code> #loc'
reuse.of.local.variable.split.quickfix:
    text: Split local variable
runtime.exec.call.display.name:
    text: Call to 'Runtime.exec()'
runtime.exec.call.problem.descriptor:
    text: 'Call to <code>Runtime.#ref()</code> is non-portable #loc'
runtime.exec.with.non.constant.string.display.name:
    text: Call to 'Runtime.exec()' with non-constant string
runtime.exec.with.non.constant.string.problem.descriptor:
    text: 'Call to <code>Runtime.#ref()</code> with non-constant argument #loc'
safe.lock.display.name:
    text: Lock acquired but not safely unlocked
safe.lock.problem.descriptor:
    text: '''''{0}'''' should be locked in front of a ''''try'''' block and unlocked in the corresponding ''''finally'''' block #loc'
serializable.anonymous.class.stores.non.serializable.problem.descriptor:
    text: Serializable anonymous class implicitly stores non-Serializable object of type ''{0}''
serializable.class.in.secure.context.display.name:
    text: Serializable class in secure context
serializable.class.in.secure.context.problem.descriptor:
    text: 'Class <code>#ref</code> may be serialized, compromising security #loc'
serializable.class.without.serialversionuid.display.name:
    text: Serializable class without 'serialVersionUID'
serializable.class.without.serialversionuid.problem.descriptor:
    text: '<code>#ref</code> does not define a ''serialVersionUID'' field #loc'
serializable.has.serialization.methods.display.name:
    text: Serializable class without 'readObject()' and 'writeObject()'
serializable.has.serialization.methods.ignore.option:
    text: Ignore classes that do not define instance fields
serializable.has.serialization.methods.problem.descriptor:
    text: 'Serializable class <code>#ref</code> does not define ''readObject()'' or ''writeObject()'' #loc'
serializable.has.serialization.methods.problem.descriptor1:
    text: 'Serializable class <code>#ref</code> does not define ''writeObject()'' #loc'
serializable.has.serialization.methods.problem.descriptor2:
    text: 'Serializable class <code>#ref</code> does not define ''readObject()'' #loc'
serializable.inner.class.has.serial.version.uid.field.display.name:
    text: Serializable non-static inner class without 'serialVersionUID'
serializable.inner.class.has.serial.version.uid.field.problem.descriptor:
    text: 'Inner class <code>#ref</code> does not define a ''serialVersionUID'' field #loc'
serializable.inner.class.with.non.serializable.outer.class.display.name:
    text: Serializable non-'static' inner class with non-Serializable outer class
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor:
    text: 'Inner class <code>#ref</code> is serializable while its outer class is not #loc'
serializable.lambda.stores.non.serializable.problem.descriptor:
    text: Serializable lambda implicitly stores non-Serializable object of type ''{0}''
serializable.local.class.stores.non.serializable.problem.descriptor:
    text: Serializable local class ''{1}'' implicitly stores non-Serializable object of type ''{0}''
serializable.stores.non.serializable.display.name:
    text: '''Serializable'' object implicitly stores non-''Serializable'' object'
serializable.with.unconstructable.ancestor.display.name:
    text: Serializable class with unconstructable ancestor
serializable.with.unconstructable.ancestor.problem.descriptor:
    text: '<code>#ref</code> has a non-serializable ancestor ''''{0}'''' without no-arg constructor #loc'
serialpersistentfields.with.wrong.signature.display.name:
    text: '''serialPersistentFields'' field not declared ''private static final ObjectStreamField[]'''
serialpersistentfields.with.wrong.signature.problem.descriptor:
    text: '<code>#ref</code> field of a Serializable class is not declared ''private static final ObjectStreamField[]'' #loc'
serialversionuid.private.static.final.long.display.name:
    text: '''serialVersionUID'' field not declared ''private static final long'''
serialversionuid.private.static.final.long.problem.descriptor:
    text: '<code>#ref</code> field of a Serializable class is not declared ''private static final long'' #loc'
serialversionuid.private.static.final.long.quickfix:
    text: Make serialVersionUID 'private static final'
set.annotation.parameter.0.1.fix.name:
    text: Set annotation parameter {0} = "{1}"
set.replaceable.by.enum.set.display.name:
    text: '''Set'' can be replaced with ''EnumSet'''
set.replaceable.by.enum.set.problem.descriptor:
    text: '<code>#ref</code> can be replaced with ''EnumSet'' #loc'
setup.calls.super.setup.add.quickfix:
    text: Add call to 'super.setUp()'
setup.calls.super.setup.display.name:
    text: '''setUp()'' does not call ''super.setUp()'''
setup.calls.super.setup.problem.descriptor:
    text: '<code>#ref()</code> does not call ''super.setUp()'' #loc'
setup.is.public.void.no.arg.display.name:
    text: '''setUp()'' with incorrect signature'
setup.is.public.void.no.arg.problem.descriptor:
    text: <code>#ref()</code> has incorrect signature
shared.thread.local.random.display.name:
    text: '''ThreadLocalRandom'' instance might be shared'
shared.thread.local.random.problem.descriptor:
    text: '''ThreadLocalRandom'' instance might be shared between threads'
shift.operation.by.inappropriate.constant.display.name:
    text: Shift operation by inappropriate constant
shift.operation.by.inappropriate.constant.problem.descriptor.negative:
    text: 'Shift operation <code>#ref</code> by negative constant value #loc'
shift.operation.by.inappropriate.constant.problem.descriptor.too.large:
    text: 'Shift operation <code>#ref</code> by overly large constant value #loc'
shift.out.of.range.quickfix:
    text: Replace ''{0}'' with ''{1}''
signal.without.corresponding.await.display.name:
    text: '''signal()'' without corresponding ''await()'''
signal.without.corresponding.await.problem.descriptor:
    text: 'Call to <code>#ref()</code> without corresponding <code>await()</code> #loc'
simplifiable.annotation.display.name:
    text: Simplifiable annotation
simplifiable.annotation.problem.descriptor:
    text: 'Annotation <code>#ref</code> may be replaced with ''''{0}'''' #loc'
simplifiable.annotation.quickfix:
    text: Simplify annotation
simplifiable.annotation.whitespace.problem.descriptor:
    text: 'Unnecessary whitespace in annotation #loc'
simplifiable.boolean.expression.display.name:
    text: Simplifiable boolean expression
simplifiable.conditional.expression.display.name:
    text: Simplifiable conditional expression
simplifiable.conditional.expression.problem.descriptor:
    text: '<code>#ref</code> can be simplified to ''''{0}'''' #loc'
simplifiable.equals.expression.display.name:
    text: Unnecessary 'null' check before 'equals()' call
simplifiable.equals.expression.problem.descriptor:
    text: 'Unnecessary ''''null'''' check before ''''{0}()'''' call #loc'
simplifiable.equals.expression.quickfix:
    text: Flip ''.{0}()'' and remove unnecessary ''null'' check
simplifiable.if.statement.display.name:
    text: '''if'' statement may be replaced with \&\& or || expression'
simplifiable.if.statement.problem.descriptor:
    text: '<code>#ref</code> statement can be replaced with ''''{0}'''' #loc'
simplifiable.junit.assertion.display.name:
    text: Simplifiable assertion
simplifiable.junit.assertion.problem.descriptor:
    text: '<code>#ref()</code> can be simplified to ''''{0}'''' #loc'
simplifiable.testng.assertion.display.name:
    text: Simplifiable TestNG assertion
simplify.junit.assertion.simplify.quickfix:
    text: Simplify assertion
single.character.startswith.display.name:
    text: Single character 'startsWith()' or 'endsWith()'
single.character.startswith.problem.descriptor:
    text: 'Single character <code>#ref()</code> can be replaced with ''charAt()'' expression #loc'
single.character.startswith.quickfix:
    text: Replace with 'charAt()'
single.class.import.display.name:
    text: Single class import
single.class.import.problem.descriptor:
    text: 'Single class import <code>#ref</code> #loc'
single.element.annotation.family.quickfix:
    text: Expand annotation to normal form
single.element.annotation.name:
    text: Single-element annotation
single.element.annotation.quickfix:
    text: Add 'value='
single.statement.in.block.descriptor:
    text: '''''{0}'''' contains single statement'
single.statement.in.block.family.quickfix:
    text: Remove braces from statement
single.statement.in.block.name:
    text: Code block contains single statement
single.statement.in.block.quickfix:
    text: Remove braces from ''{0}'' statement
singleton.display.name:
    text: Singleton
singleton.problem.descriptor:
    text: 'Class <code>#ref</code> is a singleton #loc'
size.replaceable.by.isempty.display.name:
    text: '''size() == 0'' can be replaced with ''isEmpty()'''
size.replaceable.by.isempty.negation.ignore.option:
    text: Ignore expressions which would be replaced with '!isEmpty()'
size.replaceable.by.isempty.quickfix:
    text: Replace with 'isEmpty()'
sleep.while.holding.lock.display.name:
    text: Call to 'Thread.sleep()' while synchronized
sleep.while.holding.lock.problem.descriptor:
    text: 'Call to <code>Thread.#ref()</code> while synchronized #loc'
smth.unnecessary.remove.quickfix:
    text: Remove unnecessary ''{0}''
socket.opened.not.closed.display.name:
    text: Socket opened but not safely closed
standard.variable.names.display.name:
    text: Standard variable names
standard.variable.names.ignore.override.option:
    text: Ignore for parameter names identical to super method parameters
standard.variable.names.problem.descriptor:
    text: 'Variable named <code>#ref</code> doesn''''t have type ''''{0}'''' #loc'
standard.variable.names.problem.descriptor2:
    text: 'Variable named <code>#ref</code> doesn''''t have type ''''{0}'''' or ''''{1}'''' #loc'
statement.problem.descriptor:
    text: '<code>#ref</code> statement #loc'
statement.with.empty.body.display.name:
    text: Statement with empty body
statement.with.empty.body.include.option:
    text: Include statement bodies that are empty code blocks
statement.with.empty.body.problem.descriptor:
    text: '<code>#ref</code> statement has empty body #loc'
static.collection.display.name:
    text: Static collection
static.collection.ignore.option:
    text: Ignore weak static collections or maps
static.collection.problem.descriptor:
    text: 'Static collection <code>#ref</code> #loc'
static.field.via.subclass.display.name:
    text: Static field referenced via subclass
static.field.via.subclass.problem.descriptor:
    text: 'Static field <code>#ref</code> declared in class ''''{0}'''' but referenced via subclass ''''{1}'''' #loc'
static.field.via.subclass.rationalize.quickfix:
    text: Rationalize static field access
static.import.display.name:
    text: Static import
static.import.problem.descriptor:
    text: 'Static import <code>#ref</code>  #loc'
static.import.replace.quickfix:
    text: Replace with non-static import
static.inheritance.display.name:
    text: Static inheritance
static.inheritance.problem.descriptor:
    text: 'Interface <code>#ref</code> is implemented only for its static constants #loc'
static.inheritance.replace.quickfix:
    text: Replace inheritance with qualified references in {0}
static.initializer.references.subclass.display.name:
    text: Static initializer references subclass
static.method.naming.convention.display.name:
    text: '''static'' method naming convention'
static.method.naming.convention.element.description:
    text: '''static'' method'
static.method.naming.convention.problem.descriptor.long:
    text: '''static'' method name <code>#ref</code> is too long #loc'
static.method.naming.convention.problem.descriptor.regex.mismatch:
    text: '''static'' method name <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
static.method.naming.convention.problem.descriptor.short:
    text: '''static'' method name <code>#ref</code> is too short #loc'
static.method.only.used.in.one.anonymous.class.problem.descriptor:
    text: 'Static method <code>#ref()</code> is only used from an anonymous class derived from ''''{0}'''' #loc'
static.method.only.used.in.one.class.display.name:
    text: '''static'' method only used from one other class'
static.method.only.used.in.one.class.ignore.anonymous.option:
    text: Ignore when only used from an anonymous class
static.method.only.used.in.one.class.ignore.on.conflicts:
    text: Ignore when the method cannot be moved without conflicts
static.method.only.used.in.one.class.ignore.test.option:
    text: Ignore when only used from a test class
static.method.only.used.in.one.class.problem.descriptor:
    text: '''static'' method <code>#ref()</code> is only used from class ''''{0}'''' #loc'
static.method.only.used.in.one.class.problem.descriptor.anonymous.extending:
    text: '''static'' method <code>#ref()</code> is only used from an anonymous class extending ''''{0}'''' #loc'
static.method.only.used.in.one.class.problem.descriptor.anonymous.implementing:
    text: '''static'' method <code>#ref()</code> is only used from an anonymous class implementing ''''{0}'''' #loc'
static.method.only.used.in.one.class.quickfix:
    text: Move method
static.method.via.subclass.display.name:
    text: Static method referenced via subclass
static.method.via.subclass.problem.descriptor:
    text: 'Static method <code>#ref()</code> declared in class ''''{0}'''' but referenced via subclass ''''{1}'''' #loc'
static.method.via.subclass.rationalize.quickfix:
    text: Rationalize static method call
static.non.final.field.display.name:
    text: '''static'', non-''final'' field'
static.non.final.field.option:
    text: Only report 'public' fields
static.non.final.field.problem.descriptor:
    text: '''static'' non-''final'' field <code>#ref</code> #loc'
static.suite.display.name:
    text: '''suite()'' method not declared ''static'''
static.suite.problem.descriptor:
    text: 'JUnit <code>#ref()</code> methods not declared ''static'' #loc'
static.variable.may.not.be.initialized.display.name:
    text: Static field may not be initialized
static.variable.may.not.be.initialized.problem.descriptor:
    text: 'Static field <code>#ref</code> may not be initialized during class initialization #loc'
static.variable.naming.convention.display.name:
    text: '''static'' field naming convention'
static.variable.naming.convention.element.description:
    text: '''static'' field'
static.variable.naming.convention.mutable.option:
    text: Check 'static final' fields with a mutable type
static.variable.naming.convention.problem.descriptor.long:
    text: '''static'' field name <code>#ref</code> is too long #loc'
static.variable.naming.convention.problem.descriptor.regex.mismatch:
    text: '''static'' field <code>#ref</code> doesn''''t match regex ''''{0}'''' #loc'
static.variable.naming.convention.problem.descriptor.short:
    text: '''static'' field name <code>#ref</code> is too short #loc'
static.variable.of.concrete.class.display.name:
    text: Static field of concrete class
static.variable.of.concrete.class.option:
    text: Ignore static fields whose type is an abstract class
static.variable.of.concrete.class.problem.descriptor:
    text: 'Static field ''''{0}'''' of concrete class <code>#ref</code> #loc'
static.variable.used.before.initialization.display.name:
    text: Static field used before initialization
static.variable.used.before.initialization.problem.descriptor:
    text: 'Static field <code>#ref</code> used before initialization #loc'
string.buffer.must.have.initial.capacity.display.name:
    text: StringBuffer or StringBuilder without initial capacity
string.buffer.must.have.initial.capacity.problem.descriptor:
    text: '<code>new #ref()</code> without initial capacity #loc'
string.buffer.replaceable.by.string.builder.display.name:
    text: '''StringBuffer'' may be ''StringBuilder'''
string.buffer.replaceable.by.string.builder.problem.descriptor:
    text: '<code>StringBuffer #ref</code> may be declared as ''StringBuilder'' #loc'
string.buffer.replaceable.by.string.builder.replace.quickfix:
    text: Replace with 'StringBuilder'
string.buffer.replaceable.by.string.display.name:
    text: '''StringBuffer'' can be replaced with ''String'''
string.buffer.replaceable.by.string.problem.descriptor:
    text: '<code>{0} #ref</code> can be replaced with ''''String'''' #loc'
string.buffer.replaceable.by.string.quickfix:
    text: Replace 'StringBuffer' with 'String'
string.buffer.to.string.in.concatenation.display.name:
    text: '''StringBuffer.toString()'' in concatenation'
string.buffer.to.string.in.concatenation.problem.descriptor:
    text: 'Calls to <code>StringBuffer.#ref()</code> in concatenation #loc'
string.buffer.to.string.in.concatenation.remove.quickfix:
    text: Remove 'toString()'
string.builder.replaceable.by.string.quickfix:
    text: Replace 'StringBuilder' with 'String'
string.compareto.call.display.name:
    text: Call to 'String.compareTo()'
string.compareto.call.problem.descriptor:
    text: '<code>String.#ref()</code> called using internationalized strings #loc'
string.comparison.display.name:
    text: String comparison using '==', instead of 'equals()'
string.comparison.problem.descriptor:
    text: 'String values are compared using <code>#ref</code>, not ''equals()'' #loc'
string.concatenation.argument.to.log.call.display.name:
    text: Non-constant string concatenation as argument to logging call
string.concatenation.argument.to.log.call.problem.descriptor:
    text: 'Non-constant string concatenation as argument to <code>#ref()</code> logging call #loc'
string.concatenation.argument.to.log.call.quickfix:
    text: Replace concatenation with parameterized log message
string.concatenation.display.name:
    text: String concatenation
string.concatenation.ignore.assert.option:
    text: Ignore for assert statement arguments
string.concatenation.ignore.constant.initializers.option:
    text: Ignore for initializers of constants
string.concatenation.ignore.exceptions.option:
    text: Ignore for throwable arguments
string.concatenation.ignore.system.err.option:
    text: Ignore for 'System.err.print' arguments
string.concatenation.ignore.system.out.option:
    text: Ignore for 'System.out.print' arguments
string.concatenation.in.format.call.display.name:
    text: String concatenation as argument to 'format()' call
string.concatenation.in.format.call.plural.quickfix:
    text: Replace concatenation with separate arguments
string.concatenation.in.format.call.problem.descriptor:
    text: '<code>#ref()</code> call has a String concatenation argument #loc'
string.concatenation.in.format.call.quickfix:
    text: Replace concatenation with parameterized log message
string.concatenation.in.loops.display.name:
    text: String concatenation in loop
string.concatenation.in.loops.only.option:
    text: Only warn if string is repeatedly appended
string.concatenation.in.loops.problem.descriptor:
    text: 'String concatenation <code>#ref</code> in loop #loc'
string.concatenation.in.message.format.call.display.name:
    text: String concatenation as argument to 'MessageFormat.format()' call
string.concatenation.in.message.format.call.problem.descriptor:
    text: 'String concatenation as argument to ''MessageFormat.format()'' call #loc'
string.concatenation.inside.string.buffer.append.display.name:
    text: String concatenation as argument to 'StringBuilder.append()' call
string.concatenation.inside.string.buffer.append.problem.descriptor:
    text: 'String concatenation as argument to <code>{0}.#ref()</code> call #loc'
string.concatenation.inside.string.buffer.append.replace.quickfix:
    text: Replace with chained 'append()' calls
string.concatenation.introduce.fix:
    text: Introduce StringBuilder
string.concatenation.introduce.fix.name:
    text: Introduce new {1} to update variable ''{0}''
string.concatenation.missing.whitespace.display.name:
    text: String literal concatenation missing whitespace
string.concatenation.missing.whitespace.option:
    text: Ignore when one or both sides are not literals
string.concatenation.missing.whitespace.problem.descriptor:
    text: 'String literal concatenation missing whitespace #loc'
string.concatenation.problem.descriptor:
    text: 'String concatenation <code>#ref</code> in an internationalized context #loc'
string.concatenation.replace.fix:
    text: Replace with StringBuilder
string.concatenation.replace.fix.name:
    text: Convert variable ''{0}'' from String to {1}
string.constructor.display.name:
    text: Redundant String constructor call
string.constructor.problem.descriptor:
    text: '<code>#ref</code> is redundant #loc'
string.constructor.replace.arg.quickfix:
    text: Replace with arg
string.constructor.replace.empty.quickfix:
    text: Replace with empty string
string.constructor.substring.parameter.option:
    text: Ignore string constructor calls with a 'substring()' call argument
string.equals.call.display.name:
    text: Call to 'String.equals()'
string.equals.call.problem.descriptor:
    text: '<code>String.#ref()</code> using internationalized strings #loc'
string.equals.empty.string.display.name:
    text: '''String.equals("")'''
string.equals.empty.string.is.empty.problem.descriptor:
    text: '<code>#ref("")</code> can be replaced with ''isEmpty()'' #loc'
string.equals.empty.string.isempty.quickfix:
    text: Replace with 'isEmpty()'
string.equals.empty.string.problem.descriptor:
    text: '<code>#ref("")</code> can be replaced with ''length()==0'' #loc'
string.equals.empty.string.quickfix:
    text: Replace with 'length()==0'
string.equalsignorecase.call.display.name:
    text: Call to 'String.equalsIgnoreCase()'
string.equalsignorecase.call.problem.descriptor:
    text: '<code>String.#ref()</code> using internationalized strings #loc'
string.format.choose.class:
    text: Choose Formatter Class
string.format.class.column.name:
    text: Additional formatter classes
string.format.class.method.name:
    text: Additional formatter methods
string.replace.quickfix:
    text: Replace concatenation with ''{0}''
string.replaceable.by.string.buffer.display.name:
    text: Non-constant 'String' can be replaced with 'StringBuilder'
string.replaceable.by.string.buffer.in.loop.option:
    text: Only warn when appending in a loop
string.replaceable.by.string.buffer.problem.descriptor:
    text: 'Non-constant String <code>#ref</code> should probably be declared as ''StringBuilder'' #loc'
string.to.string.display.name:
    text: Redundant 'String.toString()'
string.to.string.problem.descriptor:
    text: '<code>#ref</code> is redundant #loc'
string.touppercase.tolowercase.without.locale.display.name:
    text: Call to 'String.toUpperCase()' or 'toLowerCase()' without locale
string.touppercase.tolowercase.without.locale.problem.descriptor:
    text: '<code>String.#ref()</code> called without specifying a Locale using internationalized strings #loc'
stringbuffer.field.display.name:
    text: '''StringBuilder'' field'
stringbuffer.field.problem.descriptor:
    text: '''''{0}'''' field <code>#ref</code> #loc'
substring.zero.display.name:
    text: Redundant 'substring(0)' call
substring.zero.problem.descriptor:
    text: '<code>#ref</code> is redundant #loc'
subtraction.in.compareto.display.name:
    text: Subtraction in 'compareTo()'
subtraction.in.compareto.problem.descriptor:
    text: 'Subtraction <code>#ref</code> in ''compareTo()'' may result in overflow errors #loc'
super.class.logger.option:
    text: Ignore classes with an accessible logger declared in a superclass
super.tear.down.in.finally.display.name:
    text: '''super.tearDown()'' not called from ''finally'' block'
super.tear.down.in.finally.problem.descriptor:
    text: '<code>#ref()</code> not called from ''finally'' block #loc'
suppress.for.tests.scope.quickfix:
    text: Suppress for 'Tests' scope
suspicious.array.cast.display.name:
    text: Suspicious array cast
suspicious.array.cast.problem.descriptor:
    text: 'Suspicious cast to <code>#ref</code> #loc'
suspicious.comparator.compare.descriptor.non.reflexive:
    text: Comparator does not return 0 for equal elements
suspicious.comparator.compare.descriptor.parameter.not.used:
    text: '''compare()'' parameter <code>#ref</code> is not used #loc'
suspicious.comparator.compare.display.name:
    text: Suspicious 'Comparator.compare()' implementation
suspicious.getter.problem.descriptor:
    text: 'Getter <code>#ref()</code> returns field ''''{0}'''' #loc'
suspicious.getter.setter.display.name:
    text: Suspicious getter/setter
suspicious.indent.after.control.statement.display.name:
    text: Suspicious indentation after control statement without braces
suspicious.indent.after.control.statement.problem.descriptor:
    text: '<code>#ref</code> statement has suspicious indentation #loc'
suspicious.literal.underscore.display.name:
    text: Suspicious underscore in number literal
suspicious.literal.underscore.problem.descriptor:
    text: 'Group in number literal with underscores does not have length 3 #loc'
suspicious.setter.problem.descriptor:
    text: 'Setter <code>#ref()</code> assigns field ''''{0}'''' #loc'
suspicious.system.arraycopy.display.name:
    text: Suspicious 'System.arraycopy()' call
suspicious.system.arraycopy.problem.descriptor1:
    text: 'Parameter ''srcPos'' may not be negative #loc'
suspicious.system.arraycopy.problem.descriptor2:
    text: 'Parameter ''destPos'' may not be negative #loc'
suspicious.system.arraycopy.problem.descriptor3:
    text: 'Parameter ''length'' may not be negative #loc'
suspicious.system.arraycopy.problem.descriptor4:
    text: '<code>#ref</code> is not of an array type #loc'
suspicious.system.arraycopy.problem.descriptor5:
    text: '<code>#ref</code> is not of an array type #loc'
suspicious.system.arraycopy.problem.descriptor6:
    text: 'Source parameter type ''''{0}'''' is not assignable to destination parameter <code>#ref</code> of type ''''{1}'''' #loc'
suspicious.to.array.call.display.name:
    text: Suspicious 'Collection.toArray()' call
suspicious.to.array.call.problem.descriptor:
    text: 'Array of type ''''{0}[]'''' expected #loc'
switch.expression.with.single.default.message:
    text: '''switch'' expression has only ''default'' case'
switch.expression.with.too.few.branches.problem.descriptor:
    text: '''''switch'''' expression has too few case labels ({0}), and should probably be replaced with an ''''if'''' statement or conditional operator #loc'
switch.statement.density.display.name:
    text: '''switch'' statement with too low of a branch density'
switch.statement.density.min.option:
    text: 'Minimum density of branches: %'
switch.statement.density.problem.descriptor:
    text: '<code>#ref</code> branch density is too low ({0}%) #loc'
switch.statement.display.name:
    text: '''switch'' statement'
switch.statement.with.confusing.declaration.display.name:
    text: Local variable used and declared in different 'switch' branches
switch.statement.with.confusing.declaration.problem.descriptor:
    text: 'Local variable <code>#ref</code> declared in one ''switch'' branch and used in another #loc'
switch.statement.with.single.default.message:
    text: '''switch'' statement has only ''default'' case'
switch.statement.with.too.few.branches.display.name:
    text: '''switch'' statement with too few branches'
switch.statement.with.too.few.branches.min.option:
    text: 'Minimum number of branches:'
switch.statement.with.too.few.branches.problem.descriptor:
    text: '<code>#ref</code> has too few branches ({0}), and should probably be replaced with an ''''if'''' statement #loc'
switch.statement.with.too.many.branches.display.name:
    text: '''switch'' statement with too many branches'
switch.statement.without.default.ignore.option:
    text: Ignore if all cases of an enumerated type are covered
switch.statements.without.default.display.name:
    text: '''switch'' statement without ''default'' branch'
switch.statements.without.default.problem.descriptor:
    text: '<code>#ref</code> statement without ''default'' branch #loc'
synchronization.on.get.class.display.name:
    text: Synchronization on 'getClass()'
synchronization.on.get.class.problem.descriptor:
    text: 'Synchronization on <code>#ref()</code> #loc'
synchronization.on.local.variable.or.method.parameter.display.name:
    text: Synchronization on local variable or method parameter
synchronization.on.local.variable.problem.descriptor:
    text: 'Synchronization on local variable <code>#ref</code> #loc'
synchronization.on.method.parameter.problem.descriptor:
    text: 'Synchronization on method parameter <code>#ref</code> #loc'
synchronization.on.static.field.display.name:
    text: Synchronization on 'static' field
synchronization.on.static.field.problem.descriptor:
    text: 'Synchronization on ''static'' field <code>#ref</code> #loc'
synchronize.on.class.problem.descriptor:
    text: 'Lock operations on a class may have unforeseen side-effects #loc'
synchronize.on.lock.display.name:
    text: Synchronization on a 'Lock' object
synchronize.on.lock.problem.descriptor:
    text: 'Synchronization on a ''''{0}'''' object is unlikely to be intentional #loc'
synchronize.on.non.final.field.display.name:
    text: Synchronization on a non-final field
synchronize.on.non.final.field.problem.descriptor:
    text: 'Synchronization on a non-final field <code>#ref</code> #loc'
synchronize.on.this.display.name:
    text: Synchronization on 'this'
synchronize.on.this.problem.descriptor:
    text: 'Lock operations on ''this'' may have unforeseen side-effects #loc'
synchronized.method.display.name:
    text: '''synchronized'' method'
synchronized.method.ignore.synchronized.super.option:
    text: Ignore methods overriding a synchronized method
synchronized.method.include.option:
    text: Include native methods
synchronized.method.move.quickfix:
    text: Move synchronization into method
synchronized.method.problem.descriptor:
    text: 'Method ''''{0}()'''' declared <code>#ref</code> #loc'
synchronized.on.direct.literal.object.problem.descriptor:
    text: 'Synchronization on {0} literal <code>#ref</code> #loc'
synchronized.on.literal.object.name:
    text: Synchronization on an object initialized with a literal
synchronized.on.literal.object.problem.descriptor:
    text: 'Synchronization on {0} <code>#ref</code> which is initialized by a literal #loc'
synchronized.on.literal.object.warn.on.all.option:
    text: Warn on all possible literals
synchronized.on.possibly.literal.object.problem.descriptor:
    text: 'Synchronization on {0} <code>#ref</code> #loc'
system.exit.call.display.name:
    text: Call to 'System.exit()' or related methods
system.exit.call.ignore.option:
    text: Ignore in main method
system.exit.call.problem.descriptor:
    text: 'Call to <code>{0}.#ref()</code> is non-portable #loc'
system.getenv.call.display.name:
    text: Call to 'System.getenv()'
system.getenv.call.problem.descriptor:
    text: 'Call to <code>System.#ref()</code> is non-portable #loc'
system.properties.display.name:
    text: Access of system properties
system.properties.problem.descriptor:
    text: 'Call to <code>Integer.#ref()</code> may pose security concerns #loc'
system.properties.problem.descriptor1:
    text: 'Call to <code>Boolean.#ref()</code> may pose security concerns #loc'
system.run.finalizers.on.exit.display.name:
    text: Call to 'System.runFinalizersOnExit()'
system.run.finalizers.on.exit.problem.descriptor:
    text: 'Call to <code>System.#ref()</code> #loc'
system.set.problem.descriptor:
    text: 'Call to <code>System.#ref()</code> may pose security concerns #loc'
system.set.security.manager.display.name:
    text: Call to 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor:
    text: 'Call to <code>System.#ref()</code> may pose security concerns #loc'
tail.recursion.display.name:
    text: Tail recursion
tail.recursion.problem.descriptor:
    text: 'Tail recursive call <code>#ref()</code> #loc'
tail.recursion.replace.quickfix:
    text: Replace tail recursion with iteration
teardown.calls.super.teardown.display.name:
    text: '''tearDown()'' does not call ''super.tearDown()'''
teardown.calls.super.teardown.problem.descriptor:
    text: '<code>#ref()</code> does not call ''super.tearDown()'' #loc'
teardown.is.public.void.no.arg.display.name:
    text: '''tearDown()'' with incorrect signature'
teardown.is.public.void.no.arg.problem.descriptor:
    text: '<code>#ref()</code> has incorrect signature #loc'
test.case.in.product.code.display.name:
    text: JUnit TestCase in product source
test.case.in.product.code.problem.descriptor:
    text: 'Test case <code>#ref</code> should probably be placed in a test source tree #loc'
test.case.with.constructor.display.name:
    text: JUnit TestCase with non-trivial constructors
test.case.with.constructor.problem.descriptor:
    text: 'Initialization logic in constructor <code>#ref()</code> instead of ''setUp()'' #loc'
test.case.with.constructor.problem.descriptor.initializer:
    text: Initialization logic in initializer instead of 'setUp()'
test.case.with.no.test.methods.display.name:
    text: JUnit test case with no tests
test.case.with.no.test.methods.option:
    text: Ignore test cases which have superclasses with test methods
test.case.with.no.test.methods.problem.descriptor:
    text: 'JUnit test case <code>#ref</code> has no tests #loc'
test.method.in.product.code.display.name:
    text: JUnit test method in product source
test.method.in.product.code.problem.descriptor:
    text: 'Test method <code>#ref()</code> should probably be placed in a test source tree #loc'
test.method.is.public.void.no.arg.display.name:
    text: Malformed test method
test.method.is.public.void.no.arg.problem.descriptor1:
    text: 'Test method <code>#ref()</code> should probably not have parameters #loc'
test.method.is.public.void.no.arg.problem.descriptor2:
    text: 'Test method <code>#ref()</code> is not declared ''public void'' #loc'
test.method.is.public.void.no.arg.problem.descriptor3:
    text: 'Test method <code>#ref()</code> should not be ''static'' #loc'
test.method.without.assertion.display.name:
    text: JUnit test method without any assertions
test.method.without.assertion.problem.descriptor:
    text: 'JUnit test method <code>#ref()</code> contains no assertions #loc'
text.label.in.switch.statement.display.name:
    text: Text label in 'switch' statement
text.label.in.switch.statement.problem.descriptor:
    text: 'Text label <code>#ref:</code> in ''switch'' statement #loc'
the.whole.project:
    text: the whole project
this.class:
    text: this class
this.reference.escaped.in.construction.display.name:
    text: '''this'' reference escaped in object construction'
this.reference.escaped.in.construction.problem.descriptor:
    text: 'Escape of <code>#ref</code> during object construction #loc'
thread.death.rethrown.display.name:
    text: '''ThreadDeath'' not rethrown'
thread.death.rethrown.problem.descriptor:
    text: 'ThreadDeath <code>#ref</code> not rethrown #loc'
thread.local.not.static.final.display.name:
    text: '''ThreadLocal'' field not declared ''static final'''
thread.local.not.static.final.problem.descriptor:
    text: 'ThreadLocal <code>#ref</code> is not declared ''static final'' #loc'
thread.priority.display.name:
    text: Call to 'Thread.setPriority()'
thread.priority.problem.descriptor:
    text: 'Call to <code>Thread.#ref()</code> #loc'
thread.run.display.name:
    text: Call to 'Thread.run()'
thread.run.problem.descriptor:
    text: 'Calls to <code>#ref()</code> should probably be replaced with ''start()'' #loc'
thread.run.replace.quickfix:
    text: Replace with 'start()'
thread.start.in.construction.display.name:
    text: Call to 'Thread.start()' during object construction
thread.start.in.construction.problem.descriptor:
    text: 'Call to <code>#ref()</code> during object construction #loc'
thread.stop.suspend.resume.display.name:
    text: Call to 'Thread.stop()', 'suspend()' or 'resume()'
thread.stop.suspend.resume.problem.descriptor:
    text: 'Call to <code>Thread.#ref()</code> #loc'
thread.with.default.run.method.display.name:
    text: Instantiating a 'Thread' with default 'run()' method
thread.with.default.run.method.problem.descriptor:
    text: 'Instantiating a <code>#ref</code> with default ''run()'' method #loc'
thread.yield.display.name:
    text: Call to 'Thread.yield()'
thread.yield.problem.descriptor:
    text: 'Call to <code>Thread.#ref()</code> #loc'
three.negations.per.method.display.name:
    text: Method with more than three negations
three.negations.per.method.ignore.assert.option:
    text: Ignore negations in 'assert' statements
three.negations.per.method.ignore.option:
    text: Ignore negations in 'equals()' methods
three.negations.per.method.problem.descriptor:
    text: '<code>#ref</code> contains {0} negations #loc'
throw.caught.locally.display.name:
    text: '''throw'' caught by containing ''try'' statement'
throw.caught.locally.ignore.option:
    text: Ignore rethrown exceptions
throw.caught.locally.problem.descriptor:
    text: '<code>#ref</code> caught by containing ''try'' statement #loc'
throw.from.finally.block.display.name:
    text: '''throw'' inside ''finally'' block'
throw.from.finally.block.everywhere.option:
    text: Warn everywhere declared exceptions may be thrown
throw.from.finally.block.problem.descriptor:
    text: '<code>#ref</code> inside ''finally'' block #loc'
throwable.instance.never.thrown.checked.exception.problem.descriptor:
    text: 'Checked exception instance <code>#ref</code> is not thrown #loc'
throwable.instance.never.thrown.display.name:
    text: Throwable instance not thrown
throwable.instance.never.thrown.error.problem.descriptor:
    text: 'Error instance <code>#ref</code> is not thrown #loc'
throwable.instance.never.thrown.problem.descriptor:
    text: 'Throwable instance <code>#ref</code> is not thrown #loc'
throwable.instance.never.thrown.runtime.exception.problem.descriptor:
    text: 'Runtime exception instance <code>new #ref()</code> is not thrown #loc'
throwable.not.thrown.display.name:
    text: '''Throwable'' not thrown'
throwable.printed.to.system.out.display.name:
    text: '''Throwable'' printed to ''System.out'''
throwable.printed.to.system.out.problem.descriptor:
    text: '''Throwable'' argument <code>#ref</code> to ''''System.{0}.{1}()'''' call'
throwable.result.of.method.call.ignored.display.name:
    text: Throwable result of method call ignored
throwable.result.of.method.call.ignored.problem.descriptor:
    text: 'Result of <code>#ref()</code> not thrown #loc'
thrown.exceptions.per.method.display.name:
    text: Method with too many exceptions declared
thrown.exceptions.per.method.limit.option:
    text: 'Exceptions thrown limit:'
thrown.exceptions.per.method.problem.descriptor:
    text: '<code>#ref</code> has too many exceptions declared (num exceptions = {0}) #loc'
throws.runtime.exception.display.name:
    text: Unchecked exception declared in 'throws' clause
throws.runtime.exception.move.quickfix:
    text: Move ''{0}'' to Javadoc ''@throws'' tag
throws.runtime.exception.problem.descriptor:
    text: 'Unchecked exception <code>#ref</code> declared in ''throws'' clause #loc'
throws.runtime.exception.quickfix:
    text: Remove ''{0}'' from ''throws'' clause
time.tostring.call.display.name:
    text: Call to 'Time.toString()'
time.tostring.call.problem.descriptor:
    text: '<code>Time.#ref()</code> in an internationalized context #loc'
to.array.call.with.zero.length.array.argument.display.name:
    text: Call to 'Collection.toArray()' with zero-length array argument
to.array.call.with.zero.length.array.argument.problem.descriptor:
    text: 'Call to <code>#ref()</code> with zero-length array argument ''''{0}'''' #loc'
to.array.call.with.zero.length.array.argument.quickfix:
    text: Replace argument with correctly sized array
todo.comment.display.name:
    text: TODO comment
todo.comment.problem.descriptor:
    text: 'TODO comment <code>#ref</code> #loc'
too.broad.catch.display.name:
    text: Overly broad 'catch' block
too.broad.catch.option:
    text: '&Only warn on RuntimeException, Exception, Error or Throwable'
too.broad.catch.problem.descriptor:
    text: '''''catch'''' of <code>#ref</code> is too broad, masking exception ''''{0}'''' #loc'
too.broad.catch.problem.descriptor1:
    text: '''''catch'''' of <code>#ref</code> is too broad, masking exceptions ''''{0}'''' and ''''{1}'''' #loc'
too.broad.catch.quickfix:
    text: Add ''catch'' clause for ''{0}''
too.broad.scope.allow.option:
    text: '<html>Report variables with a new expression as initializer<br>(potentially unsafe: quick fix may modify semantics if the constructor has non-local side-effects)</html>'
too.broad.scope.display.name:
    text: Scope of variable is too broad
too.broad.scope.narrow.quickfix:
    text: Move declaration of ''{0}'' closer to usages
too.broad.scope.only.blocks.option:
    text: Only report variables that can be moved into inner blocks
too.broad.scope.problem.descriptor:
    text: 'Scope of variable <code>#ref</code> is too broad #loc'
too.many.constructors.count.limit.option:
    text: 'Constructor count limit:'
too.many.constructors.display.name:
    text: Class with too many constructors
too.many.constructors.ignore.deprecated.option:
    text: Ignore deprecated constructors
too.many.constructors.problem.descriptor:
    text: '<code>#ref</code> has too many constructors (constructor count = {0}) #loc'
too.many.fields.count.limit.option:
    text: 'Field count limit:'
too.many.fields.display.name:
    text: Class with too many fields
too.many.fields.problem.descriptor:
    text: '<code>#ref</code> has too many fields (field count = {0}) #loc'
too.many.methods.display.name:
    text: Class with too many methods
too.many.methods.problem.descriptor:
    text: '<code>#ref</code> has too many methods (method count = {0}) #loc'
trace.level.option:
    text: trace level
transient.field.in.non.serializable.class.display.name:
    text: Transient field in non-serializable class
transient.field.in.non.serializable.class.problem.descriptor:
    text: 'Field ''''{0}'''' is marked <code>#ref</code>, in non-Serializable class #loc'
transient.field.in.non.serializable.class.remove.quickfix:
    text: Remove 'transient'
transient.field.not.initialized.display.name:
    text: Transient field is not initialized on deserialization
transient.field.not.initialized.problem.descriptor:
    text: 'Transient field <code>#ref</code> not initialized on deserialization #loc'
trivial.if.display.name:
    text: Redundant 'if' statement
trivial.if.problem.descriptor:
    text: '<code>#ref</code> statement can be simplified #loc'
trivial.string.concatenation.display.name:
    text: Concatenation with empty string
trivial.string.concatenation.problem.descriptor:
    text: Empty string in concatenation
try.finally.can.be.try.with.resources.display.name:
    text: '''try finally'' can be replaced with ''try'' with resources'
try.finally.can.be.try.with.resources.problem.descriptor:
    text: '<code>#ref</code> can use automatic resource management #loc'
try.finally.can.be.try.with.resources.quickfix:
    text: Replace with 'try' with resources
try.statement.with.multiple.resources.name:
    text: '''try'' statement with multiple resources can be split'
try.statement.with.multiple.resources.quickfix:
    text: Split 'try' statement with multiple resources
try.with.identical.catches.display.name:
    text: Identical 'catch' branches in 'try' statement
try.with.identical.catches.problem.descriptor:
    text: '''''catch'''' branch identical to ''''{0}'''' branch #loc'
try.with.identical.catches.quickfix:
    text: Collapse 'catch' blocks
type.may.be.weakened.collection.method.option:
    text: Use &parameterized type of collection for method call arguments
type.may.be.weakened.display.name:
    text: Type may be weakened
type.may.be.weakened.do.not.weaken.to.object.option:
    text: Do not &weaken to 'java.lang.Object'
type.may.be.weakened.field.problem.descriptor:
    text: 'Type of field <code>#ref</code> may be weakened to {0} #loc'
type.may.be.weakened.ignore.option:
    text: Use &righthand type as weakest type in assignments
type.may.be.weakened.method.problem.descriptor:
    text: 'Return type of method <code>#ref()</code> may be weakened to {0} #loc'
type.may.be.weakened.parameter.problem.descriptor:
    text: 'Type of parameter <code>#ref</code> may be weakened to {0} #loc'
type.may.be.weakened.problem.descriptor:
    text: 'Type of variable <code>#ref</code> may be weakened to {0} #loc'
type.may.be.weakened.quickfix:
    text: Weaken type to ''{0}''
type.parameter.extends.final.class.display.name:
    text: Type parameter extends 'final' class
type.parameter.extends.final.class.problem.descriptor1:
    text: 'Type parameter <code>#ref</code> extends ''''final'''' class ''''{0}'''' #loc'
type.parameter.extends.final.class.problem.descriptor2:
    text: 'Wildcard type argument <code>#ref</code> extends ''''final'''' class ''''{0}'''' #loc'
type.parameter.extends.final.class.quickfix:
    text: Replace type parameter with actual class
type.parameter.extends.object.display.name:
    text: Type parameter explicitly extends 'Object'
type.parameter.extends.object.problem.descriptor1:
    text: 'Type parameter <code>#ref</code> explicitly extends ''java.lang.Object'' #loc'
type.parameter.extends.object.problem.descriptor2:
    text: 'Wildcard type argument <code>#ref</code> explicitly extends ''java.lang.Object'' #loc'
type.parameter.hides.type.parameter.problem.descriptor:
    text: 'Type parameter <code>#ref</code> hides type parameter ''''{0}'''' #loc'
type.parameter.hides.visible.type.display.name:
    text: Type parameter hides visible type
type.parameter.hides.visible.type.problem.descriptor:
    text: 'Type parameter <code>#ref</code> hides visible type ''''{0}'''' #loc'
type.parameter.naming.convention.display.name:
    text: Type parameter naming convention
type.parameter.naming.convention.element.description:
    text: Type parameter
type.parameter.naming.convention.problem.descriptor.long:
    text: 'Type parameter name <code>#ref</code> is too long #loc'
type.parameter.naming.convention.problem.descriptor.short:
    text: 'Type parameter name <code>#ref</code> is too short #loc'
unary.plus.display.name:
    text: Unary plus
unary.plus.problem.descriptor:
    text: 'Unary <code>#ref</code> operator #loc'
unary.plus.quickfix:
    text: Remove unary '+'
unchecked.exception.class.display.name:
    text: Unchecked 'Exception' class
unchecked.exception.class.problem.descriptor:
    text: 'Unchecked exception class <code>#ref</code> #loc'
unclear.binary.expression.display.name:
    text: Unclear expression
unclear.binary.expression.problem.descriptor:
    text: 'Expression could use clarifying parentheses #loc'
unclear.binary.expression.quickfix:
    text: Add clarifying parentheses
unconditional.wait.display.name:
    text: Unconditional 'wait()' call
unconditional.wait.problem.descriptor:
    text: 'Unconditional call to <code>#ref()</code> #loc'
unconstructable.test.case.display.name:
    text: Unconstructable JUnit TestCase
unconstructable.test.case.problem.descriptor:
    text: 'Test case <code>#ref</code> is not constructable by most test runners #loc'
unnecessarily.qualified.inner.class.access.display.name:
    text: Unnecessarily qualified inner class access
unnecessarily.qualified.inner.class.access.option:
    text: Ignore references for which an import is needed
unnecessarily.qualified.inner.class.access.problem.descriptor:
    text: '''''{0}'''' is unnecessarily qualified with <code>#ref</code> #loc'
unnecessarily.qualified.inner.class.access.quickfix:
    text: Remove qualifier
unnecessarily.qualified.static.usage.display.name:
    text: Unnecessarily qualified static access
unnecessarily.qualified.static.usage.ignore.field.option:
    text: Ignore unnecessarily qualified field accesses
unnecessarily.qualified.static.usage.ignore.method.option:
    text: Ignore unnecessarily qualified method calls
unnecessarily.qualified.static.usage.problem.descriptor:
    text: 'Unnecessarily qualified call to static method <code>{0}()</code> #loc'
unnecessarily.qualified.static.usage.problem.descriptor1:
    text: 'Unnecessarily qualified access to static field <code>{0}</code> #loc'
unnecessarily.qualified.statically.imported.element.display.name:
    text: Unnecessarily qualified statically imported element
unnecessarily.qualified.statically.imported.element.problem.descriptor:
    text: 'Statically imported element ''''{0}'''' is unnecessarily qualified with <code>#ref</code> #loc'
unnecessarily.qualified.statically.imported.element.quickfix:
    text: Remove unnecessary qualifier
unnecessary.block.statement.problem.descriptor:
    text: 'Braces around this statement are unnecessary #loc'
unnecessary.boxing.display.name:
    text: Unnecessary boxing
unnecessary.boxing.problem.descriptor:
    text: 'Unnecessary boxing <code>#ref</code> #loc'
unnecessary.boxing.remove.quickfix:
    text: Remove boxing
unnecessary.boxing.superfluous.option:
    text: Only report truly superfluously boxed expressions
unnecessary.break.display.name:
    text: Unnecessary 'break' statement
unnecessary.break.problem.descriptor:
    text: '<code>#ref</code> statement is unnecessary #loc'
unnecessary.call.to.string.valueof.display.name:
    text: Unnecessary call to 'String.valueOf()'
unnecessary.call.to.string.valueof.problem.descriptor:
    text: '<code>#ref</code> can be simplified to ''''{0}'''' #loc'
unnecessary.call.to.string.valueof.quickfix:
    text: Replace with ''{0}''
unnecessary.code.block.display.name:
    text: Unnecessary code block
unnecessary.code.block.unwrap.quickfix:
    text: Unwrap block
unnecessary.conditional.expression.display.name:
    text: Redundant conditional expression
unnecessary.constant.array.creation.expression.display.name:
    text: Redundant 'new' expression in constant array creation
unnecessary.constant.array.creation.expression.family.quickfix:
    text: Replace with array initializer expression
unnecessary.constant.array.creation.expression.problem.descriptor:
    text: '<code>#ref</code> can be replaced with array initializer expression #loc'
unnecessary.constant.array.creation.expression.quickfix:
    text: Replace with array initializer expression
unnecessary.constructor.annotation.option:
    text: Ignore constructors with an annotation
unnecessary.constructor.display.name:
    text: Redundant no-arg constructor
unnecessary.constructor.problem.descriptor:
    text: 'No-arg constructor <code>#ref()</code> is redundant #loc'
unnecessary.constructor.remove.quickfix:
    text: Remove redundant constructor
unnecessary.continue.display.name:
    text: Unnecessary 'continue' statement
unnecessary.continue.problem.descriptor:
    text: '<code>#ref</code> is unnecessary as the last statement in a loop #loc'
unnecessary.default.display.name:
    text: Unnecessary 'default' for enum 'switch' statement
unnecessary.default.problem.descriptor:
    text: '<code>#ref</code> branch is unnecessary #loc'
unnecessary.enum.modifier.display.name:
    text: Unnecessary enum modifier
unnecessary.enum.modifier.problem.descriptor:
    text: 'Modifier <code>#ref</code> is redundant for enum constructors #loc'
unnecessary.enum.modifier.problem.descriptor1:
    text: 'Modifier <code>#ref</code> is redundant for inner enums #loc'
unnecessary.explicit.numeric.cast.display.name:
    text: Unnecessary explicit numeric cast
unnecessary.explicit.numeric.cast.problem.descriptor:
    text: '''''{0}'''' unnecessarily cast to <code>#ref</code> #loc'
unnecessary.explicit.numeric.cast.quickfix:
    text: Remove cast
unnecessary.final.on.local.variable.or.parameter.display.name:
    text: Unnecessary 'final' on local variable or parameter
unnecessary.final.on.local.variable.problem.descriptor:
    text: 'Unnecessary <code>#ref</code> on variable ''''{0}'''' #loc'
unnecessary.final.on.parameter.only.interface.option:
    text: Only warn on abstract or interface methods
unnecessary.final.on.parameter.problem.descriptor:
    text: 'Unnecessary <code>#ref</code> on parameter ''''{0}'''' #loc'
unnecessary.final.report.local.variables.option:
    text: Report local variables
unnecessary.final.report.parameters.option:
    text: Report parameters
unnecessary.fully.qualified.name.display.name:
    text: Unnecessary fully qualified name
unnecessary.fully.qualified.name.ignore.option:
    text: Ignore fully qualified names in javadoc
unnecessary.fully.qualified.name.problem.descriptor1:
    text: 'Qualifier <code>#ref</code> is unnecessary, and can be replaced with an import #loc'
unnecessary.fully.qualified.name.problem.descriptor2:
    text: 'Qualifier <code>#ref</code> is unnecessary and can be removed #loc'
unnecessary.fully.qualified.name.remove.quickfix:
    text: Remove unnecessary qualification
unnecessary.fully.qualified.name.replace.quickfix:
    text: Replace qualified name with import
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message:
    text: '{0} fully qualified {0, choice, 1#name|2#names} replaced with import (press Escape to remove highlighting)'
unnecessary.inherit.doc.class.invalid.problem.descriptor:
    text: '<code>#ref</code> is not valid on classes #loc'
unnecessary.inherit.doc.constructor.invalid.problem.descriptor:
    text: '<code>#ref</code> is not valid on constructors #loc'
unnecessary.inherit.doc.constructor.no.super.problem.descriptor:
    text: 'No super method found to inherit Javadoc from #loc'
unnecessary.inherit.doc.display.name:
    text: Unnecessary '{@inheritDoc}' Javadoc comment
unnecessary.inherit.doc.field.invalid.problem.descriptor:
    text: '<code>#ref</code> is not valid on fields #loc'
unnecessary.inherit.doc.module.invalid.problem.descriptor:
    text: '<code>#ref</code> is not valid on module declarations #loc'
unnecessary.inherit.doc.problem.descriptor:
    text: 'Javadoc comment containing only <code>#ref</code> is unnecessary #loc'
unnecessary.inherit.doc.quickfix:
    text: Remove unnecessary '{@inheritDoc}'
unnecessary.initcause.display.name:
    text: Unnecessary call to 'Throwable.initCause()'
unnecessary.initcause.problem.descriptor:
    text: Unnecessary <code>Throwable.#ref()</code> call
unnecessary.initcause.quickfix:
    text: Remove 'Throwable.initCause()' call
unnecessary.interface.modifier.display.name:
    text: Unnecessary interface modifier
unnecessary.interface.modifier.inner.interface.of.interface.problem.descriptor:
    text: 'Modifier <code>#ref</code> is redundant for inner interfaces #loc'
unnecessary.interface.modifier.problem.descriptor:
    text: 'Modifier <code>#ref</code> is redundant for interfaces #loc'
unnecessary.interface.modifier.problem.descriptor2:
    text: 'Modifier <code>#ref</code> is redundant for interface methods #loc'
unnecessary.interface.modifier.problem.descriptor3:
    text: 'Modifier <code>#ref</code> is redundant for inner classes of interfaces #loc'
unnecessary.interface.modifier.problem.descriptor4:
    text: 'Modifier <code>#ref</code> is redundant for interface fields #loc'
unnecessary.javadoc.link.display.name:
    text: Unnecessary Javadoc link
unnecessary.javadoc.link.option:
    text: Ignore inline links to super methods
unnecessary.javadoc.link.quickfix:
    text: Remove unnecessary ''{0}''
unnecessary.javadoc.link.super.method.problem.descriptor:
    text: '<code>#ref</code> pointing to super method is unnecessary #loc'
unnecessary.javadoc.link.this.class.problem.descriptor:
    text: '<code>#ref</code> pointing to containing class is unnecessary #loc'
unnecessary.javadoc.link.this.method.problem.descriptor:
    text: '<code>#ref</code> pointing to this method is unnecessary #loc'
unnecessary.label.on.break.statement.display.name:
    text: Unnecessary label on 'break' statement
unnecessary.label.on.break.statement.problem.descriptor:
    text: 'Unnecessary label on <code>#ref</code> statement #loc'
unnecessary.label.on.continue.statement.display.name:
    text: Unnecessary label on 'continue' statement
unnecessary.label.on.continue.statement.problem.descriptor:
    text: 'Unnecessary label on <code>#ref</code> statement #loc'
unnecessary.label.remove.quickfix:
    text: Remove label
unnecessary.local.variable.problem.descriptor:
    text: 'Local variable <code>#ref</code> is redundant #loc'
unnecessary.parentheses.conditional.option:
    text: Ignore parentheses around the condition of conditional expressions
unnecessary.parentheses.display.name:
    text: Unnecessary parentheses
unnecessary.parentheses.option:
    text: Ignore clarifying parentheses
unnecessary.parentheses.problem.descriptor:
    text: 'Parentheses around <code>#ref</code> are unnecessary #loc'
unnecessary.parentheses.remove.quickfix:
    text: Remove unnecessary parentheses
unnecessary.qualifier.for.super.problem.descriptor:
    text: 'Qualifier <code>#ref</code> on ''super'' is unnecessary in this context #loc'
unnecessary.qualifier.for.this.display.name:
    text: Unnecessary qualifier for 'this' or 'super'
unnecessary.qualifier.for.this.problem.descriptor:
    text: 'Qualifier <code>#ref</code> on ''this'' is unnecessary in this context #loc'
unnecessary.qualifier.for.this.remove.quickfix:
    text: Remove unnecessary qualifier
unnecessary.return.constructor.problem.descriptor:
    text: '<code>#ref</code> is unnecessary as the last statement in a constructor #loc'
unnecessary.return.display.name:
    text: Unnecessary 'return' statement
unnecessary.return.option:
    text: Ignore in then branch of 'if' statement with 'else' branch
unnecessary.return.problem.descriptor:
    text: '<code>#ref</code> is unnecessary as the last statement in a ''void'' method #loc'
unnecessary.semicolon.display.name:
    text: Unnecessary semicolon
unnecessary.semicolon.problem.descriptor:
    text: 'Unnecessary semicolon <code>#ref</code> #loc'
unnecessary.semicolon.remove.quickfix:
    text: Remove unnecessary semicolon
unnecessary.super.constructor.display.name:
    text: Unnecessary call to 'super()'
unnecessary.super.constructor.problem.descriptor:
    text: '<code>#ref</code> is unnecessary #loc'
unnecessary.super.constructor.remove.quickfix:
    text: Remove unnecessary 'super()'
unnecessary.super.qualifier.display.name:
    text: Unnecessary 'super' qualifier
unnecessary.super.qualifier.problem.descriptor:
    text: 'Qualifier <code>#ref</code> is unnecessary in this context #loc'
unnecessary.super.qualifier.quickfix:
    text: Remove unnecessary 'super' qualifier
unnecessary.temporary.on.conversion.from.string.display.name:
    text: Unnecessary temporary object in conversion from 'String'
unnecessary.temporary.on.conversion.from.string.fix.name:
    text: Replace with ''{0}''
unnecessary.temporary.on.conversion.from.string.problem.descriptor:
    text: '<code>#ref</code> #loc can be simplified to ''''{0}'''''
unnecessary.temporary.on.conversion.to.string.display.name:
    text: Unnecessary temporary object in conversion to 'String'
unnecessary.this.display.name:
    text: Unnecessary 'this' qualifier
unnecessary.this.ignore.assignments.option:
    text: Ignore field assignments
unnecessary.this.problem.descriptor:
    text: '<code>#ref</code> is unnecessary in this context #loc'
unnecessary.this.remove.quickfix:
    text: Remove unnecessary 'this' qualifier
unnecessary.tostring.call.display.name:
    text: Unnecessary call to 'toString()'
unnecessary.tostring.call.problem.descriptor:
    text: 'Unnecessary <code>#ref()</code> call #loc'
unnecessary.unary.minus.display.name:
    text: Unnecessary unary minus
unnecessary.unary.minus.problem.descriptor:
    text: 'Unnecessary unary minus #loc'
unnecessary.unary.minus.quickfix:
    text: Remove unary minus and invert parent operation sign
unnecessary.unboxing.display.name:
    text: Unnecessary unboxing
unnecessary.unboxing.problem.descriptor:
    text: 'Unnecessary unboxing <code>#ref</code> #loc'
unnecessary.unboxing.remove.quickfix:
    text: Remove unboxing
unnecessary.unboxing.superfluous.option:
    text: Only report truly superfluously unboxed expressions
unnecessary.unicode.escape.display.name:
    text: Unnecessary Unicode escape sequence
unnecessary.unicode.escape.problem.descriptor:
    text: 'Unicode escape sequence <code>#ref</code> can be replaced with ''''{0}'''' #loc'
unpredictable.big.decimal.constructor.call.display.name:
    text: Unpredictable 'BigDecimal' constructor call
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option:
    text: Ignore constructor calls with multiple literals (e.g. 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.ignore.references.option:
    text: Ignore constructor calls with variable or method call arguments
unpredictable.big.decimal.constructor.call.problem.descriptor:
    text: 'Unpredictable <code>new #ref()</code> call #loc'
unpredictable.big.decimal.constructor.call.quickfix:
    text: Replace with ''{0}''
unqualified.field.access.display.name:
    text: Instance field access not qualified with 'this'
unqualified.field.access.problem.descriptor:
    text: 'Instance field access <code>#ref</code> is not qualified with ''this'' #loc'
unqualified.inner.class.access.display.name:
    text: Unqualified inner class access
unqualified.inner.class.access.option:
    text: Ignore references to local inner classes
unqualified.inner.class.access.problem.descriptor:
    text: '<code>#ref</code> is not qualified with outer class #loc'
unqualified.inner.class.access.quickfix:
    text: Qualify with outer class
unqualified.method.access.display.name:
    text: Instance method call not qualified with 'this'
unqualified.method.access.problem.descriptor:
    text: 'Instance method call <code>#ref()</code> is not qualified with ''this'' #loc'
unqualified.static.usage.display.name:
    text: Unqualified static access
unqualified.static.usage.ignore.field.option:
    text: Ignore unqualified field accesses
unqualified.static.usage.ignore.method.option:
    text: Ignore unqualified method calls
unqualified.static.usage.only.report.static.usages.option:
    text: Only report static access from a non-static context
unqualified.static.usage.problem.descriptor:
    text: 'Unqualified static method call <code>#ref()</code> #loc'
unqualified.static.usage.problem.descriptor1:
    text: 'Unqualified static field access <code>#ref</code> #loc'
unqualified.static.usage.qualify.field.quickfix:
    text: Qualify static field access
unqualified.static.usage.qualify.method.quickfix:
    text: Qualify static method call
unsecure.random.number.generation.display.name:
    text: Insecure random number generation
unsecure.random.number.generation.problem.descriptor1:
    text: 'For security purposes, use ''java.security.SecureRandom'' instead of <code>java.lang.Math.#ref()</code> #loc'
unsecure.random.number.generation.problem.descriptor2:
    text: 'For security purposes, use ''java.security.SecureRandom'' instead of <code>java.util.#ref</code> #loc'
unsecure.random.number.generation.problem.descriptor3:
    text: 'For security purposes, use ''java.security.SecureRandom'' instead of <code>#ref</code> #loc'
unused.catch.parameter.display.name:
    text: Unused 'catch' parameter
unused.catch.parameter.ignore.catch.option:
    text: Ignore when 'catch' block contains a comment
unused.catch.parameter.ignore.empty.option:
    text: Ignore unused 'catch' parameters in tests
unused.catch.parameter.problem.descriptor:
    text: 'Unused ''catch'' parameter <code>#ref</code> #loc'
unused.import.display.name:
    text: Unused import
unused.import.problem.descriptor:
    text: 'Unused import <code>#ref</code> #loc'
unused.label.display.name:
    text: Unused label
unused.label.problem.descriptor:
    text: 'Unused label <code>#ref</code> #loc'
unused.label.remove.quickfix:
    text: Remove unused label
update.column.name:
    text: Update names start with
upper.case.field.name.not.constant.display.name:
    text: Non-constant field with upper-case name
upper.case.field.name.not.constant.problem.descriptor:
    text: 'Non-constant field <code>#ref</code> with constant-style name #loc'
usage.of.obsolete.assert.display.name:
    text: Usage of obsolete 'junit.framework.Assert' method
use.0index.in.jdbc.prepared.statement.problem.descriptor:
    text: 'Use of index ''0'' in JDBC PreparedStatement #loc'
use.0index.in.jdbc.resultset.display.name:
    text: Use of index 0 in JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor:
    text: 'Use of index ''0'' in JDBC ResultSet #loc'
use.assert.as.identifier.display.name:
    text: Use of 'assert' as identifier
use.assert.as.identifier.problem.descriptor:
    text: 'Use of <code>#ref</code> as identifier #loc'
use.enum.as.identifier.display.name:
    text: Use of 'enum' as identifier
use.enum.as.identifier.problem.descriptor:
    text: 'Use of <code>#ref</code> as identifier #loc'
use.obsolete.collection.type.display.name:
    text: Use of obsolete collection type
use.obsolete.collection.type.ignore.library.arguments.option:
    text: Ignore obsolete collection types where they are required
use.obsolete.collection.type.problem.descriptor:
    text: 'Obsolete collection type <code>#ref</code> used #loc'
use.of.awt.peer.class.display.name:
    text: Use of AWT peer class
use.of.awt.peer.class.problem.descriptor:
    text: 'Use of AWT peer class <code>#ref</code> is non-portable #loc'
use.of.clone.call.method.problem.descriptor:
    text: Implementation of <code>#ref()</code>
use.of.clone.call.problem.descriptor:
    text: Call to <code>#ref()</code>
use.of.clone.display.name:
    text: Use of 'clone()' or 'Cloneable'
use.of.clone.reference.problem.descriptor:
    text: Use of <code>#ref</code>
use.of.concrete.jdbc.driver.class.display.name:
    text: Use of concrete JDBC driver class
use.of.concrete.jdbc.driver.class.problem.descriptor:
    text: 'Use of concrete JDBC driver class <code>#ref</code> is non-portable #loc'
use.of.obsolete.assert.problem.descriptor:
    text: 'Call to <code>#ref()</code> from ''org.junit.framework.Assert'' should be replaced with call to method from ''org.junit.Assert'' #loc'
use.of.obsolete.assert.quickfix:
    text: Replace with 'org.junit.Assert' method call
use.of.obsolete.date.time.api.display.name:
    text: Use of obsolete date-time API
use.of.obsolete.date.time.api.problem.descriptor:
    text: 'Obsolete date-time type <code>#ref</code> used #loc'
use.processbuilder.class.display.name:
    text: Use of 'java.lang.ProcessBuilder' class
use.processbuilder.class.problem.descriptor:
    text: 'Use of <code>#ref</code> is non-portable #loc'
use.stringtokenizer.display.name:
    text: Use of 'StringTokenizer'
use.stringtokenizer.problem.descriptor:
    text: '<code>#ref</code> in an internationalized context #loc'
use.sun.classes.display.name:
    text: Use of 'sun.*' classes
use.sun.classes.problem.descriptor:
    text: 'Use of Sun-supplied class <code>#ref</code> is non-portable #loc'
use.system.out.err.display.name:
    text: Use of 'System.out' or 'System.err'
use.system.out.err.problem.descriptor:
    text: 'Uses of <code>#ref</code> should probably be replaced with more robust logging #loc'
used.catch.parameter.named.ignore.problem.descriptor:
    text: '''catch'' parameter named <code>#ref</code> is used #loc'
utility.class.can.be.enum.display.name:
    text: Utility class can be 'enum'
utility.class.code.can.be.enum.problem.descriptor:
    text: 'Utility class <code>#ref</code> can be ''enum'' #loc'
utility.class.code.can.be.enum.quickfix:
    text: Convert to 'enum'
utility.class.display.name:
    text: Utility class
utility.class.problem.descriptor:
    text: 'Class <code>#ref</code> has only ''static'' members, indicating procedural construction #loc'
utility.class.with.public.constructor.display.name:
    text: Utility class with 'public' constructor
utility.class.with.public.constructor.make.quickfix:
    text: Make {0, choice, 1#constructor|2#constructors} 'private'
utility.class.with.public.constructor.problem.descriptor:
    text: 'Class <code>#ref</code> has only ''static'' members, and a ''public'' constructor #loc'
utility.class.without.private.constructor.create.quickfix:
    text: Generate empty 'private' constructor
utility.class.without.private.constructor.display.name:
    text: Utility class without 'private' constructor
utility.class.without.private.constructor.make.quickfix:
    text: Make constructor 'private'
utility.class.without.private.constructor.option:
    text: Ignore classes with only a main method
utility.class.without.private.constructor.problem.descriptor:
    text: 'Class <code>#ref</code> has only ''static'' members, and lacks a ''private'' constructor #loc'
value.of.post.decrement.problem.descriptor:
    text: 'Value of post-decrement expression <code>#ref</code> is used #loc'
value.of.post.increment.problem.descriptor:
    text: 'Value of post-increment expression <code>#ref</code> is used #loc'
value.of.pre.decrement.problem.descriptor:
    text: 'Value of pre-decrement expression <code>#ref</code> is used #loc'
value.of.pre.increment.problem.descriptor:
    text: 'Value of pre-increment expression <code>#ref</code> is used #loc'
variable.argument.method.display.name:
    text: Varargs method
variable.argument.method.problem.descriptor:
    text: 'Varargs method <code>#ref()</code> #loc'
variable.argument.method.quickfix:
    text: Convert varargs parameter to array
variable.not.used.inside.conditional.problem.descriptor:
    text: '<code>#ref</code> checked for ''null'' is not used inside conditional #loc'
variable.not.used.inside.if.display.name:
    text: Reference checked for 'null' is not used inside 'if'
variable.not.used.inside.if.problem.descriptor:
    text: '<code>#ref</code> checked for ''null'' is not used inside ''if'' #loc'
volatile.array.field.display.name:
    text: Volatile array field
volatile.field.problem.descriptor:
    text: 'Volatile field <code>#ref</code> of type ''''{0}'''' #loc'
volatile.long.or.double.field.display.name:
    text: Volatile long or double field
wait.called.on.condition.display.name:
    text: '''wait()'' called on ''java.util.concurrent.locks.Condition'' object'
wait.called.on.condition.problem.descriptor:
    text: 'Call to <code>#ref()</code> on Condition object #loc'
wait.not.in.loop.display.name:
    text: '''wait()'' not called in loop'
wait.not.in.loop.problem.descriptor:
    text: 'Call to <code>#ref()</code> is not in loop #loc'
wait.not.in.synchronized.context.display.name:
    text: '''wait()'' while not synchronized'
wait.not.in.synchronized.context.problem.descriptor:
    text: 'Call to <code>#ref</code> while not synchronized on ''''{0}'''' #loc'
wait.notify.not.in.synchronized.context.display.name:
    text: '''wait()'' or ''notify()'' is not in synchronized context'
wait.notify.while.not.synchronized.on.problem.descriptor:
    text: 'Call to <code>#ref</code> while not synchronized on ''''{0}'''' #loc'
wait.or.await.without.timeout.display.name:
    text: '''wait()'' or ''await()'' without timeout'
wait.or.await.without.timeout.problem.descriptor:
    text: '<code>#ref</code> without timeout #loc'
wait.while.holding.two.locks.display.name:
    text: '''wait()'' while holding two locks'
wait.while.holding.two.locks.problem.descriptor:
    text: 'Call to <code>#ref()</code> is made while holding two locks #loc'
wait.without.corresponding.notify.display.name:
    text: '''wait()'' without corresponding ''notify()'''
wait.without.corresponding.notify.problem.descriptor:
    text: 'Call to <code>#ref()</code> without corresponding <code>notify()</code> or <code>notifyAll()</code> #loc'
warn.level.and.lower.option:
    text: warn level and lower
warn.on.label:
    text: 'Warn on:'
while.can.be.foreach.display.name:
    text: '''while'' loop can be replaced with enhanced ''for'' loop'
while.can.be.foreach.problem.descriptor:
    text: '<code>#ref</code> loop can be replaced with enhanced ''for'' #loc'
while.loop.spins.on.field.display.name:
    text: '''while'' loop spins on field'
while.loop.spins.on.field.fix.family.name:
    text: Fix spin loop
while.loop.spins.on.field.fix.spinwait:
    text: Add Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile:
    text: Make ''{0}'' volatile
while.loop.spins.on.field.fix.volatile.spinwait:
    text: Make ''{0}'' volatile and add Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option:
    text: Only warn if the loop is empty
while.loop.spins.on.field.problem.descriptor:
    text: '<code>#ref</code> loop spins on field #loc'
teardown.calls.super.teardown.add.quickfix:
    text: "Add call to 'super.tearDown()'"