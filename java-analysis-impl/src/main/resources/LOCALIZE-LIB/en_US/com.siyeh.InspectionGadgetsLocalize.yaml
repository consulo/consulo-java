cast.to.concrete.class.display.name:
  text: Cast to a concrete class
cast.to.concrete.class.problem.descriptor:
  text: 'Cast to concrete class <code>{0}</code> #loc'
class.references.subclass.display.name:
  text: Class references one of its subclasses
class.references.subclass.problem.descriptor:
  text: 'Class ''''{0}'''' references subclass <code>#ref</code> #loc'
class.references.subclass.problem.descriptor.anonymous:
  text: 'Anonymous class references subclass <code>#ref</code> #loc'
collection.declared.by.class.display.name:
  text: Collection declared by class, not interface
collection.declared.by.class.problem.descriptor:
  text: 'Declaration of <code>#ref</code> should probably be weakened to ''''{0}'''' #loc'
collection.declared.by.class.ignore.locals.option:
  text: Ignore local variables
collection.declared.by.class.ignore.private.members.option:
  text: Ignore 'private' fields and methods
feature.envy.display.name:
  text: Feature envy
feature.envy.problem.descriptor:
  text: 'Class ''''{0}'''' accessed repeatedly in method <code>#ref()</code> #loc'
instance.variable.of.concrete.class.display.name:
  text: Type of instance field is concrete class
instance.variable.of.concrete.class.problem.descriptor:
  text: 'Type of field ''''{0}'''' is concrete class <code>#ref</code> #loc'
chain.of.instanceof.checks.display.name:
  text: Chain of 'instanceof' checks
chain.of.instanceof.checks.problem.descriptor:
  text: 'Chain of ''instanceof'' checks indicates abstraction failure #loc'
chain.of.class.equality.checks.problem.descriptor:
  text: 'Chain of class equality checks indicates abstraction failure #loc'
instanceof.concrete.class.display.name:
  text: '''instanceof'' a concrete class'
instanceof.concrete.class.problem.descriptor:
  text: '''instanceof'' concrete class <code>#ref</code> #loc'
instanceof.check.for.this.display.name:
  text: '''instanceof'' check for ''this'''
instanceof.check.for.this.problem.descriptor:
  text: '''instanceof'' check for <code>#ref</code> #loc'
local.variable.of.concrete.class.display.name:
  text: Local variable of concrete class
local.variable.of.concrete.class.problem.descriptor:
  text: 'Local variable ''''{0}'''' of concrete class <code>#ref</code> #loc'
magic.number.display.name:
  text: Magic number
magic.number.problem.descriptor:
  text: 'Magic number <code>#ref</code> #loc'
method.return.concrete.class.display.name:
  text: Method return of concrete class
method.return.concrete.class.problem.descriptor:
  text: 'Method returns a concrete class <code>#ref</code> #loc'
overly.strong.type.cast.display.name:
  text: Overly strong type cast
overly.strong.type.cast.weaken.quickfix:
  text: Weaken overly strong cast
concrete.class.method.parameter.display.name:
  text: Method parameter of concrete class
concrete.class.method.parameter.problem.descriptor:
  text: 'Parameter ''''{0}'''' of concrete class <code>#ref</code> #loc'
public.method.not.in.interface.display.name:
  text: '''public'' method not exposed in interface'
public.method.not.in.interface.problem.descriptor:
  text: '''public'' method <code>#ref()</code> is not exposed via an interface #loc'
public.method.not.in.interface.option:
  text: <html>Ignore if the containing class does not implement a non-library interface</html>
static.variable.of.concrete.class.display.name:
  text: Static field of concrete class
static.variable.of.concrete.class.problem.descriptor:
  text: 'Static field ''''{0}'''' of concrete class <code>#ref</code> #loc'
incompatible.mask.operation.display.name:
  text: Incompatible bitwise mask operation
incompatible.mask.operation.problem.descriptor.always.false:
  text: '<code>#ref</code> is always false #loc'
incompatible.mask.operation.problem.descriptor.always.true:
  text: '<code>#ref</code> is always true #loc'
pointless.bitwise.expression.display.name:
  text: Pointless bitwise expression
pointless.bitwise.expression.simplify.quickfix:
  text: Simplify
shift.operation.by.inappropriate.constant.display.name:
  text: Shift operation by inappropriate constant
shift.operation.by.inappropriate.constant.problem.descriptor.too.large:
  text: 'Shift operation <code>#ref</code> by overly large constant value #loc'
shift.operation.by.inappropriate.constant.problem.descriptor.negative:
  text: 'Shift operation <code>#ref</code> by negative constant value #loc'
equals.called.on.array.display.name:
  text: '''equals()'' called on array'
equals.called.on.array.problem.descriptor:
  text: '<code>#ref()</code> between arrays should probably be ''Arrays.equals()'' #loc'
replace.with.arrays.equals:
  text: Replace with 'Arrays.equals()'
replace.with.arrays.deep.equals:
  text: Replace with 'Arrays.deepEquals()'
assignment.to.null.display.name:
  text: '''null'' assignment'
assignment.to.null.problem.descriptor:
  text: '''null'' assigned to variable <code>#ref</code> #loc'
assignment.to.null.option:
  text: Ignore assignments to fields
assignment.to.static.field.from.instance.method.display.name:
  text: Assignment to static field from instance context
assignment.to.static.field.from.instance.method.problem.descriptor:
  text: 'Assignment to static field <code>#ref</code> from instance context #loc'
assignment.used.as.condition.display.name:
  text: Assignment used as condition
assignment.used.as.condition.problem.descriptor:
  text: '<code>#ref</code> used as condition #loc'
assignment.used.as.condition.replace.quickfix:
  text: Replace '=' with '=='
cast.conflicts.with.instanceof.display.name:
  text: Cast conflicts with 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor:
  text: 'Cast <code>#ref</code> conflicts with surrounding ''instanceof'' check #loc'
casting.to.incompatible.interface.display.name:
  text: Casting to incompatible interface
casting.to.incompatible.interface.problem.descriptor:
  text: 'Cast to incompatible interface <code>#ref</code> #loc'
collection.added.to.self.display.name:
  text: Collection added to self
collection.added.to.self.problem.descriptor:
  text: '''''{0}()'''' called on collection <code>#ref</code> with itself as argument #loc'
non.final.field.compareto.display.name:
  text: Non-final field referenced in 'compareTo()'
non.final.field.compareto.problem.descriptor:
  text: 'Non-final field <code>#ref</code> accessed in ''compareTo()'' #loc'
covariant.equals.display.name:
  text: Covariant 'equals()'
covariant.equals.problem.descriptor:
  text: '<code>#ref()</code> should take ''Object'' as its argument #loc'
empty.class.initializer.display.name:
  text: Empty class initializer
empty.class.initializer.problem.descriptor:
  text: 'Empty class initializer #loc'
empty.class.initializer.delete.quickfix:
  text: Delete empty class initializer
statement.with.empty.body.display.name:
  text: Statement with empty body
statement.with.empty.body.problem.descriptor:
  text: '<code>#ref</code> statement has empty body #loc'
statement.with.empty.body.include.option:
  text: Include statement bodies that are empty code blocks
equals.between.inconvertible.types.display.name:
  text: '''equals()'' between objects of inconvertible types'
equals.between.inconvertible.types.problem.descriptor:
  text: '<code>#ref()</code> between objects of inconvertible types ''''{0}'''' and ''''{1}'''' #loc'
equals.called.on.suspicious.object.display.name:
  text: '''equals()'' called on suspicious object'
equals.called.on.suspicious.object.problem.descriptor:
  text: Suspicious call ''equals'' on ''{0}'' object
non.final.field.in.equals.display.name:
  text: Non-final field referenced in 'equals()'
non.final.field.in.equals.problem.descriptor:
  text: 'Non-final field <code>#ref</code> accessed in ''equals()''  #loc'
equals.doesnt.check.class.parameter.display.name:
  text: '''equals()'' method which does not check class of parameter'
equals.doesnt.check.class.parameter.problem.descriptor:
  text: '<code>#ref()</code> should check the class of its parameter #loc'
for.loop.not.use.loop.variable.display.name:
  text: '''for'' loop where update or condition does not use loop variable'
for.loop.not.use.loop.variable.problem.descriptor.condition:
  text: '<code>#ref</code> statement has condition which does not use the for loop variable #loc'
for.loop.not.use.loop.variable.problem.descriptor.update:
  text: '<code>#ref</code> statement has update which does not use the for loop variable #loc'
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update:
  text: '<code>#ref</code> statement has condition and update which do not use the for loop variable #loc'
non.final.field.in.hashcode.display.name:
  text: Non-final field referenced in 'hashCode()'
non.final.field.in.hashcode.problem.descriptor:
  text: 'Non-final field <code>#ref</code> accessed in ''hashCode()'' #loc'
result.of.method.call.ignored.display.name:
  text: Result of method call ignored
result.of.method.call.ignored.problem.descriptor:
  text: 'Result of <code>{0}.#ref()</code> is ignored #loc'
result.of.method.call.ignored.class.column.title:
  text: Class name
result.of.method.call.ignored.method.column.title:
  text: Method name regex
result.of.method.call.ignored.non.library.option:
  text: Report all ignored non-library calls
infinite.recursion.display.name:
  text: Infinite recursion
infinite.recursion.problem.descriptor:
  text: 'Method <code>#ref()</code> recurses infinitely, and can only end by throwing an exception #loc'
instanceof.with.incompatible.interface.display.name:
  text: '''instanceof'' with incompatible interface'
instanceof.with.incompatible.interface.problem.descriptor:
  text: '''instanceof'' incompatible interface <code>#ref</code> #loc'
instantiation.utility.class.display.name:
  text: Instantiation of utility class
instantiation.utility.class.problem.descriptor:
  text: 'Instantiation of utility class <code>#ref</code> #loc'
iterator.hasnext.which.calls.next.display.name:
  text: '''Iterator.hasNext()'' which calls ''next()'''
iterator.hasnext.which.calls.next.problem.descriptor:
  text: '<code>Iterator.#ref()</code> contains call to ''next()'' #loc'
iterator.next.does.not.throw.nosuchelementexception.display.name:
  text: '''Iterator.next()'' which can''t throw ''NoSuchElementException'''
malformed.format.string.display.name:
  text: Malformed format string
malformed.format.string.problem.descriptor.malformed:
  text: 'Format string <code>#ref</code> is malformed #loc'
malformed.format.string.problem.descriptor.illegal:
  text: 'Illegal format string specifier: {0} #loc'
malformed.format.string.problem.descriptor.too.many.arguments:
  text: 'Too many arguments for format string (found: {0}, expected: {1}) #loc'
malformed.format.string.problem.descriptor.too.few.arguments:
  text: 'Too few arguments for format string (found: {0}, expected: {1}) #loc'
malformed.format.string.problem.descriptor.arguments.do.not.match.type:
  text: 'Argument type ''''{0}'''' does not match the type of the format specifier ''''{1}'''' #loc'
malformed.regular.expression.display.name:
  text: Malformed regular expression
malformed.regular.expression.problem.descriptor1:
  text: 'Regular expression <code>#ref</code> is malformed #loc'
malformed.regular.expression.problem.descriptor2:
  text: 'Regular expression <code>#ref</code> is malformed: {0} #loc'
malformed.xpath.expression.display.name:
  text: Malformed XPath expression
malformed.xpath.expression.problem.description:
  text: 'XPath expression <code>#ref</code> is malformed #loc'
mismatched.read.write.array.display.name:
  text: Mismatched read and write of array
mismatched.read.write.array.problem.descriptor.write.not.read:
  text: 'Contents of array <code>#ref</code> are written to, but never read #loc'
mismatched.read.write.array.problem.descriptor.read.not.write:
  text: 'Contents of array <code>#ref</code> are read, but never written to #loc'
mismatched.update.collection.display.name:
  text: Mismatched query and update of collection
mismatched.update.collection.problem.descriptor.updated.not.queried:
  text: 'Contents of collection <code>#ref</code> are updated, but never queried #loc'
mismatched.update.collection.problem.description.queried.not.updated:
  text: 'Contents of collection <code>#ref</code> are queried, but never updated #loc'
rename.quickfix:
  text: Rename
renameto.quickfix:
  text: Rename to ''{0}''
misspelled.equals.display.name:
  text: '''equal()'' instead of ''equals()'''
misspelled.equals.problem.descriptor:
  text: '<code>#ref()</code> method should probably be ''equals()'' #loc'
non.short.circuit.boolean.expression.display.name:
  text: Non-short-circuit boolean expression
non.short.circuit.boolean.expression.problem.descriptor:
  text: 'Non-short-circuit boolean expression <code>#ref</code> #loc'
non.short.circuit.boolean.expression.replace.quickfix:
  text: Replace with short circuit expression
null.argument.to.var.arg.method.display.name:
  text: Confusing argument to varargs method
null.argument.to.var.arg.method.problem.descriptor:
  text: 'Confusing argument <code>#ref</code>, unclear if a varargs or non-varargs call is desired #loc'
primitive.array.argument.to.var.arg.method.display.name:
  text: Confusing primitive array argument to varargs method
primitive.array.argument.to.var.arg.method.problem.descriptor:
  text: 'Confusing primitive array argument to varargs method #loc'
object.comparison.display.name:
  text: Object comparison using '==', instead of 'equals()'
object.comparison.enumerated.ignore.option:
  text: Ignore '==' between enumerated types
object.comparison.klass.ignore.option:
  text: Ignore '==' on 'java.lang.Class' objects
object.comparison.problem.description:
  text: 'Object values are compared using <code>#ref</code>, not ''equals()'' #loc'
object.comparison.replace.quickfix:
  text: Replace with 'equals()'
object.equals.null.problem.descriptor:
  text: '<code>.equals(#ref)</code> is probably not what was intended #loc'
default.tostring.call.display.name:
  text: Call to default 'toString()'
default.tostring.call.problem.descriptor:
  text: 'Call to default ''toString()'' on <code>#ref</code> #loc'
octal.and.decimal.integers.in.same.array.display.name:
  text: Octal and decimal integers in same array
octal.and.decimal.integers.in.same.array.problem.descriptor:
  text: 'Octal and decimal integers in the same array initializer #loc'
result.of.object.allocation.ignored.display.name:
  text: Result of object allocation ignored
result.of.object.allocation.ignored.problem.descriptor:
  text: 'Result of <code>new #ref()</code> is ignored #loc'
use.0index.in.jdbc.resultset.display.name:
  text: Use of index 0 in JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor:
  text: 'Use of index ''0'' in JDBC ResultSet #loc'
use.0index.in.jdbc.prepared.statement.problem.descriptor:
  text: 'Use of index ''0'' in JDBC PreparedStatement #loc'
return.of.null.display.name:
  text: Return of 'null'
return.of.null.problem.descriptor:
  text: 'Return of <code>#ref</code> #loc'
return.of.null.arrays.option:
  text: Report methods that return arrays
return.of.null.quickfix:
  text: Annotate method as @Nullable
return.of.null.objects.option:
  text: Report methods that return objects
return.of.null.collections.option:
  text: Report methods that return collection objects
return.of.null.ignore.private.option:
  text: Ignore 'private' methods
return.of.null.optional.quickfix:
  text: Replace with ''{0}.{1}()''
return.of.null.optional.quickfix.family:
  text: Replace with 'Optional.empty()'
static.method.via.subclass.display.name:
  text: Static method referenced via subclass
static.method.via.subclass.problem.descriptor:
  text: 'Static method <code>#ref()</code> declared in class ''''{0}'''' but referenced via subclass ''''{1}'''' #loc'
static.method.via.subclass.rationalize.quickfix:
  text: Rationalize static method call
static.field.via.subclass.display.name:
  text: Static field referenced via subclass
static.field.via.subclass.problem.descriptor:
  text: 'Static field <code>#ref</code> declared in class ''''{0}'''' but referenced via subclass ''''{1}'''' #loc'
static.field.via.subclass.rationalize.quickfix:
  text: Rationalize static field access
string.comparison.display.name:
  text: String comparison using '==', instead of 'equals()'
number.comparison.display.name:
  text: Number comparison using '==', instead of 'equals()'
string.comparison.problem.descriptor:
  text: 'String values are compared using <code>#ref</code>, not ''equals()'' #loc'
number.comparison.problem.descriptor:
  text: 'Number objects are compared using <code>#ref</code>, not ''equals()'' #loc'
subtraction.in.compareto.display.name:
  text: Subtraction in 'compareTo()'
subtraction.in.compareto.problem.descriptor:
  text: 'Subtraction <code>#ref</code> in ''compareTo()'' may result in overflow errors #loc'
text.label.in.switch.statement.display.name:
  text: Text label in 'switch' statement
text.label.in.switch.statement.problem.descriptor:
  text: 'Text label <code>#ref:</code> in ''switch'' statement #loc'
properties.object.as.hashtable.display.name:
  text: Use of Properties object as a Hashtable
properties.object.as.hashtable.problem.descriptor:
  text: 'Call to <code>Hashtable.#ref()</code> on properties object #loc'
assignment.replaceable.with.operator.assignment.display.name:
  text: Assignment replaceable with operator assignment
unnecessary.code.block.display.name:
  text: Unnecessary code block
unnecessary.code.block.unwrap.quickfix:
  text: Unwrap block
redundant.local.variable.display.name:
  text: Redundant local variable
redundant.local.variable.ignore.option:
  text: Ignore immediately returned or thrown variables
redundant.local.variable.annotation.option:
  text: Ignore variables which have an annotation
static.collection.display.name:
  text: Static collection
static.collection.problem.descriptor:
  text: 'Static collection <code>#ref</code> #loc'
static.collection.ignore.option:
  text: Ignore weak static collections or maps
stringbuffer.field.display.name:
  text: StringBuffer field
stringbuffer.field.problem.descriptor:
  text: '''''{0}'''' field <code>#ref</code> #loc'
gc.call.display.name:
  text: Calls to 'System.gc()' or 'Runtime.gc()'
gc.call.problem.descriptor:
  text: '<code>#ref</code> should not be called in production code #loc'
array.allocation.zero.length.display.name:
  text: Zero-length array allocation
array.allocation.zero.length.problem.descriptor:
  text: 'Allocation of zero length array #loc'
constant.for.zero.length.array.display.name:
  text: Unnecessary zero length array usage
constant.for.zero.length.array.problem.descriptor:
  text: 'Zero length array can be changed to constant #loc'
constant.for.zero.length.array.quickfix.family:
  text: Replace with constant
replace.with:
  text: Replace with ''{0}''
multiple.loggers.display.name:
  text: Class with multiple loggers
logger.name.option:
  text: 'Logger &class name:'
multiple.loggers.problem.descriptor:
  text: 'Class <code>#ref</code> declares multiple loggers #loc'
no.logger.display.name:
  text: Class without logger
no.logger.problem.descriptor:
  text: 'Class <code>#ref</code> does not declare a logger #loc'
non.constant.logger.display.name:
  text: Non-constant logger
non.constant.logger.problem.descriptor:
  text: 'Non-constant logger field <code>#ref</code> #loc'
public.method.without.logging.display.name:
  text: '''public'' method without logging'
public.method.without.logging.problem.descriptor:
  text: '''public'' method <code>#ref()</code> has no logging call #loc'
ignore.trivial.finalizers.option:
  text: Ignore for trivial 'finalize()' implementations
finalize.declaration.display.name:
  text: '''finalize()'' declaration'
finalize.declaration.problem.descriptor:
  text: '<code>#ref()</code> declared #loc'
finalize.not.declared.protected.display.name:
  text: '''finalize()'' not declared ''protected'''
finalize.not.declared.protected.problem.descriptor:
  text: '<code>#ref()</code> not declared ''protected'' #loc'
make.protected.quickfix:
  text: Make 'protected'
finalize.called.explicitly.display.name:
  text: '''finalize()'' called explicitly'
finalize.called.explicitly.problem.descriptor:
  text: '<code>#ref()</code> called explicitly #loc'
java.lang.import.display.name:
  text: '''java.lang'' import'
java.lang.import.problem.descriptor:
  text: 'Unnecessary import from package ''java.lang'' #loc'
import.display.name:
  text: '''*'' import'
import.problem.descriptor:
  text: 'Package import <code>#ref</code> #loc'
redundant.import.display.name:
  text: Redundant import
redundant.import.problem.descriptor:
  text: 'Redundant import <code>#ref</code> #loc'
import.from.same.package.display.name:
  text: Import from same package
import.from.same.package.problem.descriptor:
  text: 'Unnecessary import from same package <code>#ref</code> #loc'
single.class.import.display.name:
  text: Single class import
single.class.import.problem.descriptor:
  text: 'Single class import <code>#ref</code> #loc'
static.import.display.name:
  text: Static import
static.import.problem.descriptor:
  text: 'Static import <code>#ref</code>  #loc'
static.import.replace.quickfix:
  text: Replace with non-static import
unused.import.display.name:
  text: Unused import
unused.import.problem.descriptor:
  text: 'Unused import <code>#ref</code> #loc'
clone.instantiates.objects.with.constructor.display.name:
  text: '''clone()'' instantiates objects with constructor'
clone.instantiates.objects.with.constructor.problem.descriptor:
  text: '''clone()'' creates new <code>#ref</code> instances #loc'
clone.doesnt.declare.clonenotsupportedexception.display.name:
  text: '''clone()'' does not declare ''CloneNotSupportedException'''
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor:
  text: '<code>#ref()</code> #loc does not declare ''CloneNotSupportedException'''
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix:
  text: Declare 'CloneNotSupportedException'
clone.method.in.non.cloneable.class.display.name:
  text: '''clone()'' method in non-Cloneable class'
clone.method.in.non.cloneable.class.problem.descriptor:
  text: '<code>#ref()</code> defined in non-Cloneable class ''''{0}'''' #loc'
clone.method.in.non.cloneable.interface.problem.descriptor:
  text: '<code>#ref()</code> defined in non-Cloneable interface ''''{0}'''' #loc'
cloneable.class.without.clone.display.name:
  text: Cloneable class without 'clone()'
cloneable.class.without.clone.problem.descriptor:
  text: '<code>#ref</code> does not define ''clone()'' #loc'
cloneable.class.without.clone.ignore.option:
  text: Ignore classes cloneable due to inheritance
cloneable.class.without.clone.quickfix:
  text: Generate 'clone()' method
class.without.tostring.display.name:
  text: Class without 'toString()'
class.without.tostring.problem.descriptor:
  text: 'Class <code>#ref</code> should probably implement ''toString()'', for debugging purposes #loc'
use.obsolete.collection.type.display.name:
  text: Use of obsolete collection type
use.obsolete.collection.type.problem.descriptor:
  text: 'Obsolete collection type <code>#ref</code> used #loc'
use.obsolete.collection.type.ignore.library.arguments.option:
  text: Ignore obsolete collection types where they are required
inspection.suppression.annotation.display.name:
  text: Inspection suppression annotation
inspection.suppression.annotation.problem.descriptor:
  text: 'Inspection suppression annotation <code>#ref</code> #loc'
use.system.out.err.display.name:
  text: Use of System.out or System.err
use.system.out.err.problem.descriptor:
  text: 'Uses of <code>#ref</code> should probably be replaced with more robust logging #loc'
dumpstack.call.display.name:
  text: Call to 'Thread.dumpStack()'
dumpstack.call.problem.descriptor:
  text: 'Call to <code>Thread.#ref()</code> should probably be replaced with more robust logging #loc'
printstacktrace.call.display.name:
  text: Call to 'printStackTrace()'
printstacktrace.call.problem.descriptor:
  text: 'Call to <code>#ref()</code> should probably be replaced with more robust logging #loc'
abstract.method.call.in.constructor.display.name:
  text: Abstract method called during object construction
abstract.method.call.in.constructor.problem.descriptor:
  text: 'Call to ''abstract'' method <code>#ref()</code> during object construction #loc'
instance.variable.may.not.be.initialized.display.name:
  text: Instance field may not be initialized
instance.variable.may.not.be.initialized.problem.descriptor:
  text: 'Instance field <code>#ref</code> may not be initialized during object construction #loc'
instance.Variable.may.not.be.initialized.problem.descriptor.junit:
  text: 'Instance field <code>#ref</code> may not be initialized during object construction or ''setUp()'' call #loc'
primitive.fields.ignore.option:
  text: Ignore primitive fields
instance.variable.used.before.initialized.display.name:
  text: Instance field used before initialization
instance.variable.used.before.initialized.problem.descriptor:
  text: 'Instance field <code>#ref</code> used before initialized #loc'
non.final.static.variable.initialization.display.name:
  text: Non-final static field is used during class initialization
non.final.static.variable.initialization.problem.descriptor:
  text: 'Non-final static field <code>#ref</code> used during class initialization #loc'
overridable.method.call.in.constructor.display.name:
  text: Overridable method called during object construction
overridable.method.call.in.constructor.problem.descriptor:
  text: 'Call to overridable method <code>#ref()</code> during object construction #loc'
overridden.method.call.in.constructor.display.name:
  text: Overridden method called during object construction
overridden.method.call.in.constructor.problem.descriptor:
  text: 'Call to overridden method <code>#ref()</code> during object construction #loc'
static.variable.may.not.be.initialized.display.name:
  text: Static field may not be initialized
static.variable.may.not.be.initialized.problem.descriptor:
  text: 'Static field <code>#ref</code> may not be initialized during class initialization #loc'
static.variable.used.before.initialization.display.name:
  text: Static field used before initialization
static.variable.used.before.initialization.problem.descriptor:
  text: 'Static field <code>#ref</code> used before initialization #loc'
this.reference.escaped.in.construction.display.name:
  text: '''this'' reference escaped in object construction'
this.reference.escaped.in.construction.problem.descriptor:
  text: 'Escape of <code>#ref</code> during object construction #loc'
assignment.to.catch.block.parameter.display.name:
  text: Assignment to catch block parameter
extract.parameter.as.local.variable.quickfix:
  text: Extract parameter as local variable
assignment.to.for.loop.parameter.display.name:
  text: Assignment to 'for' loop parameter
assignment.to.for.loop.parameter.check.foreach.option:
  text: Check foreach parameters
assignment.to.for.loop.parameter.problem.descriptor:
  text: 'Assignment to for-loop parameter <code>#ref</code> #loc'
assignment.to.method.parameter.display.name:
  text: Assignment to method parameter
chained.equality.comparisons.display.name:
  text: Chained equality comparisons
confusing.octal.escape.sequence.display.name:
  text: Confusing octal escape sequence
increment.decrement.display.name:
  text: Value of ++ or -- used
nested.assignment.display.name:
  text: Result of assignment used
nested.assignment.problem.descriptor:
  text: 'Result of assignment expression used #loc'
overloaded.methods.with.same.number.parameters.display.name:
  text: Overloaded methods with same number of parameters
overloaded.vararg.method.display.name:
  text: Overloaded varargs method
refused.bequest.display.name:
  text: Method does not call super method
reuse.of.local.variable.display.name:
  text: Reuse of local variable
reuse.of.local.variable.split.quickfix:
  text: Split local variable
character.comparison.display.name:
  text: Character comparison
character.comparison.problem.descriptor:
  text: 'Character comparison <code>#ref</code> in an internationalized context #loc'
assignment.collection.array.field.from.parameter.display.name:
  text: Assignment to Collection or array field from parameter
assignment.collection.array.field.from.parameter.problem.descriptor.array:
  text: 'Assignment to array field <code>#ref</code> from parameter ''''{0}'''' #loc'
assignment.collection.array.field.from.parameter.problem.descriptor.collection:
  text: 'Assignment to Collection field <code>#ref</code> from parameter ''''{0}'''' #loc'
assignment.collection.array.field.option:
  text: Ignore assignments in 'private' methods
assignment.to.date.calendar.field.from.parameter.display.name:
  text: Assignment to Date or Calendar field from parameter
assignment.to.date.calendar.field.from.parameter.problem.descriptor:
  text: 'Assignment to ''''{0}'''' field <code>#ref</code> from parameter {1} #loc'
package.visible.field.display.name:
  text: Package-visible field
package.visible.field.problem.descriptor:
  text: 'Package-visible field <code>#ref</code> #loc'
package.visible.inner.class.display.name:
  text: Package-visible inner class
package.visible.inner.class.problem.descriptor:
  text: 'Package-visible inner class <code>#ref</code> #loc'
package.visible.inner.class.ignore.enum.option:
  text: Ignore package-visible inner enums
package.visible.inner.class.ignore.interface.option:
  text: Ignore package-visible inner interfaces
protected.field.display.name:
  text: Protected field
protected.field.problem.descriptor:
  text: 'Protected field <code>#ref</code> #loc'
protected.inner.class.display.name:
  text: Protected inner class
protected.inner.class.problem.descriptor:
  text: 'Protected inner class <code>#ref</code> #loc'
protected.inner.class.ignore.enum.option:
  text: Ignore 'protected' inner enums
protected.inner.class.ignore.interface.option:
  text: Ignore 'protected' inner interfaces
public.field.display.name:
  text: '''public'' field'
public.field.problem.descriptor:
  text: '''public'' field <code>#ref</code> #loc'
public.field.ignore.enum.type.fields.option:
  text: Ignore 'public final' fields of an enum type
public.inner.class.display.name:
  text: '''public'' inner class'
public.inner.class.problem.descriptor:
  text: '''public'' inner class <code>#ref</code> #loc'
public.inner.class.ignore.enum.option:
  text: Ignore 'public' inner enums
public.inner.class.ignore.interface.option:
  text: Ignore 'public' inner interfaces
return.of.collection.array.field.display.name:
  text: Return of Collection or array field
return.of.collection.array.field.problem.descriptor.array:
  text: '''return'' of array field <code>#ref</code> #loc'
return.of.collection.array.field.problem.descriptor.collection:
  text: '''return'' of Collection field <code>#ref</code> #loc'
return.of.collection.array.field.option:
  text: Ignore 'private' methods returning an array or collection field
return.date.calendar.field.display.name:
  text: Return of Date or Calendar field
return.date.calendar.field.problem.descriptor:
  text: 'Return of ''''{0}'''' field <code>#ref</code> #loc'
return.date.calendar.field.quickfix:
  text: Return clone of ''{0}''
accessing.non.public.field.of.another.object.display.name:
  text: Accessing a non-public field of another object
accessing.non.public.field.of.another.object.problem.descriptor:
  text: 'Direct access of non-public field <code>#ref</code> on another object #loc'
call.to.date.tostring.display.name:
  text: Call to 'Date.toString()'
call.to.date.tostring.problem.descriptor:
  text: '<code>Date.#ref()</code> used in an internationalized context #loc'
magic.character.display.name:
  text: Magic character
magic.character.problem.descriptor:
  text: 'Magic character <code>#ref</code> in an internationalized context #loc'
call.to.numeric.tostring.display.name:
  text: Call to Numeric 'toString()'
call.to.numeric.tostring.problem.descriptor:
  text: 'Numeric <code>#ref()</code> called in an internationalized context #loc'
instantiating.simpledateformat.without.locale.display.name:
  text: Instantiating a SimpleDateFormat without a Locale
instantiating.simpledateformat.without.locale.problem.descriptor:
  text: 'Instantiating a <code>#ref</code> without specifying a Locale in an internationalized context #loc'
string.concatenation.display.name:
  text: String concatenation
string.concatenation.problem.descriptor:
  text: 'String concatenation <code>#ref</code> in an internationalized context #loc'
inspection.option.ignore.system.out:
  text: Ignore for 'System.out.print' arguments
inspection.option.ignore.system.err:
  text: Ignore for 'System.err.print' arguments
inspection.option.ignore.assert:
  text: Ignore for assert statement description arguments
inspection.option.ignore.exceptions:
  text: Ignore for constructor arguments of Throwable subclasses
inspection.option.ignore.nonnls:
  text: Ignore when annotated via @NonNls
inspection.option.ignore.constant.initializers:
  text: Ignore for initializers of constant fields
inspection.option.ignore.in.annotations:
  text: Ignore in annotations
inspection.option.ignore.in.tostring:
  text: Ignore inside toString() methods
inspection.option.ignore.as.initial.capacity:
  text: Ignore initial capacity for StringBuilders and Collections
inspection.option.ignore.in.hashcode:
  text: Ignore constants in 'hashCode()' methods
string.touppercase.tolowercase.without.locale.display.name:
  text: Call to 'String.toUpperCase()' or 'toLowerCase()' without a Locale
string.touppercase.tolowercase.without.locale.problem.descriptor:
  text: '<code>String.#ref()</code> called without specifying a Locale using internationalized strings #loc'
use.stringtokenizer.display.name:
  text: Use of StringTokenizer
use.stringtokenizer.problem.descriptor:
  text: '<code>#ref</code> in an internationalized context #loc'
time.tostring.call.display.name:
  text: Call to 'Time.toString()'
time.tostring.call.problem.descriptor:
  text: '<code>Time.#ref()</code> in an internationalized context #loc'
class.escapes.defined.scope.display.name:
  text: Non-accessible class is exposed
class.escapes.defined.scope.display.module.option:
  text: Module's API exposes not exported classes (Java 9+)
class.escapes.defined.scope.display.public.option:
  text: Public API exposes non-accessible classes
class.escapes.defined.scope.display.package.option:
  text: Package-local API exposes private classes
class.escapes.defined.scope.problem.descriptor:
  text: 'Class <code>#ref</code> is exposed outside its defined scope #loc'
class.escapes.defined.scope.java9.modules.descriptor:
  text: Class <code>#ref</code> is not exported from module ''{0}''
field.name.hides.in.superclass.display.name:
  text: Field name hides field in superclass
field.name.hides.in.superclass.problem.descriptor:
  text: 'Field <code>#ref</code> hides field in superclass #loc'
field.name.hides.in.superclass.ignore.option:
  text: Ignore superclass fields not visible from subclass
inner.class.field.hides.outer.display.name:
  text: Inner class field hides outer class field
inner.class.field.hides.outer.ignore.option:
  text: Ignore outer fields not visible from inner class
inner.class.field.hides.outer.problem.descriptor:
  text: 'Inner class field <code>#ref</code> hides outer class field #loc'
local.variable.hides.member.variable.display.name:
  text: Local variable hides field
local.variable.hides.member.variable.problem.descriptor:
  text: 'Local variable <code>#ref</code> hides field in class ''''{0}'''' #loc'
local.variable.hides.member.variable.ignore.option:
  text: Ignore local variables in a static context
method.overloads.display.name:
  text: Method overloads method of superclass
method.overloads.problem.descriptor:
  text: 'Method <code>#ref()</code> overloads a compatible method of a superclass, when overriding might have been intended #loc'
method.overloads.report.incompatible.option:
  text: Report even if parameter types are not compatible
method.overrides.private.display.name.problem.descriptor:
  text: 'Method <code>#ref()</code> overrides a ''private'' method of a superclass #loc'
method.overrides.static.display.name:
  text: Method overrides static method of superclass
method.overrides.static.problem.descriptor:
  text: 'Method <code>#ref()</code> overrides a static method of a superclass #loc'
parameter.hides.member.variable.display.name:
  text: Parameter hides field
parameter.hides.member.variable.problem.descriptor:
  text: 'Parameter <code>#ref</code> hides field in class ''''{0}'''' #loc'
parameter.hides.member.variable.ignore.setters.option:
  text: Ignore for property setters
parameter.hides.member.variable.ignore.superclass.option:
  text: Ignore superclass fields not visible from subclass
parameter.hides.member.variable.ignore.constructors.option:
  text: Ignore for constructors
parameter.hides.member.variable.ignore.abstract.methods.option:
  text: Ignore for abstract methods
parameter.hides.member.variable.ignore.static.parameters.option:
  text: Ignore for static method parameters hiding instance fields
type.parameter.hides.visible.type.display.name:
  text: Type parameter hides visible type
type.parameter.hides.visible.type.problem.descriptor:
  text: 'Type parameter <code>#ref</code> hides visible type ''''{0}'''' #loc'
type.parameter.hides.type.parameter.problem.descriptor:
  text: 'Type parameter <code>#ref</code> hides type parameter ''''{0}'''' #loc'
anonymous.class.variable.hides.containing.method.variable.display.name:
  text: Anonymous class variable hides variable in containing method
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor:
  text: 'Anonymous class parameter <code>#ref</code> hides variable in containing method #loc'
anonymous.class.field.hides.containing.method.variable.problem.descriptor:
  text: 'Anonymous class field <code>#ref</code> hides variable in containing method #loc'
anonymous.class.variable.hides.containing.method.variable.problem.descriptor:
  text: 'Anonymous class local variable <code>#ref</code> hides variable in containing method #loc'
channel.opened.not.closed.display.name:
  text: Channel opened but not safely closed
drivermanager.call.display.name:
  text: Use of DriverManager to get JDBC connection
drivermanager.call.problem.descriptor:
  text: 'Call to <code>DriverManager.#ref()</code> #loc'
hibernate.resource.opened.not.closed.display.name:
  text: Hibernate resource opened but not safely closed
i.o.resource.opened.not.closed.display.name:
  text: I/O resource opened but not safely closed
resource.opened.not.closed.problem.descriptor:
  text: '''''{0}'''' should be opened in front of a ''''try'''' block and closed in the corresponding ''''finally'''' block #loc'
jdbc.resource.opened.not.closed.display.name:
  text: JDBC resource opened but not safely closed
jndi.resource.opened.not.closed.display.name:
  text: JNDI resource opened but not safely closed
socket.opened.not.closed.display.name:
  text: Socket opened but not safely closed
annotation.class.display.name:
  text: Annotation class
annotation.class.problem.descriptor:
  text: 'Annotation class <code>#ref</code> #loc'
annotation.display.name:
  text: Annotation
annotation.problem.descriptor:
  text: 'Annotation <code>#ref</code> #loc'
use.assert.as.identifier.display.name:
  text: Use of 'assert' as identifier
use.assert.as.identifier.problem.descriptor:
  text: 'Use of <code>#ref</code> as identifier #loc'
assert.statement.display.name:
  text: '''assert'' statement'
statement.problem.descriptor:
  text: '<code>#ref</code> statement #loc'
auto.boxing.display.name:
  text: Auto-boxing
auto.boxing.problem.descriptor:
  text: 'Auto-boxing <code>#ref</code> #loc'
auto.boxing.make.boxing.explicit.quickfix:
  text: Make boxing explicit
auto.boxing.ignore.added.to.collection.option:
  text: Ignore expressions added to a collection
auto.unboxing.display.name:
  text: Auto-unboxing
auto.unboxing.problem.descriptor:
  text: 'Auto-unboxing <code>#ref</code> #loc'
auto.unboxing.make.unboxing.explicit.quickfix:
  text: Make unboxing explicit
use.enum.as.identifier.display.name:
  text: Use of 'enum' as identifier
use.enum.as.identifier.problem.descriptor:
  text: 'Use of <code>#ref</code> as identifier #loc'
enumerated.class.display.name:
  text: Enumerated class
enumerated.class.problem.descriptor:
  text: 'Enumerated class <code>#ref</code> #loc'
extended.for.statement.display.name:
  text: Extended 'for' statement
extended.for.statement.replace.quickfix:
  text: Replace with old-style 'for' statement
variable.argument.method.display.name:
  text: Varargs method
variable.argument.method.problem.descriptor:
  text: 'Varargs method <code>#ref()</code> #loc'
variable.argument.method.quickfix:
  text: Convert varargs parameter to array
hardcoded.file.separator.display.name:
  text: Hardcoded file separator
hardcoded.file.separator.problem.descriptor:
  text: 'Hardcoded file separator <code>#ref</code> #loc'
hardcoded.file.separator.include.option:
  text: Include "example/*" in recognized MIME media types
hardcoded.line.separator.display.name:
  text: Hardcoded line separator
hardcoded.line.separator.problem.descriptor:
  text: 'Hardcoded line separator <code>#ref</code> #loc'
native.method.display.name:
  text: Native method
native.method.problem.descriptor:
  text: 'Methods declared <code>#ref</code> are non-portable #loc'
runtime.exec.call.display.name:
  text: Call to 'Runtime.exec()'
runtime.exec.call.problem.descriptor:
  text: 'Call to <code>Runtime.#ref()</code> is non-portable #loc'
system.exit.call.display.name:
  text: Call to 'System.exit()' or related methods
system.exit.call.problem.descriptor:
  text: 'Call to <code>{0}.#ref()</code> is non-portable #loc'
system.exit.call.ignore.option:
  text: Ignore in main method
system.getenv.call.display.name:
  text: Call to 'System.getenv()'
system.getenv.call.problem.descriptor:
  text: 'Call to <code>System.#ref()</code> is non-portable #loc'
use.of.awt.peer.class.display.name:
  text: Use of AWT peer class
use.of.awt.peer.class.problem.descriptor:
  text: 'Use of AWT peer class <code>#ref</code> is non-portable #loc'
use.of.concrete.jdbc.driver.class.display.name:
  text: Use of concrete JDBC driver class
use.of.concrete.jdbc.driver.class.problem.descriptor:
  text: 'Use of concrete JDBC driver class <code>#ref</code> is non-portable #loc'
use.processbuilder.class.display.name:
  text: Use of 'java.lang.ProcessBuilder' class
use.processbuilder.class.problem.descriptor:
  text: 'Use of <code>#ref</code> is non-portable #loc'
use.sun.classes.display.name:
  text: Use of sun.* classes
use.sun.classes.problem.descriptor:
  text: 'Use of Sun-supplied class <code>#ref</code> is non-portable #loc'
abstract.class.with.only.one.direct.inheritor.display.name:
  text: Abstract class which has only one direct inheritor
anonymous.inner.may.be.named.static.inner.class.display.name:
  text: Anonymous class may be a named 'static' inner class
anonymous.inner.may.be.named.static.inner.class.problem.descriptor:
  text: 'Anonymous class <code>#ref</code> may be a named ''static'' inner class #loc'
array.length.in.loop.condition.display.name:
  text: Array.length in loop condition
array.length.in.loop.condition.problem.descriptor:
  text: 'Check of array <code>#ref</code> in loop condition #loc'
large.array.allocation.no.outofmemoryerror.display.name:
  text: Large array allocation with no OutOfMemoryError check
large.array.allocation.no.outofmemoryerror.problem.descriptor:
  text: 'Large array allocation which is not checked for out-of-memory condition #loc'
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option:
  text: 'Maximum number of elements:'
connection.opened.not.safely.closed.display.name:
  text: Connection opened but not safely closed
interface.one.inheritor.display.name:
  text: Interface which has only one direct inheritor
interface.one.inheritor.problem.descriptor:
  text: 'Interface <code>#ref</code> has only one direct inheritor #loc'
method.call.in.loop.condition.display.name:
  text: Method call in loop condition
method.call.in.loop.condition.problem.descriptor:
  text: 'Call to method <code>#ref()</code> in loop condition #loc'
large.initializer.primitive.type.array.display.name:
  text: Overly large initializer for array of primitive type
large.initializer.primitive.type.array.problem.descriptor:
  text: 'Primitive array initializer with too many elements ({0}) #loc'
large.initializer.primitive.type.array.maximum.number.of.elements.option:
  text: 'Maximum number of elements:'
private.member.access.between.outer.and.inner.classes.display.name:
  text: Synthetic accessor call
private.member.access.between.outer.and.inner.classes.problem.descriptor:
  text: 'Access to ''private'' member of class ''''{0}'''' requires synthetic accessor call #loc'
private.member.access.between.outer.and.inner.classes.make.local.quickfix:
  text: Make ''{0}'' package-private
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix:
  text: Make ''{0}'' constructor package-private
recordstore.opened.not.safely.closed.display.name:
  text: RecordStore opened but not safely closed
overly.complex.anonymous.inner.class.display.name:
  text: Overly complex anonymous class
cyclomatic.complexity.limit.option:
  text: 'Cyclomatic complexity limit:'
overly.complex.anonymous.inner.class.problem.descriptor:
  text: 'Overly complex anonymous class (cyclomatic complexity = {0}) #loc'
anonymous.inner.class.with.too.many.methods.display.name:
  text: Anonymous inner class with too many methods
method.count.limit.option:
  text: 'Method count limit:'
anonymous.inner.class.with.too.many.methods.problem.descriptor:
  text: 'Anonymous inner class with too many methods (method count = {0}) #loc'
overly.complex.class.display.name:
  text: Overly complex class
overly.complex.class.problem.descriptor:
  text: 'Overly complex class <code>#ref</code> (cyclomatic complexity = {0}) #loc'
overly.coupled.class.display.name:
  text: Overly coupled class
overly.coupled.class.class.coupling.limit.option:
  text: 'Class coupling limit:'
include.java.system.classes.option:
  text: Include couplings to java system classes
include.library.classes.option:
  text: Include couplings to library classes
overly.coupled.class.problem.descriptor:
  text: '<code>#ref</code> is overly coupled (dependencies = {0}) #loc'
class.too.deep.display.name:
  text: Class too deep in inheritance tree
class.too.deep.inheritance.depth.limit.option:
  text: 'Inheritance depth limit:'
class.too.deep.problem.descriptor:
  text: '<code>#ref</code> is too deep in inheritance tree (inheritance depth = {0}) #loc'
inner.class.too.deeply.nested.display.name:
  text: Inner class too deeply nested
inner.class.too.deeply.nested.nesting.limit.option:
  text: 'Nesting limit:'
inner.class.too.deeply.nested.problem.descriptor:
  text: '<code>#ref</code> is too deeply nested (nesting level = {0}) #loc'
too.many.constructors.display.name:
  text: Class with too many constructors
too.many.constructors.count.limit.option:
  text: 'Constructor count limit:'
too.many.constructors.ignore.deprecated.option:
  text: Ignore deprecated constructors
too.many.constructors.problem.descriptor:
  text: '<code>#ref</code> has too many constructors (constructor count = {0}) #loc'
too.many.fields.display.name:
  text: Class with too many fields
too.many.fields.count.limit.option:
  text: 'Field count limit:'
too.many.fields.problem.descriptor:
  text: '<code>#ref</code> has too many fields (field count = {0}) #loc'
too.many.methods.display.name:
  text: Class with too many methods
too.many.methods.problem.descriptor:
  text: '<code>#ref</code> has too many methods (method count = {0}) #loc'
externalizable.with.serialization.methods.display.name:
  text: Externalizable class with 'readObject()' or 'writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both:
  text: 'Externalizable class <code>#ref</code> defines ''readObject()'' and ''writeObject()'' #loc'
externalizable.with.serialization.methods.problem.descriptor.write:
  text: 'Externalizable class <code>#ref</code> defines ''writeObject()'' #loc'
externalizable.with.serialization.methods.problem.descriptor.read:
  text: 'Externalizable class <code>#ref</code> defines ''readObject()'' #loc'
non.serializable.with.serialversionuid.display.name:
  text: Non-serializable class with 'serialVersionUID'
non.serializable.class.with.serialversionuid.problem.descriptor:
  text: 'Non-serializable class <code>#ref</code> defines a ''serialVersionUID'' field #loc'
non.serializable.interface.with.serialversionuid.problem.descriptor:
  text: 'Non-serializable interface <code>#ref</code> defines a ''serialVersionUID'' field #loc'
non.serializable.ainterface.with.serialversionuid.problem.descriptor:
  text: 'Non-serializable @interface <code>#ref</code> defines a ''serialVersionUID'' field #loc'
non.serializable.anonymous.with.serialversionuid.problem.descriptor:
  text: 'Non-serializable anonymous class extending <code>#ref</code> defines a ''serialVersionUID'' field #loc'
non.serializable.with.serialversionuid.remove.quickfix:
  text: Remove 'serialVersionUID' field
non.serializable.class.with.readwriteobject.display.name:
  text: Non-serializable class with 'readObject()' or 'writeObject()'
non.serializable.class.with.readwriteobject.problem.descriptor.both:
  text: 'Non-serializable class <code>#ref</code> defines ''readObject()'' and ''writeObject()'' #loc'
non.serializable.class.with.readwriteobject.problem.descriptor.write:
  text: 'Non-serializable class <code>#ref</code> defines ''writeObject()'' #loc'
non.serializable.class.with.readwriteobject.problem.descriptor.read:
  text: 'Non-serializable class <code>#ref</code> defines ''readObject()'' #loc'
non.serializable.anonymous.with.readwriteobject.problem.descriptor.both:
  text: 'Non-serializable anonymous class extending <code>#ref</code> defines ''readObject()'' and ''writeObject()'' #loc'
non.serializable.anonymous.with.readwriteobject.problem.descriptor.write:
  text: 'Non-serializable anonymous class extending <code>#ref</code> defines ''writeObject()'' #loc'
non.serializable.anonymous.with.readwriteobject.problem.descriptor.read:
  text: 'Non-serializable anonymous class extending <code>#ref</code> defines ''readObject()'' #loc'
readwriteobject.private.display.name:
  text: '''readObject()'' or ''writeObject()'' not declared ''private'''
readwriteobject.private.problem.descriptor:
  text: '<code>#ref</code> not declared ''private'' #loc'
readobject.initialization.display.name:
  text: Instance field may not be initialized by 'readObject()'
readobject.initialization.problem.descriptor:
  text: 'Instance field <code>#ref</code> may not be initialized during ''readObject()'' call #loc'
readresolve.writereplace.protected.display.name:
  text: '''readResolve()'' or ''writeReplace()'' not declared ''protected'''
readresolve.writereplace.protected.problem.descriptor:
  text: '<code>#ref()</code> not declared ''protected'' #loc'
serialpersistentfields.with.wrong.signature.display.name:
  text: '''serialPersistentFields'' field not declared ''private static final ObjectStreamField[]'''
serialpersistentfields.with.wrong.signature.problem.descriptor:
  text: '<code>#ref</code> field of a Serializable class is not declared ''private static final ObjectStreamField[]'' #loc'
serialversionuid.private.static.final.long.display.name:
  text: '''serialVersionUID'' field not declared ''private static final long'''
serialversionuid.private.static.final.long.problem.descriptor:
  text: '<code>#ref</code> field of a Serializable class is not declared ''private static final long'' #loc'
serialversionuid.private.static.final.long.quickfix:
  text: Make serialVersionUID 'private static final'
serializable.class.without.serialversionuid.display.name:
  text: Serializable class without 'serialVersionUID'
serializable.class.without.serialversionuid.problem.descriptor:
  text: '<code>#ref</code> does not define a ''serialVersionUID'' field #loc'
non.protected.constructor.in.abstract.class.display.name:
  text: '''public'' constructor in ''abstract'' class'
unnecessary.qualifier.for.this.display.name:
  text: Unnecessary qualifier for 'this' or 'super'
multiple.declaration.display.name:
  text: Multiple variables in one declaration
thread.priority.display.name:
  text: Call to 'Thread.setPriority()'
too.broad.scope.display.name:
  text: Scope of variable is too broad
infinite.loop.statement.display.name:
  text: Infinite loop statement
asserts.without.messages.display.name:
  text: Message missing on JUnit assertion
constant.naming.convention.display.name:
  text: Constant naming convention
constant.naming.convention.element.description:
  text: Constant
random.double.for.random.integer.display.name:
  text: Using 'Random.nextDouble()' to get random integer
test.method.without.assertion.display.name:
  text: JUnit test method without any assertions
string.buffer.replaceable.by.string.builder.display.name:
  text: '''StringBuffer'' may be ''StringBuilder'''
comparison.of.short.and.char.display.name:
  text: Comparison of 'short' and 'char' values
unnecessary.fully.qualified.name.display.name:
  text: Unnecessary fully qualified name
ignore.in.module.statements.option:
  text: Ignore in Java 9 module statements
unnecessary.label.on.break.statement.display.name:
  text: Unnecessary label on 'break' statement
exception.name.doesnt.end.with.exception.display.name:
  text: Exception class name does not end with 'Exception'
bad.exception.declared.display.name:
  text: Prohibited exception declared
deserializable.class.in.secure.context.display.name:
  text: Deserializable class in secure context
pointless.boolean.expression.display.name:
  text: Pointless boolean expression
class.without.constructor.display.name:
  text: Class without constructor
break.statement.display.name:
  text: '''break'' statement'
unconditional.wait.display.name:
  text: Unconditional 'wait()' call
cyclomatic.complexity.display.name:
  text: Overly complex method
string.to.string.display.name:
  text: Redundant 'String.toString()'
constant.on.lhs.of.comparison.display.name:
  text: Constant on left side of comparison
final.class.display.name:
  text: '''final'' class'
labeled.statement.display.name:
  text: Labeled statement
notify.called.on.condition.display.name:
  text: '''notify()''  or ''notifyAll()'' called on ''java.util.concurrent.locks.Condition'' object'
loop.statements.that.dont.loop.display.name:
  text: Loop statement that does not loop
thread.run.display.name:
  text: Call to 'Thread.run()'
non.synchronized.method.overrides.synchronized.method.display.name:
  text: Unsynchronized method overrides synchronized method
constant.on.rhs.of.comparison.display.name:
  text: Constant on right side of comparison
synchronize.on.this.display.name:
  text: Synchronization on 'this'
switch.statement.with.too.many.branches.display.name:
  text: '''switch'' statement with too many branches'
utility.class.without.private.constructor.display.name:
  text: Utility class without 'private' constructor
throw.caught.locally.display.name:
  text: '''throw'' caught by containing ''try'' statement'
exception.from.catch.which.doesnt.wrap.display.name:
  text: '''throw'' inside ''catch'' block which ignores the caught exception'
type.parameter.naming.convention.display.name:
  text: Type parameter naming convention
type.parameter.naming.convention.element.description:
  text: Type parameter
multiply.or.divide.by.power.of.two.display.name:
  text: Multiply or divide by power of two
multiply.or.divide.by.power.of.two.divide.option:
  text: Check divisions by a power of two also
serializable.with.unconstructable.ancestor.display.name:
  text: Serializable class with unconstructable ancestor
missorted.modifiers.display.name:
  text: Missorted modifiers
sleep.while.holding.lock.display.name:
  text: Call to 'Thread.sleep()' while synchronized
singleton.display.name:
  text: Singleton
thread.death.rethrown.display.name:
  text: '''java.lang.ThreadDeath'' not rethrown'
if.statement.with.too.many.branches.display.name:
  text: '''if'' statement with too many branches'
redundant.implements.display.name:
  text: Redundant interface declaration
nesting.depth.display.name:
  text: Overly nested method
return.this.display.name:
  text: Return of 'this'
busy.wait.display.name:
  text: Busy wait
utility.class.display.name:
  text: Utility class
instantiating.object.to.get.class.object.display.name:
  text: Instantiating object to get Class object
abstract.class.extends.concrete.class.display.name:
  text: Abstract class extends concrete class
parameter.naming.convention.display.name:
  text: Method parameter naming convention
parameter.naming.convention.element.description:
  text: Parameter
integer.division.in.floating.point.context.display.name:
  text: Integer division in floating point context
interface.naming.convention.display.name:
  text: Interface naming convention
interface.naming.convention.element.description:
  text: Interface
length.one.strings.in.concatenation.display.name:
  text: Single character string concatenation
length.one.string.in.indexof.display.name:
  text: Single character string argument in 'String.indexOf()' call
unnecessary.conditional.expression.display.name:
  text: Redundant conditional expression
thread.yield.display.name:
  text: Call to 'Thread.yield()'
confusing.floating.point.literal.display.name:
  text: Confusing floating-point literal
wait.not.in.loop.display.name:
  text: '''wait()'' not in loop'
string.concatenation.inside.string.buffer.append.display.name:
  text: String concatenation as argument to 'StringBuffer.append()' call
class.initializer.display.name:
  text: Non-'static' initializer
enumerated.class.naming.convention.display.name:
  text: Enumerated class naming convention
enumerated.class.naming.convention.element.description:
  text: Enumerated class
non.thread.safe.lazy.initialization.display.name:
  text: Unsafe lazy initialization of 'static' field
call.to.simple.setter.in.class.display.name:
  text: Call to simple setter from within class
comparison.to.nan.display.name:
  text: Comparison to Double.NaN or Float.NaN
instance.method.naming.convention.display.name:
  text: Instance method naming convention
instance.method.naming.convention.element.description:
  text: Instance method
unnecessary.semicolon.display.name:
  text: Unnecessary semicolon
fallthru.in.switch.statement.display.name:
  text: Fallthrough in 'switch' statement
call.to.native.method.while.locked.display.name:
  text: Call to a native method while locked
switch.statement.display.name:
  text: '''switch'' statement'
custom.classloader.display.name:
  text: Custom ClassLoader
nested.conditional.expression.display.name:
  text: Nested conditional expression
duplicate.condition.display.name:
  text: Duplicate condition in 'if' statement
duplicate.boolean.branch.display.name:
  text: Duplicate condition on '\&\&' or '||'
method.with.multiple.loops.display.name:
  text: Method with multiple loops
non.comment.source.statements.display.name:
  text: Overly long method
local.variable.naming.convention.display.name:
  text: Local variable naming convention
local.variable.naming.convention.element.description:
  text: Local variable
negated.if.else.display.name:
  text: '''if'' statement with negated condition'
class.naming.convention.display.name:
  text: Class naming convention
class.naming.convention.element.description:
  text: Class
abstract.class.naming.convention.display.name:
  text: Abstract class naming convention
abstract.class.naming.convention.element.description:
  text: Abstract class
serializable.inner.class.with.non.serializable.outer.class.display.name:
  text: Serializable non-'static' inner class with non-Serializable outer class
pointless.arithmetic.expression.display.name:
  text: Pointless arithmetic expression
method.name.same.as.class.name.display.name:
  text: Method name same as class name
unnecessary.temporary.on.conversion.to.string.display.name:
  text: Unnecessary temporary object in conversion to String
unnecessary.continue.display.name:
  text: Unnecessary 'continue' statement
inner.class.on.interface.display.name:
  text: Inner class of interface
unused.label.display.name:
  text: Unused label
multiple.typed.declaration.display.name:
  text: Variables of different types in one declaration
overly.complex.boolean.expression.display.name:
  text: Overly complex boolean expression
continue.statement.with.label.display.name:
  text: '''continue'' statement with label'
class.loader.instantiation.display.name:
  text: ClassLoader instantiation
return.from.finally.block.display.name:
  text: '''return'' inside ''finally'' block'
unnecessary.boxing.display.name:
  text: Unnecessary boxing
annotation.naming.convention.display.name:
  text: Annotation naming convention
annotation.naming.convention.element.description:
  text: Annotation
checked.exception.class.display.name:
  text: Checked exception class
switch.statement.with.confusing.declaration.display.name:
  text: Local variable used and declared in different 'switch' branches
cast.that.loses.precision.display.name:
  text: Numeric cast that loses precision
manual.array.copy.display.name:
  text: Manual array copy
manual.array.to.collection.copy.display.name:
  text: Manual array to collection copy
long.literals.ending.with.lowercase.l.display.name:
  text: '''long'' literal ending with ''l'' instead of ''L'''
overly.complex.arithmetic.expression.display.name:
  text: Overly complex arithmetic expression
junit.abstract.test.class.naming.convention.display.name:
  text: JUnit abstract test class naming convention
junit.abstract.test.class.naming.convention.element.description:
  text: Abstract JUnit test class
unnecessary.parentheses.display.name:
  text: Unnecessary parentheses
test.case.in.product.code.display.name:
  text: JUnit TestCase in product source
test.method.in.product.code.display.name:
  text: JUnit test method in product source
serializable.class.in.secure.context.display.name:
  text: Serializable class in secure context
static.variable.naming.convention.display.name:
  text: '''static'' field naming convention'
static.variable.naming.convention.element.description:
  text: '''static'' field'
nested.method.call.display.name:
  text: Nested method call
throw.from.finally.block.display.name:
  text: '''throw'' inside ''finally'' block'
field.accessed.synchronized.and.unsynchronized.display.name:
  text: Field accessed in both synchronized and unsynchronized contexts
abstract.method.overrides.abstract.method.display.name:
  text: Abstract method overrides abstract method
static.non.final.field.display.name:
  text: '''static'', non-''final'' field'
static.non.final.field.option:
  text: Only report 'public' fields
substring.zero.display.name:
  text: Redundant 'substring(0)' call
class.without.no.arg.constructor.display.name:
  text: Class without no-arg constructor
unnecessary.return.display.name:
  text: Unnecessary 'return' statement
final.static.method.display.name:
  text: '''static'' method declared ''final'''
constant.declared.in.abstract.class.display.name:
  text: Constant declared in abstract class
too.broad.catch.display.name:
  text: Overly broad 'catch' block
floating.point.equality.display.name:
  text: Floating point equality comparison
thrown.exceptions.per.method.display.name:
  text: Method with too many exceptions declared
public.static.array.field.display.name:
  text: '''public static'' array field'
await.not.in.loop.display.name:
  text: '''await()'' not in loop'
method.names.differ.only.by.case.display.name:
  text: Method names differing only by case
unsecure.random.number.generation.display.name:
  text: Insecure random number generation
parameters.per.method.display.name:
  text: Method with too many parameters
parameters.per.constructor.display.name:
  text: Constructor with too many parameters
unnecessary.unboxing.display.name:
  text: Unnecessary unboxing
extends.thread.display.name:
  text: Class directly extends 'java.lang.Thread'
test.case.with.constructor.display.name:
  text: JUnit TestCase with non-trivial constructors
parameter.name.differs.from.overridden.parameter.display.name:
  text: Parameter name differs from parameter in overridden method
final.private.method.display.name:
  text: '''private'' method declared ''final'''
enum.switch.statement.which.misses.cases.display.name:
  text: Enum 'switch' statement that misses case
enum.switch.statement.which.misses.cases.option:
  text: Ignore switch statements with a default branch
unconstructable.test.case.display.name:
  text: Unconstructable JUnit TestCase
volatile.long.or.double.field.display.name:
  text: Volatile long or double field
string.buffer.must.have.initial.capacity.display.name:
  text: StringBuffer or StringBuilder without initial capacity
method.may.be.static.display.name:
  text: Method may be 'static'
class.initializer.may.be.static.display.name:
  text: Class initializer may be 'static'
class.initializer.option:
  text: Only warn when the class has one or more constructors
class.initializer.move.code.to.constructor.quickfix:
  text: Move initializer code to constructor
nested.switch.statement.display.name:
  text: Nested 'switch' statement
c.style.array.declaration.display.name:
  text: C-style array declaration
final.method.in.final.class.display.name:
  text: '''final'' method in ''final'' class'
extends.annotation.display.name:
  text: Class extends annotation interface
naked.notify.display.name:
  text: '''notify()'' or ''notifyAll()'' without corresponding state change'
constant.if.statement.display.name:
  text: Constant 'if' statement
switch.statement.density.display.name:
  text: '''switch'' statement with too low of a branch density'
switch.statement.with.too.few.branches.display.name:
  text: '''switch'' statement with too few branches'
upper.case.field.name.not.constant.display.name:
  text: Non-constant field with upper-case name
unnecessary.label.on.continue.statement.display.name:
  text: Unnecessary label on 'continue' statement
jdbc.prepare.statement.with.non.constant.string.display.name:
  text: Call to 'Connection.prepare*()' with non-constant string
synchronize.on.non.final.field.display.name:
  text: Synchronization on a non-final field
noop.method.in.abstract.class.display.name:
  text: No-op method in abstract class
non.final.field.of.exception.display.name:
  text: Non-final field of exception class
nested.try.statement.display.name:
  text: Nested 'try' statement
condition.signal.display.name:
  text: Call to 'signal()' instead of 'signalAll()'
jdbc.execute.with.non.constant.string.display.name:
  text: Call to 'Statement.execute()' with non-constant string
system.set.security.manager.display.name:
  text: Call to 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor:
  text: 'Call to <code>System.#ref()</code> may pose security concerns #loc'
control.flow.statement.without.braces.display.name:
  text: Control flow statement without braces
trivial.if.display.name:
  text: Redundant 'if' statement
thread.with.default.run.method.display.name:
  text: Instantiating a Thread with default 'run()' method
while.loop.spins.on.field.display.name:
  text: '''while'' loop spins on field'
while.loop.spins.on.field.fix.family.name:
  text: Fix spin loop
while.loop.spins.on.field.fix.volatile:
  text: Make ''{0}'' volatile
while.loop.spins.on.field.fix.spinwait:
  text: Add Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile.spinwait:
  text: Make ''{0}'' volatile and add Thread.onSpinWait()
object.equals.null.display.name:
  text: Object.equals(null)
test.method.is.public.void.no.arg.display.name:
  text: Malformed test method
if.statement.with.identical.branches.display.name:
  text: '''if'' statement with identical branches'
multiple.return.points.per.method.display.name:
  text: Method with multiple return points
break.statement.with.label.display.name:
  text: '''break'' statement with label'
public.constructor.in.non.public.class.display.name:
  text: '''public'' constructor in non-public class'
questionable.name.display.name:
  text: Questionable name
empty.finally.block.display.name:
  text: Empty 'finally' block
abstract.method.overrides.concrete.method.display.name:
  text: Abstract method overrides concrete method
thread.stop.suspend.resume.display.name:
  text: Call to 'Thread.stop()', 'suspend()' or 'resume()'
constant.math.call.display.name:
  text: Constant call to 'java.lang.Math'
volatile.array.field.display.name:
  text: Volatile array field
literal.as.arg.to.string.equals.display.name:
  text: '''expression.equals("literal")'' rather than ''"literal".equals(expression)'''
inner.class.may.be.static.display.name:
  text: Inner class may be 'static'
static.suite.display.name:
  text: '''suite()'' method not declared ''static'''
redundant.field.initialization.display.name:
  text: Redundant field initialization
string.buffer.to.string.in.concatenation.display.name:
  text: '''StringBuffer.toString()'' in concatenation'
utility.class.with.public.constructor.display.name:
  text: Utility class with 'public' constructor
for.loop.replaceable.by.while.display.name:
  text: '''for'' loop may be replaced with ''while'' loop'
missing.deprecated.annotation.display.name:
  text: Missing @Deprecated annotation
cloneable.class.in.secure.context.display.name:
  text: Cloneable class in secure context
static.inheritance.display.name:
  text: Static inheritance
class.name.prefixed.with.package.name.display.name:
  text: Class name prefixed with package name
call.to.simple.getter.in.class.display.name:
  text: Call to simple getter from within class
class.name.differs.from.file.name.display.name:
  text: Class name differs from file name
protected.member.in.final.class.display.name:
  text: '''protected'' member in ''final'' class'
load.library.with.non.constant.string.display.name:
  text: Call to 'System.loadLibrary()' with non-constant string
instanceof.catch.parameter.display.name:
  text: '''instanceof'' on ''catch'' parameter'
implicit.numeric.conversion.display.name:
  text: Implicit numeric conversion
unnecessary.interface.modifier.display.name:
  text: Unnecessary interface modifier
confusing.main.method.display.name:
  text: Confusing 'main()' method
octal.literal.display.name:
  text: Octal integer
misordered.assert.equals.arguments.display.name:
  text: Misordered 'assertEquals()' arguments
unnecessary.constructor.display.name:
  text: Redundant no-arg constructor
method.name.same.as.parent.name.display.name:
  text: Method name same as parent class name
while.can.be.foreach.display.name:
  text: '''while'' loop replaceable with ''foreach'''
big.decimal.equals.display.name:
  text: '''equals()'' called on ''java.math.BigDecimal'''
implicit.call.to.super.display.name:
  text: Implicit call to 'super()'
empty.catch.block.display.name:
  text: Empty 'catch' block
unqualified.static.usage.display.name:
  text: Unqualified static access
simplifiable.junit.assertion.display.name:
  text: Simplifiable JUnit assertion
simplifiable.testng.assertion.display.name:
  text: Simplifiable TestNG assertion
object.notify.display.name:
  text: Call to 'notify()' instead of 'notifyAll()'
thread.start.in.construction.display.name:
  text: Call to 'Thread.start()' during object construction
non.final.clone.display.name:
  text: Non-final 'clone()' in secure context
unnecessary.temporary.on.conversion.from.string.display.name:
  text: Unnecessary temporary object in conversion from String
unnecessary.this.display.name:
  text: Unnecessary 'this' qualifier
unnecessary.this.ignore.assignments.option:
  text: Ignore field assignments
runtime.exec.with.non.constant.string.display.name:
  text: Call to 'Runtime.exec()' with non-constant string
system.properties.display.name:
  text: Access of system properties
chained.method.call.display.name:
  text: Chained method calls
safe.lock.display.name:
  text: Lock acquired but not safely unlocked
system.run.finalizers.on.exit.display.name:
  text: Call to 'System.runFinalizersOnExit()'
for.can.be.foreach.display.name:
  text: '''for'' loop replaceable with ''foreach'''
type.parameter.extends.object.display.name:
  text: Type parameter explicitly extends 'java.lang.Object'
marker.interface.display.name:
  text: Marker interface
limited.scope.inner.class.display.name:
  text: Limited-scope inner class
switch.statements.without.default.display.name:
  text: '''switch'' statement without ''default'' branch'
unchecked.exception.class.display.name:
  text: Unchecked exception class
for.loop.with.missing.component.display.name:
  text: '''for'' loop with missing components'
for.loop.with.missing.component.collection.loop.option:
  text: Ignore collection iterations
double.checked.locking.display.name:
  text: Double-checked locking
double.checked.locking.problem.descriptor:
  text: 'Double-checked locking #loc'
double.checked.locking.ignore.on.volatiles.option:
  text: Ignore double-checked locking on volatile fields
string.buffer.replaceable.by.string.display.name:
  text: '''StringBuffer'' can be replaced with ''String'''
boolean.method.name.must.start.with.question.display.name:
  text: Boolean method name must start with question word
class.name.same.as.ancestor.name.display.name:
  text: Class name same as ancestor name
error.rethrown.display.name:
  text: '''java.lang.Error'' not rethrown'
serializable.has.serialization.methods.display.name:
  text: Serializable class without 'readObject()' and 'writeObject()'
serializable.has.serialization.methods.ignore.option:
  text: Ignore classes that do not define instance fields
missing.override.annotation.display.name:
  text: Missing @Override annotation
wait.while.holding.two.locks.display.name:
  text: '''wait()'' while holding two locks'
empty.class.display.name:
  text: Empty class
trivial.string.concatenation.display.name:
  text: Concatenation with empty string
empty.synchronized.statement.display.name:
  text: Empty 'synchronized' statement
unnecessary.default.display.name:
  text: Unnecessary 'default' for enum 'switch' statement
simplifiable.conditional.expression.display.name:
  text: Simplifiable conditional expression
simplifiable.if.statement.display.name:
  text: '''if'' statement may be replaced with \&\& or || expression'
unnecessary.super.constructor.display.name:
  text: Unnecessary call to 'super()'
unnecessarily.qualified.static.usage.display.name:
  text: Unnecessarily qualified static access
bad.exception.caught.display.name:
  text: Prohibited exception caught
custom.security.manager.display.name:
  text: Custom SecurityManager
string.concatenation.in.loops.display.name:
  text: String concatenation in loop
boolean.constructor.display.name:
  text: Boolean constructor call
continue.statement.display.name:
  text: '''continue'' statement'
extends.object.display.name:
  text: Class explicitly extends 'java.lang.Object'
serializable.inner.class.has.serial.version.uid.field.display.name:
  text: Serializable non-'static' inner class without 'serialVersionUID'
static.method.naming.convention.display.name:
  text: '''static'' method naming convention'
static.method.naming.convention.element.description:
  text: '''static'' method'
empty.try.block.display.name:
  text: Empty 'try' block
field.has.setter.but.no.getter.display.name:
  text: Field has setter but no getter
three.negations.per.method.display.name:
  text: Method with more than three negations
conditional.expression.display.name:
  text: Conditional expression (?:)
unnecessary.enum.modifier.display.name:
  text: Unnecessary enum modifier
string.equals.empty.string.display.name:
  text: '''String.equals("")'''
synchronize.on.lock.display.name:
  text: Synchronization on a Lock object
synchronized.on.literal.object.name:
  text: Synchronization on an object initialized with a literal
field.may.be.static.display.name:
  text: Field may be 'static'
class.may.be.interface.display.name:
  text: Abstract class may be interface
abstract.class.without.abstract.methods.display.name:
  text: Abstract class without abstract methods
divide.by.zero.display.name:
  text: Divide by zero
default.not.last.case.in.switch.display.name:
  text: '''default'' not last case in ''switch'' statement'
nested.synchronized.statement.display.name:
  text: Nested 'synchronized' statement
constant.conditional.expression.display.name:
  text: Constant conditional expression
unused.catch.parameter.display.name:
  text: Unused 'catch' parameter
redundant.else.display.name:
  text: Redundant 'else'
public.field.accessed.in.synchronized.context.display.name:
  text: Non-private field accessed in synchronized context
string.replaceable.by.string.buffer.display.name:
  text: Non-constant String should be StringBuilder
junit.test.class.naming.convention.display.name:
  text: JUnit test class naming convention
junit.test.class.naming.convention.element.description:
  text: JUnit test class
method.coupling.display.name:
  text: Overly coupled method
collections.must.have.initial.capacity.display.name:
  text: Collection without initial capacity
anonymous.inner.class.display.name:
  text: Anonymous inner class
negated.conditional.display.name:
  text: Conditional expression with negated condition
non.reproducible.math.call.display.name:
  text: Non-reproducible call to 'java.lang.Math'
multiple.top.level.classes.in.file.display.name:
  text: Multiple top level classes in single file
set.replaceable.by.enum.set.display.name:
  text: Set replaceable with EnumSet
non.static.inner.class.in.secure.context.display.name:
  text: Non-'static' inner class in secure context
tail.recursion.display.name:
  text: Tail recursion
finally.block.cannot.complete.normally.display.name:
  text: '''finally'' block which can not complete normally'
non.atomic.operation.on.volatile.field.display.name:
  text: Non-atomic operation on volatile field
public.static.collection.field.display.name:
  text: '''public static'' collection field'
non.exception.name.ends.with.exception.display.name:
  text: Non-exception class name ends with 'Exception'
synchronized.method.display.name:
  text: '''synchronized'' method'
enumerated.constant.naming.convention.display.name:
  text: Enumerated constant naming convention
enumerated.constant.naming.convention.element.description:
  text: Enumerated constant
final.method.display.name:
  text: '''final'' method'
transient.field.in.non.serializable.class.display.name:
  text: Transient field in non-serializable class
bad.exception.thrown.display.name:
  text: Prohibited exception thrown
conditional.expression.with.identical.branches.display.name:
  text: Conditional expression with identical branches
conditional.can.be.pushed.inside.expression.display.name:
  text: Conditional can be pushed inside branch expression
conditional.can.be.pushed.inside.expression.option:
  text: Ignore when conditional will be only argument of a method call
conditional.can.be.pushed.inside.expression.quickfix:
  text: Push conditional expression inside branch
raw.use.of.parameterized.type.display.name:
  text: Raw use of parameterized class
standard.variable.names.display.name:
  text: Standard variable names
instance.variable.naming.convention.display.name:
  text: Instance field naming convention
instance.variable.naming.convention.element.description:
  text: Instance field
dollar.sign.in.name.display.name:
  text: Use of '$' in identifier
map.replaceable.by.enum.map.display.name:
  text: Map replaceable with EnumMap
extends.concrete.collection.display.name:
  text: Class explicitly extends a Collection class
continue.or.break.from.finally.block.display.name:
  text: '''continue'' or ''break'' inside ''finally'' block'
abstract.method.with.missing.implementations.display.name:
  text: Abstract method with missing implementations
object.allocation.in.loop.display.name:
  text: Object allocation in loop
wait.called.on.condition.display.name:
  text: '''wait()'' called on ''java.util.concurrent.locks.Condition'' object'
test.case.with.no.test.methods.display.name:
  text: JUnit test case with no tests
abstract.class.never.implemented.display.name:
  text: Abstract class which has no concrete subclass
interface.never.implemented.display.name:
  text: Interface which has no concrete subclass
constant.declared.in.interface.display.name:
  text: Constant declared in interface
exception.name.doesnt.end.with.exception.problem.descriptor:
  text: 'Exception class name <code>#ref</code> does not end with ''Exception'' #loc'
non.exception.name.ends.with.exception.problem.descriptor:
  text: 'Non-exception class name <code>#ref</code> ends with ''Exception'' #loc'
class.name.prefixed.with.package.name.problem.descriptor:
  text: 'Class name <code>#ref</code> begins with its package name #loc'
class.name.same.as.ancestor.name.problem.descriptor:
  text: 'Class name <code>#ref</code> is the same as one of its superclass'' names #loc'
method.name.same.as.class.name.problem.descriptor:
  text: 'Method name <code>#ref</code> is the same as its class name #loc'
method.name.same.as.parent.name.problem.descriptor:
  text: 'Method name <code>#ref</code> is the same as its parent class name #loc'
boolean.method.name.must.start.with.question.problem.descriptor:
  text: 'Boolean method name <code>#ref</code> does not start with question word #loc'
questionable.name.problem.descriptor:
  text: 'Questionable name <code>#ref</code> #loc'
confusing.main.method.problem.descriptor:
  text: 'Method named <code>#ref</code> without signature ''public static void main(String[])'' #loc'
upper.case.field.name.not.constant.problem.descriptor:
  text: 'Non-constant field <code>#ref</code> with constant-style name #loc'
dollar.sign.in.name.problem.descriptor:
  text: 'Identifier <code>#ref</code> contains ''$'' #loc'
integer.division.in.floating.point.context.problem.descriptor:
  text: '<code>#ref</code>: integer division in floating-point context #loc'
comparison.of.short.and.char.problem.descriptor:
  text: 'Equality comparison <code>#ref</code> of short and char values #loc'
big.decimal.equals.problem.descriptor:
  text: '<code>#ref()</code> between BigDecimal values should probably be ''compareTo()'' #loc'
divide.by.zero.problem.descriptor:
  text: 'Division by zero #loc'
non.reproducible.math.call.problem.descriptor:
  text: '<code>Math.#ref()</code> may produce non-reproducible results #loc'
constant.math.call.problem.descriptor:
  text: 'Constant call to <code>#ref()</code> can be simplified #loc'
floating.point.equality.problem.descriptor:
  text: '<code>#ref</code>: floating point values compared for exact equality #loc'
fallthru.in.switch.statement.problem.descriptor:
  text: 'Fallthrough in ''switch'' statement #loc'
switch.statements.without.default.problem.descriptor:
  text: '<code>#ref</code> statement without ''default'' branch #loc'
default.not.last.case.in.switch.problem.descriptor:
  text: '<code>#ref</code> branch not last case in ''switch'' statement #loc'
loop.statements.that.dont.loop.problem.descriptor:
  text: '<code>#ref</code> statement does not loop #loc'
conditional.expression.with.identical.branches.problem.descriptor:
  text: 'Conditional expression <code>#ref</code> with identical branches #loc'
conditional.can.be.pushed.inside.expression.problem.descriptor:
  text: 'Conditional expression can be pushed inside branch #loc'
if.statement.with.identical.branches.problem.descriptor:
  text: '<code>#ref</code> statement with identical branches #loc'
duplicate.condition.problem.descriptor:
  text: 'Duplicate condition <code>#ref</code> #loc'
duplicate.condition.ignore.method.calls.option:
  text: Ignore conditions with side effects
duplicate.boolean.branch.problem.descriptor:
  text: 'Duplicate branch <code>#ref</code> #loc'
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor:
  text: '<code>Iterator.#ref()</code> which can''t throw ''NoSuchElementException'' #loc'
infinite.loop.statement.problem.descriptor:
  text: '<code>#ref</code> statement cannot complete without throwing an exception #loc'
confusing.floating.point.literal.problem.descriptor:
  text: 'Confusing floating point literal <code>#ref</code> #loc'
overly.complex.arithmetic.expression.problem.descriptor:
  text: 'Overly complex arithmetic expression #loc'
overly.complex.boolean.expression.problem.descriptor:
  text: 'Overly complex boolean expression ({0} terms) #loc'
labeled.statement.problem.descriptor:
  text: 'Labeled statement <code>#ref:</code> #loc'
break.statement.with.label.problem.descriptor:
  text: '<code>#ref</code> statement with label #loc'
continue.statement.with.label.problem.descriptor:
  text: '<code>#ref</code> statement with label #loc'
conditional.expression.problem.descriptor:
  text: 'Conditional expression <code>#ref</code> #loc'
conditional.expression.option:
  text: Ignore for simple assignments and returns
nested.conditional.expression.problem.descriptor:
  text: 'Nested conditional expression <code>#ref</code> #loc'
long.literals.ending.with.lowercase.l.problem.descriptor:
  text: '''long'' literal <code>#ref</code> ends with lowercase ''l'' #loc'
nested.switch.statement.problem.descriptor:
  text: 'Nested <code>#ref</code> statement #loc'
chained.method.call.problem.descriptor:
  text: 'Chained method call <code>#ref()</code> #loc'
nested.method.call.problem.descriptor:
  text: 'Nested method call <code>#ref()</code> #loc'
octal.literal.problem.descriptor:
  text: 'Octal integer <code>#ref</code> #loc'
implicit.call.to.super.problem.descriptor:
  text: 'Implicit call to ''super()'' #loc'
negated.if.else.problem.descriptor:
  text: '<code>#ref</code> statement with negated condition #loc'
negated.conditional.problem.descriptor:
  text: 'Conditional expression with negated condition #loc'
redundant.else.problem.descriptor:
  text: '<code>#ref</code> branch may be unwrapped, as the ''if'' branch never completes normally #loc'
switch.statement.with.confusing.declaration.problem.descriptor:
  text: 'Local variable <code>#ref</code> declared in one ''switch'' branch and used in another #loc'
raw.use.of.parameterized.type.problem.descriptor:
  text: 'Raw use of parameterized class <code>#ref</code> #loc'
final.class.problem.descriptor:
  text: 'Class declared <code>#ref</code> #loc'
empty.class.problem.descriptor:
  text: 'Class <code>#ref</code> is empty #loc'
empty.class.file.without.class.problem.descriptor:
  text: 'Java file does not declare any class #loc'
empty.anonymous.class.problem.descriptor:
  text: 'Anonymous class is empty #loc'
anonymous.inner.class.problem.descriptor:
  text: 'Anonymous inner class <code>#ref</code> #loc'
limited.scope.inner.class.problem.descriptor:
  text: 'Limited-scope inner class <code>#ref</code> #loc'
final.method.problem.descriptor:
  text: 'Method declared <code>#ref</code> #loc'
class.initializer.problem.descriptor:
  text: 'Non-''static'' initializer #loc'
class.may.be.interface.problem.descriptor:
  text: 'Abstract class <code>#ref</code> may be interface #loc'
non.protected.constructor.in.abstract.class.problem.descriptor:
  text: 'Constructor <code>#ref()</code> is not declared ''protected'' in ''abstract'' class #loc'
class.without.constructor.problem.descriptor:
  text: 'Class <code>#ref</code> has no constructor #loc'
abstract.class.without.abstract.methods.problem.descriptor:
  text: 'Class <code>#ref</code> is declared ''abstract'', and has no ''abstract'' methods #loc'
final.method.in.final.class.problem.descriptor:
  text: 'Method declared <code>#ref</code> in ''final'' class #loc'
protected.member.in.final.class.problem.descriptor:
  text: 'Class member declared <code>#ref</code> in ''final'' class #loc'
utility.class.with.public.constructor.problem.descriptor:
  text: 'Class <code>#ref</code> has only ''static'' members, and a ''public'' constructor #loc'
utility.class.without.private.constructor.problem.descriptor:
  text: 'Class <code>#ref</code> has only ''static'' members, and lacks a ''private'' constructor #loc'
abstract.method.overrides.concrete.method.problem.descriptor:
  text: 'Abstract method <code>#ref()</code> overrides concrete method #loc'
abstract.method.with.missing.implementations.problem.descriptor:
  text: 'Abstract method <code>#ref()</code> is not implemented in every subclass #loc'
abstract.method.overrides.abstract.method.problem.descriptor:
  text: 'Abstract method <code>#ref()</code> overrides abstract method #loc'
abstract.method.overrides.abstract.method.ignore.different.javadoc.option:
  text: Ignore methods with different Javadoc than their super methods
abstract.method.overrides.abstract.method.ignore.different.annotations.option:
  text: Ignore methods with different annotations than their super methods
abstract.class.extends.concrete.class.problem.descriptor:
  text: 'Class <code>#ref</code> is declared ''abstract'', and extends a concrete class #loc'
static.non.final.field.problem.descriptor:
  text: '''static'' non-''final'' field <code>#ref</code> #loc'
constant.declared.in.abstract.class.problem.descriptor:
  text: 'Constant <code>#ref</code> declared in abstract class #loc'
constant.declared.in.interface.problem.descriptor:
  text: 'Constant <code>#ref</code> declared in interface #loc'
static.inheritance.problem.descriptor:
  text: 'Interface <code>#ref</code> is implemented only for its ''static'' constants #loc'
utility.class.problem.descriptor:
  text: 'Class <code>#ref</code> has only ''static'' members, indicating procedural construction #loc'
singleton.problem.descriptor:
  text: 'Class <code>#ref</code> is a singleton #loc'
final.private.method.problem.descriptor:
  text: '''private'' method declared <code>#ref</code> #loc'
noop.method.in.abstract.class.problem.descriptor:
  text: 'No-op Method <code>#ref()</code> should be made abstract #loc'
final.static.method.problem.descriptor:
  text: '''static'' method declared <code>#ref</code> #loc'
class.without.no.arg.constructor.problem.descriptor:
  text: '<code>#ref</code> has no no-arg constructor #loc'
multiple.top.level.classes.in.file.problem.descriptor:
  text: Multiple top level classes in file
class.name.differs.from.file.name.problem.descriptor:
  text: 'Class name <code>#ref</code> differs from file name #loc'
marker.interface.problem.descriptor:
  text: 'Marker interface <code>#ref</code> #loc'
field.has.setter.but.no.getter.problem.descriptor:
  text: 'Field <code>#ref</code> has setter but no getter #loc'
abstract.class.never.implemented.problem.descriptor:
  text: 'Abstract class <code>#ref</code> has no concrete subclass #loc'
interface.never.implemented.problem.descriptor:
  text: 'Interface <code>#ref</code> has no concrete subclass #loc'
missing.deprecated.annotation.problem.descriptor:
  text: 'Missing ''@Deprecated'' annotation #loc'
missing.deprecated.tag.problem.descriptor:
  text: 'Missing ''@deprecated'' Javadoc tag explanation #loc'
missing.deprecated.tag.option:
  text: Warn on missing @deprecated Javadoc tag explanation
missing.override.annotation.problem.descriptor:
  text: 'Missing ''@Override'' annotation on <code>#ref()</code> #loc'
non.thread.safe.lazy.initialization.problem.descriptor:
  text: 'Lazy initialization of ''static'' field <code>#ref</code> is not thread-safe #loc'
empty.catch.block.problem.descriptor:
  text: 'Empty <code>#ref</code> block #loc'
unused.catch.parameter.problem.descriptor:
  text: 'Unused ''catch'' parameter <code>#ref</code> #loc'
used.catch.parameter.named.ignore.problem.descriptor:
  text: '''catch'' parameter named <code>#ref</code> is used #loc'
empty.finally.block.problem.descriptor:
  text: 'Empty <code>#ref</code> block #loc'
finally.block.cannot.complete.normally.problem.descriptor:
  text: '<code>#ref</code> block can not complete normally #loc'
empty.try.block.problem.descriptor:
  text: 'Empty <code>#ref</code> block #loc'
throw.from.finally.block.problem.descriptor:
  text: '<code>#ref</code> inside ''finally'' block #loc'
possible.throw.from.finally.block.problem.descriptor:
  text: '<code>{0}</code> might be thrown inside ''''finally'''' block #loc'
throw.from.finally.block.everywhere.option:
  text: Warn everywhere declared exceptions may be thrown
throw.caught.locally.problem.descriptor:
  text: '<code>#ref</code> caught by containing ''try'' statement #loc'
throw.caught.locally.ignore.option:
  text: Ignore rethrown exceptions
return.from.finally.block.problem.descriptor:
  text: '<code>#ref</code> inside ''finally'' block #loc'
continue.or.break.from.finally.block.problem.descriptor:
  text: '<code>#ref</code> inside ''finally'' block #loc'
bad.exception.declared.problem.descriptor:
  text: 'Prohibited exception <code>#ref</code> declared #loc'
bad.exception.caught.problem.descriptor:
  text: 'Prohibited exception <code>#ref</code> caught #loc'
checked.exception.class.problem.descriptor:
  text: 'Checked exception class <code>#ref</code> #loc'
unchecked.exception.class.problem.descriptor:
  text: 'Unchecked exception class <code>#ref</code> #loc'
thread.death.rethrown.problem.descriptor:
  text: 'ThreadDeath <code>#ref</code> not rethrown #loc'
error.rethrown.problem.descriptor:
  text: 'Error <code>#ref</code> not rethrown #loc'
nested.try.statement.problem.descriptor:
  text: 'Nested <code>#ref</code> statement #loc'
exception.from.catch.which.doesnt.wrap.problem.descriptor:
  text: '<code>#ref</code> inside ''catch'' block ignores the caught exception #loc'
instanceof.catch.parameter.problem.descriptor:
  text: '''instanceof'' on ''catch'' parameter <code>#ref</code> #loc'
non.final.field.of.exception.problem.descriptor:
  text: 'Non-final field <code>#ref</code> of exception class #loc'
unnecessary.label.on.break.statement.problem.descriptor:
  text: 'Unnecessary label on <code>#ref</code> statement #loc'
unnecessary.label.on.continue.statement.problem.descriptor:
  text: 'Unnecessary label on <code>#ref</code> statement #loc'
trivial.if.problem.descriptor:
  text: '<code>#ref</code> statement can be simplified #loc'
constant.if.statement.problem.descriptor:
  text: '<code>#ref</code> statement can be simplified #loc'
unnecessary.parentheses.problem.descriptor:
  text: 'Parentheses around <code>#ref</code> are unnecessary #loc'
unnecessary.local.variable.problem.descriptor:
  text: 'Local variable <code>#ref</code> is redundant #loc'
unnecessary.this.problem.descriptor:
  text: '<code>#ref</code> is unnecessary in this context #loc'
unnecessary.block.statement.problem.descriptor:
  text: 'Braces around this statement are unnecessary #loc'
unnecessary.continue.problem.descriptor:
  text: '<code>#ref</code> is unnecessary as the last statement in a loop #loc'
unnecessary.semicolon.problem.descriptor:
  text: 'Unnecessary semicolon <code>#ref</code> #loc'
unnecessary.fully.qualified.name.problem.descriptor1:
  text: 'Qualifier <code>#ref</code> is unnecessary, and can be replaced with an import #loc'
unnecessary.fully.qualified.name.problem.descriptor2:
  text: 'Qualifier <code>#ref</code> is unnecessary and can be removed #loc'
unnecessary.qualifier.for.this.problem.descriptor:
  text: 'Qualifier <code>#ref</code> on ''this'' is unnecessary in this context #loc'
unnecessary.qualifier.for.super.problem.descriptor:
  text: 'Qualifier <code>#ref</code> on ''super'' is unnecessary in this context #loc'
unused.label.problem.descriptor:
  text: 'Unused label <code>#ref</code> #loc'
redundant.field.initialization.problem.descriptor:
  text: 'Field initialization to <code>#ref</code> is redundant #loc'
redundant.implements.problem.descriptor:
  text: 'Redundant interface declaration <code>#ref</code> #loc'
extends.object.problem.descriptor:
  text: 'Class <code>#ref</code> explicitly extends ''java.lang.Object'' #loc'
type.parameter.extends.object.problem.descriptor1:
  text: 'Type parameter <code>#ref</code> explicitly extends ''java.lang.Object'' #loc'
type.parameter.extends.object.problem.descriptor2:
  text: 'Wildcard type argument <code>#ref</code> explicitly extends ''java.lang.Object'' #loc'
unnecessary.super.constructor.problem.descriptor:
  text: '<code>#ref</code> is unnecessary #loc'
unnecessary.constructor.problem.descriptor:
  text: 'No-arg constructor <code>#ref()</code> is redundant #loc'
unnecessary.constructor.annotation.option:
  text: Ignore constructors with an annotation
for.loop.replaceable.by.while.problem.descriptor:
  text: '<code>#ref</code> loop statement may be replace by ''while'' loop #loc'
unnecessary.default.problem.descriptor:
  text: '<code>#ref</code> branch is unnecessary #loc'
unnecessary.boxing.problem.descriptor:
  text: 'Unnecessary boxing <code>#ref</code> #loc'
unnecessary.unboxing.problem.descriptor:
  text: 'Unnecessary unboxing <code>#ref</code> #loc'
unnecessary.boxing.superfluous.option:
  text: Only report truly superfluously boxed expressions
unnecessary.unboxing.superfluous.option:
  text: Only report truly superfluously unboxed expressions
for.can.be.foreach.problem.descriptor:
  text: '<code>#ref</code> loop replaceable with ''foreach'' #loc'
while.can.be.foreach.problem.descriptor:
  text: '<code>#ref</code> loop replaceable with ''foreach'' #loc'
too.broad.scope.problem.descriptor:
  text: 'Scope of variable <code>#ref</code> is too broad #loc'
return.this.problem.descriptor:
  text: 'Return of <code>#ref</code> #loc'
constant.on.lhs.of.comparison.problem.descriptor:
  text: '<code>#ref</code>: constant on left side of comparison #loc'
constant.on.rhs.of.comparison.problem.descriptor:
  text: '<code>#ref</code>: constant on right side of comparison #loc'
control.flow.statement.without.braces.problem.descriptor:
  text: '<code>{0}</code> without braces #loc'
missorted.modifiers.problem.descriptor:
  text: 'Missorted modifiers <code>#ref</code> #loc'
cstyle.array.variable.declaration.problem.descriptor:
  text: 'C-style array declaration of {0, choice, 1#field|2#parameter|3#local variable} <code>#ref</code> #loc'
cstyle.array.method.declaration.problem.descriptor:
  text: C-style array declaration of the return type of method <code>#ref()</code>#loc
multiple.declaration.problem.descriptor:
  text: 'Multiple variables in one declaration #loc'
multiple.typed.declaration.problem.descriptor:
  text: 'Variables of different types in one declaration #loc'
serializable.inner.class.has.serial.version.uid.field.problem.descriptor:
  text: 'Inner class <code>#ref</code> does not define a ''serialVersionUID'' field #loc'
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor:
  text: 'Inner class <code>#ref</code> is serializable while its outer class is not #loc'
busy.wait.problem.descriptor:
  text: 'Call to <code>Thread.#ref()</code> in a loop, probably busy-waiting #loc'
sleep.while.holding.lock.problem.descriptor:
  text: 'Call to <code>Thread.#ref()</code> while synchronized #loc'
non.atomic.operation.on.volatile.field.problem.descriptor:
  text: 'Non-atomic operation on volatile field <code>#ref</code> #loc'
call.to.native.method.while.locked.problem.descriptor:
  text: 'Call to native method <code>#ref()</code> in a synchronized context #loc'
object.notify.problem.descriptor:
  text: '<code>#ref</code> should probably be replaced with ''notifyAll()'' #loc'
condition.signal.problem.descriptor:
  text: '<code>#ref</code> should probably be replaced with ''signalAll()'' #loc'
thread.with.default.run.method.problem.descriptor:
  text: 'Instantiating a <code>#ref</code> with default ''run()'' method #loc'
extends.thread.problem.descriptor:
  text: 'Class <code>#ref</code> directly extends ''java.lang.Thread'' #loc'
anonymous.extends.thread.problem.descriptor:
  text: 'Anonymous class directly extends ''java.lang.Thread'' #loc'
naked.notify.problem.descriptor:
  text: 'Call to <code>#ref()</code> without corresponding state change #loc'
unconditional.wait.problem.descriptor:
  text: 'Unconditional call to <code>#ref()</code> #loc'
system.run.finalizers.on.exit.problem.descriptor:
  text: 'Call to <code>System.#ref()</code> #loc'
thread.priority.problem.descriptor:
  text: 'Call to <code>Thread.#ref()</code> #loc'
thread.yield.problem.descriptor:
  text: 'Call to <code>Thread.#ref()</code> #loc'
thread.stop.suspend.resume.problem.descriptor:
  text: 'Call to <code>Thread.#ref()</code> #loc'
while.loop.spins.on.field.problem.descriptor:
  text: '<code>#ref</code> loop spins on field #loc'
wait.not.in.loop.problem.descriptor:
  text: 'Call to <code>#ref()</code> is not made in a loop #loc'
await.not.in.loop.problem.descriptor:
  text: 'Call to <code>#ref()</code> is not made in a loop #loc'
wait.called.on.condition.problem.descriptor:
  text: 'Call to <code>#ref()</code> on Condition object #loc'
notify.called.on.condition.problem.descriptor:
  text: 'Call to <code>#ref()</code> on Condition object #loc'
wait.while.holding.two.locks.problem.descriptor:
  text: 'Call to <code>#ref()</code> is made while holding two locks #loc'
thread.run.problem.descriptor:
  text: 'Calls to <code>#ref()</code> should probably be replaced with ''start()'' #loc'
thread.start.in.construction.problem.descriptor:
  text: 'Call to <code>#ref</code> during object construction #loc'
synchronize.on.lock.problem.descriptor:
  text: 'Synchronization on a ''''{0}'''' object is unlikely to be intentional #loc'
synchronized.on.literal.object.problem.descriptor:
  text: 'Synchronization on {0} <code>#ref</code> which is initialized by a literal #loc'
synchronized.on.direct.literal.object.problem.descriptor:
  text: 'Synchronization on {0} literal <code>#ref</code> #loc'
synchronized.on.possibly.literal.object.problem.descriptor:
  text: 'Synchronization on {0} <code>#ref</code> #loc'
synchronize.on.non.final.field.problem.descriptor:
  text: 'Synchronization on a non-final field <code>#ref</code> #loc'
synchronized.on.literal.object.warn.on.all.option:
  text: Warn on all possible literals
synchronize.on.this.problem.descriptor:
  text: 'Lock operations on ''this'' may have unforeseen side-effects #loc'
synchronize.on.class.problem.descriptor:
  text: 'Lock operations on a class may have unforeseen side-effects #loc'
nested.synchronized.statement.problem.descriptor:
  text: 'Nested <code>#ref</code> statement #loc'
empty.synchronized.statement.problem.descriptor:
  text: 'Empty <code>#ref</code> statement #loc'
non.synchronized.method.overrides.synchronized.method.problem.descriptor:
  text: 'Unsynchronized method <code>#ref()</code> overrides synchronized method #loc'
public.field.accessed.in.synchronized.context.problem.descriptor:
  text: 'Non-private field <code>#ref</code> accessed in synchronized context  #loc'
field.accessed.synchronized.and.unsynchronized.problem.descriptor:
  text: 'Field <code>#ref</code> is accessed in both synchronized and unsynchronized contexts #loc'
extended.for.statement.problem.descriptor:
  text: 'Extended <code>#ref</code> statement #loc'
object.allocation.in.loop.problem.descriptor:
  text: 'Object allocation <code>new #ref()</code> in loop #loc'
instantiating.object.to.get.class.object.problem.descriptor:
  text: 'Instantiating object to get Class object #loc'
field.may.be.static.problem.descriptor:
  text: 'Field <code>#ref</code> may be ''static'' #loc'
method.may.be.static.problem.descriptor:
  text: 'Method <code>#ref()</code> may be ''static'' #loc'
class.initializer.may.be.static.problem.descriptor:
  text: 'Class initializer may be ''static'' #loc'
map.replaceable.by.enum.map.problem.descriptor:
  text: '<code>#ref</code> replaceable with ''EnumMap'' #loc'
set.replaceable.by.enum.set.problem.descriptor:
  text: '<code>#ref</code> replaceable with ''EnumSet'' #loc'
inner.class.may.be.static.problem.descriptor:
  text: 'Inner class <code>#ref</code> may be ''static'' #loc'
string.buffer.must.have.initial.capacity.problem.descriptor:
  text: '<code>new #ref()</code> without initial capacity #loc'
string.buffer.replaceable.by.string.builder.problem.descriptor:
  text: '<code>StringBuffer #ref</code> may be declared as ''StringBuilder'' #loc'
string.buffer.replaceable.by.string.problem.descriptor:
  text: '<code>{0} #ref</code> can be replaced with ''''String'''' #loc'
new.string.buffer.replaceable.by.string.problem.descriptor:
  text: '<code>#ref</code> can be replaced with ''String'' #loc'
string.replaceable.by.string.buffer.problem.descriptor:
  text: 'Non-constant <code>String #ref</code> should probably be declared as ''''StringBuilder'''' #loc'
collections.must.have.initial.capacity.problem.descriptor:
  text: '<code>new #ref()</code> without initial capacity #loc'
string.concatenation.in.loops.problem.descriptor:
  text: 'String concatenation <code>#ref</code> in loop #loc'
string.concatenation.inside.string.buffer.append.problem.descriptor:
  text: 'String concatenation as argument to <code>{0}.#ref()</code> call #loc'
boolean.constructor.problem.descriptor:
  text: 'Boolean constructor call #loc'
string.to.string.problem.descriptor:
  text: '<code>#ref</code> is redundant #loc'
substring.zero.problem.descriptor:
  text: '<code>#ref</code> is redundant #loc'
string.buffer.to.string.in.concatenation.problem.descriptor:
  text: 'Calls to <code>StringBuffer.#ref()</code> in concatenation #loc'
tail.recursion.problem.descriptor:
  text: 'Tail recursive call <code>#ref()</code> #loc'
string.equals.empty.string.problem.descriptor:
  text: '<code>#ref("")</code> can be replaced with ''length()==0'' #loc'
string.equals.empty.string.is.empty.problem.descriptor:
  text: '<code>#ref("")</code> can be replaced with ''isEmpty()'' #loc'
random.double.for.random.integer.problem.descriptor:
  text: 'Using <code>Random.#ref</code> to create random integer #loc'
manual.array.copy.problem.descriptor:
  text: 'Manual array copy #loc'
manual.array.to.collection.copy.problem.descriptor:
  text: 'Manual array to collection copy #loc'
call.to.simple.getter.in.class.problem.descriptor:
  text: 'Call to simple getter <code>#ref()</code> from within class #loc'
call.to.simple.setter.in.class.problem.descriptor:
  text: 'Call to simple setter <code>#ref()</code> from within class #loc'
asserts.without.messages.problem.descriptor:
  text: 'JUnit <code>#ref()</code> without message #loc'
test.case.with.constructor.problem.descriptor:
  text: 'Initialization logic in constructor <code>#ref()</code> instead of ''setUp()'' #loc'
test.case.with.constructor.problem.descriptor.initializer:
  text: Initialization logic in initializer instead of 'setUp()'
misordered.assert.equals.arguments.problem.descriptor:
  text: 'Arguments to <code>#ref()</code> in wrong order #loc'
static.suite.problem.descriptor:
  text: 'JUnit <code>#ref()</code> methods not declared ''static'' #loc'
simplifiable.junit.assertion.problem.descriptor:
  text: '<code>#ref()</code> can be simplified to ''''{0}'''' #loc'
test.method.without.assertion.problem.descriptor:
  text: 'JUnit test method <code>#ref()</code> contains no assertions #loc'
test.case.with.no.test.methods.problem.descriptor:
  text: 'JUnit test case <code>#ref</code> has no tests #loc'
test.case.in.product.code.problem.descriptor:
  text: 'Test case <code>#ref</code> should probably be placed in a test source tree #loc'
test.method.in.product.code.problem.descriptor:
  text: 'Test method <code>#ref()</code> should probably be placed in a test source tree #loc'
unconstructable.test.case.problem.descriptor:
  text: 'Test case <code>#ref</code> is not constructable by most test runners #loc'
deserializable.class.in.secure.context.problem.descriptor:
  text: 'Class <code>#ref</code> may be deserialized, compromising security #loc'
serializable.class.in.secure.context.problem.descriptor:
  text: 'Class <code>#ref</code> may be serialized, compromising security #loc'
cloneable.class.in.secure.context.problem.descriptor:
  text: 'Class <code>#ref</code> may be cloned, compromising security #loc'
non.final.clone.problem.descriptor:
  text: 'Non-final <code>#ref()</code> method, compromising security #loc'
non.static.inner.class.in.secure.context.problem.descriptor:
  text: 'Non-''static'' inner class <code>#ref</code>, compromising security #loc'
runtime.exec.with.non.constant.string.problem.descriptor:
  text: 'Call to <code>Runtime.#ref()</code> with non-constant argument #loc'
load.library.with.non.constant.string.problem.descriptor:
  text: 'Call to <code>{0}.#ref()</code> with non-constant argument #loc'
jdbc.execute.with.non.constant.string.problem.descriptor:
  text: 'Call to <code>Statement.#ref()</code> with non-constant argument #loc'
jdbc.prepare.statement.with.non.constant.string.problem.descriptor:
  text: 'Call to <code>Connection.#ref()</code> with non-constant argument #loc'
custom.classloader.problem.descriptor:
  text: 'Custom ClassLoader class <code>#ref</code> #loc'
custom.security.manager.problem.descriptor:
  text: 'Custom SecurityManager class <code>#ref</code> #loc'
system.set.problem.descriptor:
  text: 'Call to <code>System.#ref()</code> may pose security concerns #loc'
class.loader.instantiation.problem.descriptor:
  text: 'Instantiation of <code>#ref</code> may pose security concerns #loc'
public.static.array.field.problem.descriptor:
  text: '''public static'' array field <code>#ref</code>, compromising security #loc'
public.static.collection.field.problem.descriptor:
  text: '''public static'' collection field <code>#ref</code>, compromising security #loc'
abstract.class.with.only.one.direct.inheritor.problem.descriptor:
  text: 'Abstract class <code>#ref</code> has only one direct inheritor #loc'
abstract.method.overrides.abstract.method.remove.quickfix:
  text: Remove redundant abstract method declaration
class.may.be.interface.convert.quickfix:
  text: Convert class to interface
class.without.constructor.create.quickfix:
  text: Generate empty constructor
class.without.no.arg.constructor.ignore.option:
  text: Ignore if class has default constructor
extends.annotation.problem.descriptor:
  text: 'Class ''''{0}'''' implements annotation interface <code>#ref</code> #loc'
extends.annotation.interface.problem.descriptor:
  text: 'Interface ''''{0}'''' extends annotation interface <code>#ref</code> #loc'
extends.concrete.collection.problem.descriptor:
  text: 'Class <code>#ref</code> explicitly extends ''''{0}'''' #loc'
anonymous.extends.concrete.collection.problem.descriptor:
  text: 'Anonymous class explicitly extends ''''{0}'''' #loc'
inner.class.on.interface.ignore.option:
  text: Ignore inner interfaces of interfaces
inner.class.on.interface.problem.descriptor:
  text: 'Interface ''''{0}'''' has inner class <code>#ref</code> #loc'
missing.deprecated.annotation.add.quickfix:
  text: Add @Deprecated annotation
missing.override.annotation.add.quickfix:
  text: Add @Override annotation
non.protected.constructor.in.abstract.class.ignore.option:
  text: Ignore for non-public classes
public.constructor.in.non.public.class.problem.descriptor:
  text: 'Constructor is declared <code>#ref</code> in non-public class ''''{0}'''' #loc'
static.inheritance.replace.quickfix:
  text: Replace inheritance with qualified references in {0}
utility.class.with.public.constructor.make.quickfix:
  text: Make {0, choice, 1#constructor|2#constructors} 'private'
utility.class.without.private.constructor.create.quickfix:
  text: Generate empty 'private' constructor
utility.class.without.private.constructor.make.quickfix:
  text: Make constructor 'private'
naming.convention.problem.descriptor.short:
  text: '{0} name <code>#ref</code> is too short ({1} < {2}) #loc'
naming.convention.problem.descriptor.long:
  text: '{0} name <code>#ref</code> is too long ({1} > {2}) #loc'
naming.convention.problem.descriptor.regex.mismatch:
  text: '{0} name <code>#ref</code> doesn''''t match regex ''''{1}'''' #loc'
constant.naming.convention.immutables.option:
  text: Only check 'static final' fields with immutable types
local.variable.naming.convention.ignore.option:
  text: Ignore for-loop parameters
local.variable.naming.convention.ignore.catch.option:
  text: Ignore 'catch' block parameters
method.names.differ.only.by.case.problem.descriptor:
  text: 'Method name <code>#ref</code> and method name ''''{0}'''' differ only by case #loc'
parameter.name.differs.from.overridden.parameter.ignore.character.option:
  text: Ignore if overridden parameter contains only one character
parameter.name.differs.from.overridden.parameter.ignore.library.option:
  text: Ignore if overridden parameter is from a library
parameter.name.differs.from.overridden.parameter.problem.descriptor:
  text: 'Parameter name <code>#ref</code> is different from parameter ''''{0}'''' overridden #loc'
questionable.name.column.title:
  text: Name
standard.variable.names.problem.descriptor:
  text: 'Variable named <code>#ref</code> doesn''''t have type ''''{0}'''' #loc'
standard.variable.names.problem.descriptor2:
  text: 'Variable named <code>#ref</code> doesn''''t have type ''''{0}'''' or ''''{1}'''' #loc'
standard.variable.names.ignore.override.option:
  text: Ignore for parameter names identical to super method parameters
static.variable.naming.convention.mutable.option:
  text: Check 'static final' fields with a mutable type
boolean.method.name.must.start.with.question.table.column.name:
  text: Boolean method name prefix
conditional.expression.with.identical.branches.collapse.quickfix:
  text: Collapse conditional expression
redundant.else.unwrap.quickfix:
  text: Remove redundant 'else'
constant.conditional.expression.problem.descriptor:
  text: '<code>#ref</code> can be simplified to ''''{0}'''' #loc'
constant.conditional.expression.simplify.quickfix:
  text: Simplify
enum.switch.statement.which.misses.cases.problem.descriptor:
  text: '<code>#ref</code> statement on enumerated type ''''{0}'''' misses cases #loc'
for.loop.replaceable.by.while.ignore.option:
  text: Ignore 'infinite' for loops without conditions
for.loop.replaceable.by.while.replace.quickfix:
  text: Replace with 'while'
for.loop.with.missing.component.problem.descriptor1:
  text: '<code>#ref</code> statement lacks initializer #loc'
for.loop.with.missing.component.problem.descriptor2:
  text: '<code>#ref</code> statement lacks condition #loc'
for.loop.with.missing.component.problem.descriptor3:
  text: '<code>#ref</code> statement lacks update #loc'
for.loop.with.missing.component.problem.descriptor4:
  text: '<code>#ref</code> statement lacks initializer and condition #loc'
for.loop.with.missing.component.problem.descriptor5:
  text: '<code>#ref</code> statement lacks initializer and update #loc'
for.loop.with.missing.component.problem.descriptor6:
  text: '<code>#ref</code> statement lacks condition and update #loc'
for.loop.with.missing.component.problem.descriptor7:
  text: '<code>#ref</code> statement lacks initializer, condition and update #loc'
if.statement.with.identical.branches.collapse.quickfix:
  text: Collapse 'if' statement
foreach.replace.quickfix:
  text: Replace with 'foreach'
unnecessary.boxing.remove.quickfix:
  text: Remove boxing
unnecessary.unboxing.remove.quickfix:
  text: Remove unboxing
misordered.assert.equals.arguments.flip.quickfix:
  text: Flip compared arguments
simplify.junit.assertion.simplify.quickfix:
  text: Simplify assertion
test.method.is.public.void.no.arg.problem.descriptor1:
  text: 'Test method <code>#ref()</code> should probably not have parameters #loc'
test.method.is.public.void.no.arg.problem.descriptor2:
  text: 'Test method <code>#ref()</code> is not declared ''public void'' #loc'
test.method.is.public.void.no.arg.problem.descriptor3:
  text: 'Test method <code>#ref()</code> should not be ''static'' #loc'
system.properties.problem.descriptor:
  text: 'Call to <code>Integer.#ref()</code> may pose security concerns #loc'
system.properties.problem.descriptor1:
  text: 'Call to <code>Boolean.#ref()</code> may pose security concerns #loc'
unsecure.random.number.generation.problem.descriptor1:
  text: 'For security purposes, use ''java.security.SecureRandom'' instead of <code>java.lang.Math.#ref()</code> #loc'
unsecure.random.number.generation.problem.descriptor2:
  text: 'For security purposes, use ''java.security.SecureRandom'' instead of <code>java.util.#ref</code> #loc'
unsecure.random.number.generation.problem.descriptor3:
  text: 'For security purposes, use ''java.security.SecureRandom'' instead of <code>#ref</code> #loc'
serializable.has.serialization.methods.problem.descriptor:
  text: 'Serializable class <code>#ref</code> does not define ''readObject()'' or ''writeObject()'' #loc'
serializable.has.serialization.methods.problem.descriptor1:
  text: 'Serializable class <code>#ref</code> does not define ''writeObject()'' #loc'
serializable.has.serialization.methods.problem.descriptor2:
  text: 'Serializable class <code>#ref</code> does not define ''readObject()'' #loc'
serializable.with.unconstructable.ancestor.problem.descriptor:
  text: '<code>#ref</code> has a non-serializable ancestor ''''{0}'''' without no-arg constructor #loc'
transient.field.in.non.serializable.class.problem.descriptor:
  text: 'Field ''''{0}'''' is marked <code>#ref</code>, in non-Serializable class #loc'
transient.field.in.non.serializable.class.remove.quickfix:
  text: Remove 'transient'
condition.signal.replace.quickfix:
  text: Replace with 'signalAll()'
object.notify.replace.quickfix:
  text: Replace with 'notifyAll()'
safe.lock.problem.descriptor:
  text: '''''{0}'''' should be locked in front of a ''''try'''' block and unlocked in the corresponding ''''finally'''' block #loc'
synchronized.method.problem.descriptor:
  text: 'Method ''''{0}()'''' declared <code>#ref</code> #loc'
synchronized.method.include.option:
  text: Include native methods
synchronized.method.ignore.synchronized.super.option:
  text: Ignore methods overriding a synchronized method
synchronized.method.move.quickfix:
  text: Move synchronization into method
thread.run.replace.quickfix:
  text: Replace with 'start()'
volatile.field.problem.descriptor:
  text: 'Volatile field <code>#ref</code> of type ''''{0}'''' #loc'
string.format.choose.class:
  text: Choose Formatter class
string.format.class.column.name:
  text: Additional formatter classes
string.format.class.method.name:
  text: Additional formatter methods
exception.class.column.name:
  text: Exception class
bad.exception.thrown.problem.descriptor:
  text: 'Prohibited exception ''''{0}'''' thrown #loc'
empty.catch.block.comments.option:
  text: Comments count as content
empty.catch.block.ignore.ignore.option:
  text: Ignore when 'catch' parameter is named 'ignore' or 'ignored'
too.broad.catch.problem.descriptor:
  text: '''''catch'''' of <code>#ref</code> is too broad, masking exception ''''{0}'''' #loc'
too.broad.catch.problem.descriptor1:
  text: '''''catch'''' of <code>#ref</code> is too broad, masking exceptions ''''{0}'''' and ''''{1}'''' #loc'
unused.catch.parameter.ignore.catch.option:
  text: Ignore when 'catch' block contains a comment
add.serialversionuidfield.quickfix:
  text: Add 'serialVersionUID' field
delete.import.quickfix:
  text: Delete unnecessary import
encapsulate.variable.quickfix:
  text: Encapsulate field ''{0}''
extract.method.quickfix:
  text: Extract method
inline.call.quickfix:
  text: Inline call
inline.variable.quickfix:
  text: Inline variable
pointless.nullcheck.display.name:
  text: Unnecessary 'null' check before 'instanceof' expression
pointless.nullcheck.problem.descriptor:
  text: Unnecessary 'null' check before 'instanceof' expression
pointless.nullcheck.after.problem.descriptor:
  text: Unnecessary 'null' check after 'instanceof' expression
pointless.nullcheck.simplify.quickfix:
  text: Remove unnecessary ''{0}'' condition
introduce.constant.quickfix:
  text: Introduce constant
make.initialization.explicit.quickfix:
  text: Make initialization explicit
move.anonymous.to.inner.quickfix:
  text: Convert to named inner class
anonymous.inner.may.be.named.static.inner.class.quickfix:
  text: Convert to named 'static' inner class
move.class.quickfix:
  text: Move class
normalize.declaration.quickfix:
  text: Split into multiple declarations
remove.modifier.quickfix:
  text: Remove ''{0}'' modifier
replace.inheritance.with.delegation.quickfix:
  text: Replace inheritance with delegation
big.decimal.equals.replace.quickfix:
  text: Replace with 'compareTo()==0'
cast.that.loses.precision.problem.descriptor:
  text: 'Cast from ''''{0}'''' to <code>#ref</code> may result in loss of precision #loc'
cast.that.loses.precision.negative.problem.descriptor:
  text: 'Cast from ''''{0}'''' to <code>#ref</code> may result in loss of precision for negative argument #loc'
comparison.to.nan.problem.descriptor1:
  text: 'Comparison to <code>#ref</code> is always false #loc'
comparison.to.nan.problem.descriptor2:
  text: 'Comparison to <code>#ref</code> is always true #loc'
comparison.to.nan.replace.quickfix:
  text: Replace with 'isNaN()'
confusing.floating.point.literal.change.quickfix:
  text: Change to canonical form
implicit.numeric.conversion.ignore.widening.conversion.option:
  text: Ignore widening conversions
implicit.numeric.conversion.ignore.char.conversion.option:
  text: Ignore conversions from and to char
implicit.numeric.conversion.ignore.constant.conversion.option:
  text: Ignore conversions from constants and literals
implicit.numeric.conversion.problem.descriptor:
  text: 'Implicit numeric conversion of <code>#ref</code> from ''''{0}'''' to ''''{1}'''' #loc'
implicit.numeric.conversion.convert.quickfix:
  text: Convert to ''{0}''
implicit.numeric.conversion.make.explicit.quickfix:
  text: Make conversion explicit
long.literals.ending.with.lowercase.l.replace.quickfix:
  text: Replace 'l' with 'L'
non.reproducible.math.call.replace.quickfix:
  text: Replace with 'StrictMath' call
overly.complex.arithmetic.expression.max.number.option:
  text: 'Maximum number of terms:'
expression.can.be.replaced.problem.descriptor:
  text: '<code>#ref</code> can be replaced with ''''{0}'''' #loc'
method.complexity.limit.option:
  text: 'Method complexity limit:'
cyclomatic.complexity.problem.descriptor:
  text: 'Overly complex method <code>#ref()</code> (cyclomatic complexity = {0}) #loc'
method.coupling.limit.option:
  text: 'Method coupling limit:'
method.coupling.problem.descriptor:
  text: '<code>#ref</code> is overly coupled (# referenced classes = {0}) #loc'
method.with.multiple.loops.problem.descriptor:
  text: '<code>#ref</code> contains {0} loops #loc'
return.point.limit.option:
  text: '&Return point limit:'
multiple.return.points.per.method.problem.descriptor:
  text: '<code>#ref</code> has {0} return points #loc'
nesting.depth.limit.option:
  text: 'Nesting depth limit:'
nesting.depth.problem.descriptor:
  text: '<code>#ref</code> is overly nested (maximum nesting depth = {0}) #loc'
non.comment.source.statements.limit.option:
  text: 'Non-comment source statements limit:'
non.comment.source.statements.problem.descriptor:
  text: '<code>#ref</code> is too long (# Non-comment source statements = {0}) #loc'
parameters.per.method.problem.descriptor:
  text: '<code>#ref()</code> has too many parameters (num parameters = {0}) #loc'
parameters.per.constructor.problem.descriptor:
  text: '<code>#ref()</code> has too many parameters (num parameters = {0}) #loc'
parameter.limit.option:
  text: 'Parameter limit:'
constructor.visibility.option:
  text: 'Ignore constructors with visibility:'
three.negations.per.method.ignore.option:
  text: Ignore negations in 'equals()' methods
three.negations.per.method.ignore.assert.option:
  text: Ignore negations in 'assert' statements
three.negations.per.method.problem.descriptor:
  text: '<code>#ref</code> contains {0} negations #loc'
thrown.exceptions.per.method.problem.descriptor:
  text: '<code>#ref</code> has too many exceptions declared (num exceptions = {0}) #loc'
thrown.exceptions.per.method.limit.option:
  text: 'Exceptions thrown limit:'
call.to.simple.getter.in.class.ignore.option:
  text: Ignore getter calls on other objects
call.to.private.simple.getter.in.class.option:
  text: Only report getter is 'private'
call.to.simple.getter.in.class.inline.quickfix:
  text: Inline call to getter
call.to.simple.setter.in.class.ignore.option:
  text: Ignore setter calls on other objects
call.to.private.setter.in.class.option:
  text: Only report when setter is 'private'
call.to.simple.setter.in.class.inline.quickfix:
  text: Inline call to setter
make.static.quickfix:
  text: Make 'static'
length.one.strings.in.concatenation.replace.quickfix:
  text: Replace with character
multiply.or.divide.by.power.of.two.replace.quickfix:
  text: Replace with shift
boolean.expression.can.be.simplified.problem.descriptor:
  text: '<code>#ref</code> can be simplified to ''''{0}'''' #loc'
trivial.string.concatenation.problem.descriptor:
  text: Empty string used in concatenation
string.replace.quickfix:
  text: Replace concatenation with ''{0}''
instantiating.object.to.get.class.object.replace.quickfix:
  text: Replace with direct class object access
manual.array.copy.replace.quickfix:
  text: Replace with 'System.arraycopy()'
manual.array.to.collection.copy.replace.quickfix:
  text: Replace with 'Collections.addAll(...,...)'
method.may.be.static.only.option:
  text: Only check 'private' or 'final' methods
method.may.be.static.empty.option:
  text: Ignore empty methods
random.double.for.random.integer.replace.quickfix:
  text: Replace with 'nextInt()'
string.buffer.replaceable.by.string.builder.replace.quickfix:
  text: Replace with 'StringBuilder'
string.buffer.to.string.in.concatenation.remove.quickfix:
  text: Remove 'toString()'
string.concatenation.in.loops.only.option:
  text: Only warn if string is repeatedly appended
string.concatenation.inside.string.buffer.append.replace.quickfix:
  text: Replace with chained 'append()' calls
string.equals.empty.string.quickfix:
  text: Replace with 'length()==0'
string.equals.empty.string.isempty.quickfix:
  text: Replace with 'isEmpty()'
tail.recursion.replace.quickfix:
  text: Replace tail recursion with iteration
if.statement.with.too.many.branches.max.option:
  text: 'Maximum number of branches:'
if.statement.with.too.many.branches.problem.descriptor:
  text: '<code>#ref</code> has too many branches ({0}) #loc'
negated.conditional.ignore.option:
  text: Ignore '!= null' comparisons
negated.conditional.invert.quickfix:
  text: Invert condition
negated.if.else.ignore.negated.null.option:
  text: Ignore '!= null' comparisons
negated.if.else.ignore.negated.zero.option:
  text: Ignore '!= 0' comparisons
negated.if.else.invert.quickfix:
  text: Invert 'if' condition
overly.complex.boolean.expression.max.terms.option:
  text: 'Maximum number of terms:'
pointless.boolean.expression.ignore.option:
  text: Ignore named constants in determining pointless expressions
simplifiable.conditional.expression.problem.descriptor:
  text: '<code>#ref</code> can be simplified to ''''{0}'''' #loc'
simplifiable.if.statement.problem.descriptor:
  text: '<code>#ref</code> statement can be replaced with ''''{0}'''' #loc'
switch.statement.density.min.option:
  text: 'Minimum density of branches: %'
switch.statement.density.problem.descriptor:
  text: '<code>#ref</code> has too low of a branch density ({0}%) #loc'
switch.statement.with.too.few.branches.min.option:
  text: 'Minimum number of branches:'
switch.statement.with.too.few.branches.problem.descriptor:
  text: '<code>#ref</code> has too few branches ({0}), and should probably be replaced with an ''''if'''' statement #loc'
switch.statement.without.default.ignore.option:
  text: Ignore if all cases of an enumerated type are covered
unnecessary.label.remove.quickfix:
  text: Remove label
unnecessary.return.problem.descriptor:
  text: '<code>#ref</code> is unnecessary as the last statement in a ''void'' method #loc'
unnecessary.return.constructor.problem.descriptor:
  text: '<code>#ref</code> is unnecessary as the last statement in a constructor #loc'
unused.label.remove.quickfix:
  text: Remove unused label
unnecessarily.qualified.static.usage.problem.descriptor:
  text: 'Unnecessarily qualified static method call <code>{0}()</code> #loc'
unnecessarily.qualified.static.usage.problem.descriptor1:
  text: 'Unnecessarily qualified static access <code>{0}</code> #loc'
unnecessarily.qualified.static.usage.ignore.field.option:
  text: Ignore unnecessarily qualified field accesses
unnecessarily.qualified.static.usage.ignore.method.option:
  text: Ignore unnecessarily qualified method calls
unnecessary.interface.modifier.problem.descriptor:
  text: 'Modifier <code>#ref</code> is redundant for interfaces #loc'
unnecessary.interface.modifier.inner.interface.of.interface.problem.descriptor:
  text: 'Modifier <code>#ref</code> is redundant for inner interfaces #loc'
unnecessary.interface.modifier.problem.descriptor2:
  text: 'Modifier <code>#ref</code> is redundant for interface methods #loc'
unnecessary.interface.modifier.problem.descriptor3:
  text: 'Modifier <code>#ref</code> is redundant for inner classes of interfaces #loc'
unnecessary.interface.modifier.problem.descriptor4:
  text: 'Modifier <code>#ref</code> is redundant for interface fields #loc'
smth.unnecessary.remove.quickfix:
  text: Remove unnecessary ''{0}''
unqualified.static.usage.problem.descriptor:
  text: 'Unqualified static method call <code>#ref()</code> #loc'
unqualified.static.usage.problem.descriptor1:
  text: 'Unqualified static field access <code>#ref</code> #loc'
unqualified.static.usage.ignore.field.option:
  text: Ignore unqualified field accesses
unqualified.static.usage.ignore.method.option:
  text: Ignore unqualified method calls
unqualified.static.usage.qualify.field.quickfix:
  text: Qualify static field access
unqualified.static.usage.qualify.method.quickfix:
  text: Qualify static method call
too.broad.scope.allow.option:
  text: '<html>Report variables with a new expression as initializer<br>(Potentially unsafe: quick fix may modify semantics if the constructor has non-local side-effects)</html>'
too.broad.scope.only.blocks.option:
  text: Only report variables that can be moved into inner blocks
too.broad.scope.narrow.quickfix:
  text: Move declaration of ''{0}'' closer to usages
press.escape.to.remove.highlighting.message:
  text: Press Escape to remove the highlighting
unnecessary.enum.modifier.problem.descriptor:
  text: 'Modifier <code>#ref</code> is redundant for enum constructors #loc'
unnecessary.enum.modifier.problem.descriptor1:
  text: 'Modifier <code>#ref</code> is redundant for inner enums #loc'
literal.as.arg.to.string.equals.problem.descriptor:
  text: '<code>#ref</code> is argument of ''''{0}()'''', instead of its target #loc'
literal.as.arg.to.string.equals.flip.quickfix:
  text: Flip 'equals()'
c.style.array.declaration.replace.quickfix:
  text: Replace with Java-style array declaration
chained.method.call.ignore.option:
  text: Ignore chained method calls in field initializers
chained.method.call.ignore.this.super.option:
  text: Ignore chained method calls in 'this()' and 'super()' calls
introduce.variable.quickfix:
  text: Introduce variable
introduce.variable.may.change.semantics.quickfix:
  text: Introduce variable (may change semantics)
flip.comparison.quickfix:
  text: Flip comparison
control.flow.statement.without.braces.add.quickfix:
  text: Add braces to statement
control.flow.statement.without.braces.message:
  text: Add braces to ''{0}'' statement
extends.object.remove.quickfix:
  text: Remove redundant 'extends Object'
implicit.call.to.super.ignore.option:
  text: Ignore for direct subclasses of 'java.lang.Object'
implicit.call.to.super.make.explicit.quickfix:
  text: Make call to 'super()' explicit
missorted.modifiers.require.option:
  text: Require annotations to be sorted before keywords
missorted.modifiers.sort.quickfix:
  text: Sort modifiers
nested.method.call.ignore.option:
  text: Ignore nested method calls in field initializers
ignore.calls.to.static.methods:
  text: Ignore calls to static methods
ignore.calls.to.property.getters:
  text: Ignore calls to property getters
redundant.field.initialization.remove.quickfix:
  text: Remove initializer
redundant.implements.remove.quickfix:
  text: Remove redundant interface declaration
unnecessary.constructor.remove.quickfix:
  text: Remove redundant constructor
unnecessary.fully.qualified.name.replace.quickfix:
  text: Replace with import
unnecessary.fully.qualified.name.remove.quickfix:
  text: Remove qualification
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message:
  text: '{0} fully qualified {0, choice, 1#name|2#names} replaced with import (press Escape to remove highlighting)'
unnecessary.parentheses.remove.quickfix:
  text: Remove unnecessary parentheses
unnecessary.qualifier.for.this.remove.quickfix:
  text: Remove unnecessary qualifier
unnecessary.semicolon.remove.quickfix:
  text: Remove unnecessary semicolon
unnecessary.super.constructor.remove.quickfix:
  text: Remove unnecessary 'super()'
unnecessary.this.remove.quickfix:
  text: Remove unnecessary 'this' qualifier
overly.strong.type.cast.problem.descriptor:
  text: 'Cast to <code>#ref</code> can be weakened to ''''{0}'''' #loc'
field.count.inspection.include.constant.fields.in.count.checkbox:
  text: Include constant fields in count
field.count.inspection.static.final.fields.count.as.constant.checkbox:
  text: '''static final'' fields count as constant'
field.count.inspection.include.enum.constants.in.count:
  text: Include enum constants in count
make.method.final.fix.name:
  text: Make method ''{0}()'' ''final''
make.class.final.fix.name:
  text: Make class ''{0}'' ''final''
non.boolean.method.name.must.not.start.with.question.display.name:
  text: Non-boolean method name must not start with question word
non.boolean.method.name.must.not.start.with.question.problem.descriptor:
  text: 'Non-boolean method name <code>#ref</code> starts with a question word #loc'
boolean.constructor.simplify.quickfix:
  text: Simplify
unnecessary.temporary.on.conversion.from.string.problem.descriptor:
  text: '<code>#ref</code> #loc can be simplified to ''''{0}'''''
unnecessary.temporary.on.conversion.from.string.fix.name:
  text: Replace with ''{0}''
only.report.qualified.static.usages.option:
  text: Only report qualified static access from a static context
unqualified.static.usage.only.report.static.usages.option:
  text: Only report static access from a non-static context
assignment.to.catch.block.parameter.problem.descriptor:
  text: 'Assignment to ''catch'' block parameter <code>#ref</code> #loc'
assignment.to.method.parameter.problem.descriptor:
  text: 'Assignment to method parameter <code>#ref</code> #loc'
value.of.post.increment.problem.descriptor:
  text: 'Value of post-increment expression <code>#ref</code> is used #loc'
value.of.post.decrement.problem.descriptor:
  text: 'Value of post-decrement expression <code>#ref</code> is used #loc'
value.of.pre.increment.problem.descriptor:
  text: 'Value of pre-increment expression <code>#ref</code> is used #loc'
value.of.pre.decrement.problem.descriptor:
  text: 'Value of pre-decrement expression <code>#ref</code> is used #loc'
assignment.replaceable.with.operator.assignment.problem.descriptor:
  text: '<code>#ref</code> could be simplified to ''''{0}'''' #loc'
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option:
  text: Ignore conditional operators
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option:
  text: Ignore the obscure ^ and % operators
assignment.replaceable.with.operator.replace.quickfix:
  text: Replace ''='' with ''{0}=''
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option:
  text: Ignore '==' between objects of a type with only 'private' constructors
redundant.method.override.display.name:
  text: Method is identical to its super method
redundant.method.override.problem.descriptor:
  text: 'Method <code>#ref()</code> is identical to its super method #loc'
redundant.method.override.quickfix:
  text: Remove redundant method
refused.bequest.problem.descriptor:
  text: 'Method <code>#ref()</code> does not call ''super.#ref()'' #loc'
refused.bequest.ignore.empty.super.methods.option:
  text: Ignore empty super methods
overly.complex.boolean.expression.ignore.option:
  text: Ignore pure conjunctions and disjunctions
pointless.indexof.comparison.display.name:
  text: Pointless 'indexOf()' comparison
pointless.indexof.comparison.always.true.problem.descriptor:
  text: '<code>#ref</code> is always true #loc'
pointless.indexof.comparison.always.false.problem.descriptor:
  text: '<code>#ref</code> is always false #loc'
reuse.of.local.variable.problem.descriptor:
  text: 'Reuse of local variable <code>#ref</code> #loc'
single.character.startswith.display.name:
  text: Single character 'startsWith()' or 'endsWith()'
single.character.startswith.problem.descriptor:
  text: 'Single character <code>#ref()</code> could be replaced with ''charAt()'' expression #loc'
indexof.replaceable.by.contains.display.name:
  text: '''indexOf()'' expression is replaceable with ''contains()'''
replace.indexof.with.contains.quickfix:
  text: Replace 'indexOf()' with 'contains()'
overloaded.methods.with.same.number.parameters.problem.descriptor:
  text: 'Multiple methods named <code>#ref</code> with the same number of parameters #loc'
overloaded.vararg.method.problem.descriptor:
  text: 'Overloaded varargs method <code>#ref()</code> #loc'
overloaded.vararg.constructor.problem.descriptor:
  text: 'Overloaded varargs constructor <code>#ref()</code> #loc'
cached.number.constructor.call.display.name:
  text: Number constructor call with primitive argument
cached.number.constructor.call.problem.descriptor:
  text: 'Number constructor call with primitive argument #loc'
cached.number.constructor.call.quickfix:
  text: Replace with ''{0}.valueOf()'' call
cached.number.constructor.call.ignore.string.arguments.option:
  text: Ignore new number expressions with a String argument
chained.equality.comparisons.problem.descriptor:
  text: 'Chained equality comparison <code>#ref</code> #loc'
confusing.octal.escape.sequence.problem.descriptor:
  text: 'Octal escape sequence <code>#ref</code> immediately followed by digit #loc'
field.accessed.synchronized.and.unsynchronized.option:
  text: Simple getters and setters are considered field accesses too
method.overrides.inaccessible.method.display.name:
  text: Method overrides inaccessible method of superclass
method.overrides.package.local.method.problem.descriptor:
  text: 'Method <code>#ref()</code> overrides a package-private method of a superclass located in another package #loc'
suspicious.to.array.call.display.name:
  text: Suspicious 'Collection.toArray()' call
suspicious.to.array.call.problem.descriptor:
  text: 'Array of type ''''{0}[]'''' expected #loc'
suspicious.system.arraycopy.display.name:
  text: Suspicious 'System.arraycopy()' call
suspicious.system.arraycopy.problem.descriptor1:
  text: 'Parameter ''srcPos'' may not be negative #loc'
suspicious.system.arraycopy.problem.descriptor2:
  text: 'Parameter ''destPos'' may not be negative #loc'
suspicious.system.arraycopy.problem.descriptor3:
  text: 'Parameter ''length'' may not be negative #loc'
suspicious.system.arraycopy.problem.descriptor4:
  text: '<code>#ref</code> is not of an array type #loc'
suspicious.system.arraycopy.problem.descriptor5:
  text: '<code>#ref</code> is not of an array type #loc'
suspicious.system.arraycopy.problem.descriptor6:
  text: 'Source parameter type ''''{0}'''' is not assignable to destination parameter <code>#ref</code> of type ''''{1}'''' #loc'
raw.use.of.parameterized.type.ignore.new.objects.option:
  text: Ignore construction of new objects
raw.use.of.parameterized.type.ignore.type.casts.option:
  text: Ignore type casts
raw.use.of.parameterized.type.ignore.uncompilable.option:
  text: Ignore where a type parameter would not compile
raw.use.of.parameterized.type.ignore.overridden.parameter.option:
  text: Ignore parameter types of overriding methods
method.only.used.from.inner.class.display.name:
  text: Private method only used from inner class
method.only.used.from.inner.class.problem.descriptor.anonymous.extending:
  text: 'Method <code>#ref()</code>#loc is only used from an anonymous class extending ''''{0}'''' #loc'
method.only.used.from.inner.class.problem.descriptor.anonymous.implementing:
  text: 'Method <code>#ref()</code>#loc is only used from an anonymous class implementing ''''{0}'''' #loc'
method.only.used.from.inner.class.problem.descriptor:
  text: 'Method <code>#ref()</code>#loc is only used from inner class ''''{0}'''' #loc'
method.only.used.from.inner.class.ignore.option:
  text: Ignore methods accessed from an &anonymous class
ignore.static.methods.accessed.from.a.non.static.inner.class:
  text: Ignore '&static' methods accessed from a non-'static' inner class
only.report.static.methods:
  text: '&Only report ''static'' methods'
format.decode.error.requires.both.0.and.1:
  text: requires both {0} and {1}
format.decode.any:
  text: any
format.decode.date.time:
  text: Date/Time
format.decode.char:
  text: char
format.decode.integer.type:
  text: integer type
format.decode.floating.point:
  text: floating point
single.character.startswith.quickfix:
  text: Replace with 'charAt()'
interface.never.implemented.option:
  text: Ignore interfaces which only declare constants
size.replaceable.by.isempty.display.name:
  text: '''size() == 0'' replaceable with ''isEmpty()'''
size.replaceable.by.isempty.quickfix:
  text: Replace with 'isEmpty()'
size.replaceable.by.isempty.negation.ignore.option:
  text: Ignore expressions which would be replaced with '!isEmpty()'
ignored.classes.table:
  text: Ignored classes
choose.class.type.to.ignore:
  text: Choose class type to ignore
loop.condition.not.updated.inside.loop.display.name:
  text: Loop variable not updated inside loop
loop.variable.not.updated.inside.loop.problem.descriptor:
  text: 'Variable ''#ref'' is not updated inside loop #loc'
loop.condition.not.updated.inside.loop.problem.descriptor:
  text: 'Condition ''#ref'' is not updated inside loop #loc'
utility.class.without.private.constructor.option:
  text: Ignore classes with only a main method
super.class.logger.option:
  text: Ignore classes with an accessible logger declared in a superclass
static.method.only.used.in.one.class.display.name:
  text: '''static'' method only used from one other class'
static.method.only.used.in.one.class.problem.descriptor:
  text: '''static'' method <code>#ref()</code> is only used from class ''''{0}'''' #loc'
static.method.only.used.in.one.class.problem.descriptor.anonymous.implementing:
  text: '''static'' method <code>#ref()</code> is only used from an anonymous class implementing ''''{0}'''' #loc'
static.method.only.used.in.one.class.problem.descriptor.anonymous.extending:
  text: '''static'' method <code>#ref()</code> is only used from an anonymous class extending ''''{0}'''' #loc'
static.method.only.used.in.one.class.quickfix:
  text: Move method
static.method.only.used.in.one.class.ignore.test.option:
  text: Ignore when only used from a test class
static.method.only.used.in.one.class.ignore.anonymous.option:
  text: Ignore when only used from an anonymous class
static.method.only.used.in.one.class.ignore.on.conflicts:
  text: Ignore when the method cannot be moved without conflicts
unary.plus.display.name:
  text: Unary plus
unary.plus.problem.descriptor:
  text: 'Unary <code>#ref</code> operator #loc'
await.without.corresponding.signal.display.name:
  text: '''await()'' without corresponding ''signal()'''
await.without.corresponding.signal.problem.descriptor:
  text: 'Call to <code>#ref</code> without corresponding <code>signal()</code> or <code>signalAll()</code> #loc'
signal.without.corresponding.await.display.name:
  text: '''signal()'' without corresponding ''await()'''
signal.without.corresponding.await.problem.descriptor:
  text: 'Call to <code>#ref</code> without corresponding <code>await()</code> #loc'
wait.without.corresponding.notify.display.name:
  text: '''wait()'' without corresponding ''notify()'''
wait.without.corresponding.notify.problem.descriptor:
  text: 'Call to <code>#ref</code> without corresponding <code>notify()</code> or <code>notifyAll()</code> #loc'
notify.without.corresponding.wait.display.name:
  text: '''notify()'' without corresponding ''wait()'''
notify.without.corresponding.wait.problem.descriptor:
  text: 'Call to <code>#ref</code> without corresponding <code>wait()</code> #loc'
integer.multiplication.implicit.cast.to.long.display.name:
  text: Integer multiplication or shift implicitly cast to long
integer.multiplication.implicit.cast.to.long.problem.descriptor:
  text: '#ref: integer multiplication implicitly cast to long #loc'
integer.shift.implicit.cast.to.long.problem.descriptor:
  text: '#ref: integer shift implicitly cast to long #loc'
integer.multiplication.implicit.cast.to.long.option:
  text: <html>Ignore compile time constant expressions which do not overflow</html>
wait.or.await.without.timeout.display.name:
  text: '''wait()'' or ''await()'' without timeout'
wait.or.await.without.timeout.problem.descriptor:
  text: '<code>#ref</code> without timeout #loc'
method.return.always.constant.display.name:
  text: Method returns per-class constant
method.return.always.constant.problem.descriptor:
  text: Method <code>#ref()</code> and all it's derivables always return constants
class.with.too.many.dependencies.display.name:
  text: Class with too many dependencies
class.with.too.many.dependencies.problem.descriptor:
  text: Class ''{0}'' has too many dependencies ({1} > {2})
class.with.too.many.transitive.dependencies.display.name:
  text: Class with too many transitive dependencies
class.with.too.many.transitive.dependencies.problem.descriptor:
  text: Class ''{0}'' has too many transitive dependencies ({1} > {2})
class.with.too.many.dependents.display.name:
  text: Class with too many dependents
class.with.too.many.dependents.problem.descriptor:
  text: Class ''{0}'' has too many dependents ({1} > {2})
class.with.too.many.transitive.dependents.display.name:
  text: Class with too many transitive dependents
class.with.too.many.transitive.dependents.problem.descriptor:
  text: Class ''{0}'' has too many transitive dependencies ({1} > {2})
class.with.too.many.dependencies.max.option:
  text: Maximum number of dependencies
class.with.too.many.dependents.max.option:
  text: Maximum number of dependents
class.with.too.many.transitive.dependencies.max.option:
  text: Maximum number of transitive dependencies
class.with.too.many.transitive.dependents.max.option:
  text: Maximum number of transitive dependents
cyclic.class.dependency.display.name:
  text: Cyclic class dependency
cyclic.class.dependency.problem.descriptor:
  text: Class ''{0}'' is cyclically dependent on {1} other classes
cyclic.class.dependency.1.problem.descriptor:
  text: Class ''{0}'' is cyclically dependent on class ''{1}''
cyclic.class.dependency.2.problem.descriptor:
  text: Class ''{0}'' is cyclically dependent on classes ''{1}'' and ''{2}''
cyclic.package.dependency.display.name:
  text: Cyclic package dependency
cyclic.package.dependency.problem.descriptor:
  text: Package ''{0}'' is cyclically dependent on {1} other packages
cyclic.package.dependency.1.problem.descriptor:
  text: Package ''{0}'' is cyclically dependent on package ''{1}''
cyclic.package.dependency.2.problem.descriptor:
  text: Package ''{0}'' is cyclically dependent on packages ''{1}'' and ''{2}''
class.unconnected.to.package.display.name:
  text: Class independent of its package
class.unconnected.to.package.problem.descriptor:
  text: Class <code>#ref</code> has no dependencies or dependents in its package
package.with.too.many.classes.display.name:
  text: Package with too many classes
package.with.too.many.classes.problem.descriptor:
  text: Package ''{0}'' contains too many classes ({1} > {2})
package.with.too.many.classes.max.option:
  text: 'Maximum number of classes:'
package.with.too.few.classes.display.name:
  text: Package with too few classes
package.with.too.few.classes.problem.descriptor:
  text: Package ''{0}'' contains too few classes ({1} < {2})
package.with.too.few.classes.min.option:
  text: 'Minimum number of classes:'
module.with.too.many.classes.display.name:
  text: Module with too many classes
module.with.too.many.classes.problem.descriptor:
  text: Module ''{0}'' contains too many classes ({1} > {2})
module.with.too.many.classes.max.option:
  text: 'Maximum number of classes:'
module.with.too.few.classes.display.name:
  text: Module with too few classes
module.with.too.few.classes.problem.descriptor:
  text: Module ''{0}'' contains too few classes ({1} < {2})
module.with.too.few.classes.min.option:
  text: 'Minimum number of classes:'
package.in.multiple.modules.display.name:
  text: Package with classes in multiple modules
package.in.multiple.modules.problem.descriptor:
  text: Package ''{0}'' has classes in multiple modules
disjoint.package.display.name:
  text: Package with disjoint dependency graph
disjoint.package.problem.descriptor:
  text: Package {0} can be decomposed into {1} independent packages
package.naming.convention.display.name:
  text: Package naming convention
package.naming.convention.problem.descriptor.short:
  text: Package name <code>{0}</code> is too short
package.naming.convention.problem.descriptor.long:
  text: Package name <code>{0}</code> is too long
package.naming.convention.problem.descriptor.regex.mismatch:
  text: Package name <code>{0}</code> doesn''t match regex ''{1}''
cyclic.class.initialization.display.name:
  text: Cyclic class initialization dependency
cyclic.class.initialization.problem.descriptor:
  text: Initialization of class ''{0}'' is cyclically dependent on {1} other classes
before.or.after.is.public.void.no.arg.display.name:
  text: Malformed @Before or @After method
before.or.after.is.public.void.no.arg.problem.descriptor:
  text: '<code>#ref()</code> has incorrect signature for a @Before or @After method #loc'
before.class.or.after.class.is.public.static.void.no.arg.display.name:
  text: Malformed @BeforeClass/@BeforeAll or @AfterClass/@AfterAll method
before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor:
  text: '<code>#ref()</code> has incorrect signature for a @{0} method #loc'
string.constructor.display.name:
  text: Redundant String constructor call
string.constructor.problem.descriptor:
  text: '<code>#ref</code> is redundant #loc'
string.constructor.replace.arg.quickfix:
  text: Replace with arg
string.constructor.replace.empty.quickfix:
  text: Replace with empty string
string.constructor.substring.parameter.option:
  text: Ignore string constructor calls with a 'substring()' call argument
design.for.extension.display.name:
  text: Design for extension
design.for.extension.problem.descriptor:
  text: 'Method <code>#ref()</code> may be overridden and its functionality ignored #loc'
bad.oddness.display.name:
  text: Suspicious test for oddness
bad.oddness.problem.descriptor:
  text: 'Test for oddness <code>#ref</code> will fail on negative values #loc'
comparator.not.serializable.display.name:
  text: Comparator class not declared Serializable
comparator.not.serializable.problem.descriptor:
  text: 'Comparator class <code>#ref</code> is not declared as Serializable #loc'
non.serializable.field.in.serializable.class.display.name:
  text: Non-serializable field in a Serializable class
non.serializable.field.in.serializable.class.problem.descriptor:
  text: 'Non-serializable field ''#ref'' in a Serializable class #loc'
non.serializable.object.passed.to.object.stream.display.name:
  text: Non-serializable object passed to ObjectOutputStream
non.serializable.object.passed.to.object.stream.problem.descriptor:
  text: 'Non-serializable object passed to ObjectOutputStream #loc'
non.serializable.object.bound.to.http.session.display.name:
  text: Non-serializable object bound to HttpSession
non.serializable.object.bound.to.http.session.problem.descriptor:
  text: 'Non-serializable object bound to HttpSession #loc'
reflection.for.unavailable.annotation.display.name:
  text: Reflective access to a source-only annotation
reflection.for.unavailable.annotation.problem.descriptor:
  text: 'Annotation ''#ref'' is not retained for reflective access #loc'
access.to.static.field.locked.on.instance.display.name:
  text: Access to static field locked on instance data
access.to.static.field.locked.on.instance.problem.descriptor:
  text: 'Access to static field <code>#ref</code> locked on instance data #loc'
make.method.ctr.quickfix:
  text: Make method constructor
replace.all.dot.display.name:
  text: Call to String.replaceAll(".", ...)
replace.all.dot.problem.descriptor:
  text: 'Call to <code>String.#ref(".", ...)</code> #loc'
constant.string.intern.display.name:
  text: Call to 'intern()' on String constant
constant.string.intern.problem.descriptor:
  text: '<code>.#ref()</code> on compile-time constant is unnecessary #loc'
constant.string.intern.quickfix:
  text: Remove 'intern()' call
class.extends.utility.class.display.name:
  text: Class extends utility class
class.extends.utility.class.problem.descriptor:
  text: 'Class <code>#ref</code> extends utility class ''''{0}'''' #loc'
class.extends.utility.class.ignore.utility.class.option:
  text: Ignore if overriding class is a utility class
public.constructor.in.non.public.class.quickfix:
  text: Make constructor ''{0}''
assignment.to.method.parameter.ignore.transformation.option:
  text: <html>Ignore if assignment is a transformation of the original parameter</html>
type.parameter.extends.final.class.display.name:
  text: Type parameter extends final class
type.parameter.extends.final.class.problem.descriptor1:
  text: 'Type parameter <code>#ref</code> extends ''''final'''' class ''''{0}'''' #loc'
type.parameter.extends.final.class.problem.descriptor2:
  text: 'Wildcard type argument <code>#ref</code> extends ''''final'''' class ''''{0}'''' #loc'
type.parameter.extends.final.class.quickfix:
  text: Replace type parameter with actual class
double.negation.display.name:
  text: Double negation
double.negation.problem.descriptor:
  text: 'Double negation in <code>#ref</code> #loc'
double.negation.quickfix:
  text: Remove double negation
exception.from.catch.which.doesntwrap.ignore.option:
  text: Ignore if result of exception method call is used
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option:
  text: Ignore if thrown exception cannot wrap an exception
comparable.implemented.but.equals.not.overridden.display.name:
  text: Comparable implemented but 'equals()' not overridden
comparable.implemented.but.equals.not.overridden.problem.descriptor:
  text: 'Class <code>#ref</code> implements ''java.lang.Comparable'' but does not override ''equals()'' #loc'
unqualified.field.access.display.name:
  text: Instance field access not qualified with 'this'
unqualified.field.access.problem.descriptor:
  text: 'Instance field access <code>#ref</code> is not qualified with ''this'' #loc'
unqualified.method.access.display.name:
  text: Instance method call not qualified with 'this'
unqualified.method.access.problem.descriptor:
  text: 'Instance method call <code>#ref</code> is not qualified with ''this'' #loc'
add.this.qualifier.quickfix:
  text: Add 'this' qualifier
while.loop.spins.on.field.ignore.non.empty.loops.option:
  text: Only warn if the loop is empty
method.may.be.synchronized.problem.descriptor:
  text: 'Method <code>#ref()</code> with synchronized block could be synchronized method #loc'
method.may.be.synchronized.display.name:
  text: Method with synchronized block could be synchronized method
method.may.be.synchronized.quickfix:
  text: Make method synchronized and remove synchronized block
fallthru.in.switch.statement.quickfix:
  text: Add 'break'
law.of.demeter.display.name:
  text: Method call violates Law of Demeter
law.of.demeter.problem.descriptor:
  text: '<code>#ref()</code> call violates Law of Demeter #loc'
law.of.demeter.ignore.library.calls.option:
  text: Ignore calls on library methods
assertequals.between.inconvertible.types.display.name:
  text: '''assertEquals()'' between objects of inconvertible types'
assertequals.between.inconvertible.types.problem.descriptor:
  text: '<code>#ref()</code> between objects of inconvertible types ''''{0}'''' and ''''{1}'''' #loc'
enumeration.can.be.iteration.display.name:
  text: Enumeration can be iteration
enumeration.can.be.iteration.problem.descriptor:
  text: '<code>#ref()</code> can be replaced with ''''{0}'''' construct #loc'
enumeration.can.be.iteration.quickfix:
  text: Replace with 'Iterator' construct
equals.hashcode.called.on.url.display.name:
  text: '''equals()'' or ''hashCode()'' called on ''java.net.URL'' object'
equals.hashcode.called.on.url.problem.descriptor:
  text: 'Call to <code>#ref()</code> on URL object #loc'
collection.contains.url.problem.decriptor:
  text: '{0} <code>#ref</code> may contain URL objects #loc'
collection.contains.url.display.name:
  text: Map or Set may contain 'java.net.URL' objects
implicit.array.to.string.problem.descriptor:
  text: 'Implicit call to ''toString()'' on array <code>#ref</code> #loc'
explicit.array.to.string.problem.descriptor:
  text: 'Call to ''#ref()'' on array #loc'
implicit.array.to.string.method.call.problem.descriptor:
  text: 'Implicit call to ''toString()'' on array returned by call to <code>#ref</code> #loc'
implicit.array.to.string.display.name:
  text: Call to 'toString()' on array
implicit.array.to.string.quickfix:
  text: Wrap with ''{0}'' expression
suspicious.indent.after.control.statement.problem.descriptor:
  text: '<code>#ref</code> statement has suspicious indentation #loc'
suspicious.indent.after.control.statement.display.name:
  text: Suspicious indentation after control statement without braces
unpredictable.big.decimal.constructor.call.display.name:
  text: Unpredictable BigDecimal constructor call
unpredictable.big.decimal.constructor.call.problem.descriptor:
  text: 'Unpredictable <code>new #ref()</code> call #loc'
unpredictable.big.decimal.constructor.call.ignore.references.option:
  text: Ignore constructor calls with variable or method call arguments
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option:
  text: Ignore constructor calls with multiple literals (e.g. 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.quickfix:
  text: Replace with ''{0}''
unnecessary.unary.minus.display.name:
  text: Unnecessary unary minus
unnecessary.unary.minus.problem.descriptor:
  text: 'Unnecessary unary minus #loc'
unnecessary.unary.minus.quickfix:
  text: Remove unary minus and invert parent operation sign
make.field.final.quickfix:
  text: Make ''{0}'' ''final''
increment.decrement.used.as.expression.quickfix:
  text: Extract ''{0}'' to separate statement
ignore.classes.in.hierarchy.column.name:
  text: Ignore subclasses of
overly.strong.type.cast.ignore.in.matching.instanceof.option:
  text: Ignore casts with a matching instanceof expression
return.of.collection.field.quickfix:
  text: Replace with ''{0}''
access.to.non.thread.safe.static.field.from.instance.display.name:
  text: Non thread-safe static field access
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor:
  text: 'Access to non thread-safe static field <code>#ref</code> of type ''''{0}'''' #loc'
access.to.non.thread.safe.static.field.from.instance.option.title:
  text: Non thread-safe classes
access.to.non.thread.safe.static.field.from.instance.class.chooser.title:
  text: Choose non thread-safe class
transient.field.not.initialized.display.name:
  text: Transient field is not initialized on deserialization
transient.field.not.initialized.problem.descriptor:
  text: 'Transient field <code>#ref</code> not initialized on deserialization #loc'
call.to.string.concat.can.be.replaced.by.operator.display.name:
  text: Call to 'String.concat()' can be replaced with '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor:
  text: 'Call to <code>#ref()</code> can be replaced with ''+'' expression #loc'
call.to.string.concat.can.be.replaced.by.operator.quickfix:
  text: Replace 'concat()' call with '+'
new.string.buffer.with.char.argument.display.name:
  text: StringBuffer constructor call with 'char' argument
new.string.buffer.with.char.argument.problem.descriptor:
  text: '<code>new #ref()</code> with argument of type ''char'' #loc'
new.string.buffer.with.char.argument.quickfix:
  text: Replace char argument with String literal
suspicious.comparator.compare.display.name:
  text: Suspicious 'Comparator.compare()' implementation
suspicious.comparator.compare.descriptor.parameter.not.used:
  text: '''compare()'' parameter <code>#ref</code> is not used #loc'
suspicious.comparator.compare.descriptor.non.reflexive:
  text: Comparator does not return 0 for equal elements
to.array.call.with.zero.length.array.argument.display.name:
  text: Call to 'Collection.toArray()' with zero-length array argument
to.array.call.with.zero.length.array.argument.problem.descriptor:
  text: 'Call to <code>#ref()</code> with zero-length array argument ''''{0}'''' #loc'
to.array.call.with.zero.length.array.argument.quickfix:
  text: Replace argument with correctly sized array
throwable.instance.never.thrown.runtime.exception.problem.descriptor:
  text: 'Runtime exception instance <code>#ref</code> is not thrown #loc'
throwable.instance.never.thrown.checked.exception.problem.descriptor:
  text: 'Checked exception instance <code>#ref</code> is not thrown #loc'
throwable.instance.never.thrown.error.problem.descriptor:
  text: 'Error instance <code>#ref</code> is not thrown #loc'
throwable.instance.never.thrown.problem.descriptor:
  text: 'Throwable instance <code>#ref</code> is not thrown #loc'
type.may.be.weakened.display.name:
  text: Type may be weakened
type.may.be.weakened.problem.descriptor:
  text: 'Type of variable <code>#ref</code> may be weakened to {0} #loc'
type.may.be.weakened.method.problem.descriptor:
  text: 'Return type of method <code>#ref()</code> may be weakened to {0} #loc'
type.may.be.weakened.parameter.problem.descriptor:
  text: 'Type of parameter <code>#ref</code> may be weakened to {0} #loc'
type.may.be.weakened.field.problem.descriptor:
  text: 'Type of field <code>#ref</code> may be weakened to {0} #loc'
type.may.be.weakened.quickfix:
  text: Weaken type to ''{0}''
type.may.be.weakened.ignore.option:
  text: Use &righthand type as weakest type in assignments
type.may.be.weakened.collection.method.option:
  text: Use &parameterized type of collection for method call arguments
type.may.be.weakened.do.not.weaken.to.object.option:
  text: Do not &weaken to 'java.lang.Object'
ignore.guard.clauses.option:
  text: Ignore &guard clauses
ignore.for.equals.methods.option:
  text: Ignore for '&equals()' methods
caught.exception.immediately.rethrown.display.name:
  text: Caught exception is immediately rethrown
caught.exception.immediately.rethrown.problem.descriptor:
  text: 'Caught exception <code>#ref</code> is immediately rethrown #loc'
delete.catch.section.quickfix:
  text: Delete 'catch' section
remove.try.catch.quickfix:
  text: Remove 'try catch' statement
loop.with.implicit.termination.condition.display.name:
  text: Loop with implicit termination condition
loop.with.implicit.termination.condition.dowhile.problem.descriptor:
  text: '<code>#ref-while</code> loop with implicit termination condition #loc'
loop.with.implicit.termination.condition.problem.descriptor:
  text: '<code>#ref</code> loop with implicit termination condition #loc'
loop.with.implicit.termination.condition.quickfix:
  text: Make condition explicit
ignore.iterator.loop.variables:
  text: Ignore 'java.util.Iterator' loop variables
rename.catch.parameter.to.ignored:
  text: Rename 'catch' parameter to 'ignored'
unnecessary.super.qualifier.display.name:
  text: Unnecessary 'super' qualifier
unnecessary.super.qualifier.problem.descriptor:
  text: 'Qualifier <code>#ref</code> is unnecessary in this context #loc'
unnecessary.super.qualifier.quickfix:
  text: Remove unnecessary 'super' qualifier
collections.field.access.replaceable.by.method.call.display.name:
  text: Collections.EMPTY_* field access replaceable with 'Collections.empty*()' method call
collections.field.access.replaceable.by.method.call.problem.descriptor:
  text: '<code>#ref</code> replaceable with ''''Collections.{0}'''' #loc'
collections.field.access.replaceable.by.method.call.quickfix:
  text: Replace with ''{0}''
synchronization.on.local.variable.or.method.parameter.display.name:
  text: Synchronization on local variable or method parameter
synchronization.on.local.variable.problem.descriptor:
  text: 'Synchronization on local variable <code>#ref</code> #loc'
synchronization.on.method.parameter.problem.descriptor:
  text: 'Synchronization on method parameter <code>#ref</code> #loc'
too.broad.catch.quickfix:
  text: Add ''catch'' clause for ''{0}''
replace.with.catch.clause.for.runtime.exception.quickfix:
  text: Replace with 'catch' clause for 'RuntimeException'
too.broad.catch.option:
  text: '&Only warn on RuntimeException, Exception, Error or Throwable'
unnecessary.call.to.string.valueof.display.name:
  text: Unnecessary call to 'String.valueOf()'
unnecessary.tostring.call.display.name:
  text: Unnecessary call to 'toString()'
unnecessary.call.to.string.valueof.problem.descriptor:
  text: '<code>#ref</code> can be simplified to ''''{0}'''' #loc'
unnecessary.tostring.call.problem.descriptor:
  text: 'Unnecessary <code>#ref()</code> call #loc'
unnecessary.call.to.string.valueof.quickfix:
  text: Replace with ''{0}''
throwable.not.thrown.display.name:
  text: Throwable not thrown
throwable.result.of.method.call.ignored.problem.descriptor:
  text: 'Result of <code>#ref()</code> not thrown #loc'
char.used.in.arithmetic.context.display.name:
  text: Char expression used in arithmetic context
char.used.in.arithmetic.context.problem.descriptor:
  text: '''char'' <code>#ref</code> used in arithmetic context #loc'
char.used.in.arithmetic.context.quickfix:
  text: Convert to String literal
char.used.in.arithmetic.context.cast.quickfix:
  text: Insert cast to {0}
unnecessary.constant.array.creation.expression.display.name:
  text: Redundant 'new' expression in constant array creation
unnecessary.constant.array.creation.expression.problem.descriptor:
  text: '<code>#ref</code> can be replaced with array initializer expression #loc'
unnecessary.constant.array.creation.expression.quickfix:
  text: Remove ''new {0}''
unnecessary.constant.array.creation.expression.family.quickfix:
  text: Replace with array initializer expression
ambiguous.method.call.display.name:
  text: Call to inherited method looks like call to local method
ambiguous.method.call.problem.descriptor:
  text: 'Call to method <code>#ref()</code> from superclass ''''{0}'''' looks like call to method from class ''''{1}'''' #loc'
ambiguous.method.call.quickfix:
  text: Add 'super' qualifier to method call
change.modifier.quickfix:
  text: Make ''{0}''
the.whole.project:
  text: the whole project
this.class:
  text: this class
assertequals.may.be.assertsame.display.name:
  text: '''assertEquals()'' may be ''assertSame()'''
assertequals.may.be.assertsame.problem.descriptor:
  text: '<code>#ref()</code> may be ''assertSame()'' #loc'
logger.initialized.with.foreign.class.quickfix:
  text: Replace with ''{0}.class''
logger.initialized.with.foreign.class.problem.descriptor:
  text: 'Logger initialized with foreign class <code>#ref</code> #loc'
logger.initialized.with.foreign.class.display.name:
  text: Logger initialized with foreign class
logger.factory.method.name:
  text: Logger factory method name
logger.factory.class.name:
  text: Logger factory class name
make.static.final.quickfix:
  text: Make ''{0}'' static final
logging.condition.disagrees.with.log.statement.display.name:
  text: Log condition does not match logging call
logging.condition.disagrees.with.log.statement.problem.descriptor:
  text: 'Log condition <code>#ref()</code> does not match ''''{0}()'''' logging call #loc'
log.statement.guarded.by.log.condition.display.name:
  text: Logging call not guarded by log condition
log.statement.guarded.by.log.condition.problem.descriptor:
  text: '<code>#ref()</code> logging calls not guarded by log condition #loc'
log.statement.guarded.by.log.condition.quickfix:
  text: Surround with log condition
log.statement.guarded.by.log.condition.flag.all.unguarded.option:
  text: Flag all unguarded logging calls
key.set.iteration.may.use.entry.set.display.name:
  text: Iteration over 'keySet()' may be replaced with 'entrySet()' iteration
key.set.iteration.may.use.entry.set.problem.descriptor:
  text: 'Iteration over <code>#ref</code> may be replaced with ''entrySet()'' iteration #loc'
key.set.iteration.may.use.entry.set.quickfix:
  text: Replace with 'entrySet()' iteration
string.replaceable.by.string.buffer.in.loop.option:
  text: Only warn when appending in a loop
declare.collection.as.interface.quickfix:
  text: Weaken to ''{0}''
non.exception.name.ends.with.exception.quickfix:
  text: Make ''{0}'' extend ''java.lang.Exception''
constant.value.variable.use.display.name:
  text: Use of variable whose value is known to be constant
constant.value.variable.use.problem.descriptor:
  text: 'Value of <code>#ref</code> is known to be constant #loc'
replace.reference.with.expression.quickfix:
  text: Replace with ''{0}''
unnecessary.parentheses.option:
  text: Ignore clarifying parentheses
unnecessary.parentheses.conditional.option:
  text: Ignore parentheses around the condition of conditional expressions
field.may.be.final.display.name:
  text: Field may be 'final'
field.may.be.final.problem.descriptor:
  text: 'Field <code>#ref</code> may be ''final'' #loc'
cast.that.loses.precision.option:
  text: Ignore casts from int to char
ignore.overflowing.byte.casts.option:
  text: Ignore casts from int 128-255 to byte
variable.not.used.inside.if.display.name:
  text: Reference checked for 'null' is not used inside 'if'
variable.not.used.inside.if.problem.descriptor:
  text: '<code>#ref</code> checked for ''null'' is not used inside ''if'' #loc'
variable.not.used.inside.conditional.problem.descriptor:
  text: '<code>#ref</code> checked for ''null'' is not used inside conditional #loc'
boolean.expression.may.be.conditional.display.name:
  text: Boolean expression could be replaced with conditional expression
if.may.be.conditional.display.name:
  text: '''if'' statement could be replaced with conditional expression'
if.may.be.conditional.problem.descriptor:
  text: '<code>#ref</code> could be replaced with conditional expression #loc'
if.may.be.conditional.quickfix:
  text: Replace with conditional expression
if.may.be.conditional.report.method.calls.option:
  text: Report if statements containing method calls
redundant.string.format.call.display.name:
  text: Redundant call to 'String.format()'
redundant.string.format.call.problem.descriptor:
  text: 'Redundant call to <code>#ref</code> #loc'
redundant.string.format.call.quickfix:
  text: Remove redundant call to 'String.format()'
junit4.test.method.in.class.extending.junit3.testcase.display.name:
  text: JUnit 4 test method in class extending JUnit 3 TestCase
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor:
  text: 'Method <code>#ref()</code> annotated with ''@Test'' inside class extending JUnit 3 TestCase #loc'
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor:
  text: 'JUnit 3 test method <code>#ref()</code> annotated with ''@Ignore'' won''t be ignored #loc'
ignore.test.method.in.class.extending.junit3.testcase.quickfix:
  text: Remove ''@Ignore'' and rename method to ''{0}''
convert.junit3.test.class.quickfix:
  text: Convert JUnit 3 class ''{0}'' to JUnit 4
remove.junit4.test.annotation.quickfix:
  text: Remove '@Test' annotation
remove.junit4.test.annotation.and.rename.quickfix:
  text: Remove ''@Test'' annotation and rename to ''{0}''
equals.called.on.enum.constant.display.name:
  text: '''equals()'' called on Enum value'
equals.called.on.enum.constant.problem.descriptor:
  text: '<code>#ref()</code> called on Enum value #loc'
equals.called.on.enum.constant.quickfix:
  text: Replace 'equals()' with '=='
int.literal.may.be.long.literal.display.name:
  text: '''int'' literal cast to ''long'' could be ''long'' literal'
int.literal.may.be.long.literal.problem.descriptor:
  text: '<code>#ref</code> could be replaced with ''''{0}'''' #loc'
int.literal.may.be.long.literal.quickfix:
  text: Replace with ''{0}''
constant.assert.condition.display.name:
  text: '''assert'' statement condition is constant'
constant.assert.condition.problem.descriptor:
  text: 'Assert condition <code>#ref</code> is constant #loc'
assert.with.side.effects.display.name:
  text: '''assert'' statement with side effects'
assert.with.side.effects.problem.descriptor:
  text: '<code>#ref</code> has side effects #loc'
method.count.ignore.getters.setters.option:
  text: '&Ignore simple getter and setter methods'
class.new.instance.display.name:
  text: Unsafe call to 'Class.newInstance()'
class.new.instance.problem.descriptor:
  text: 'Call to <code>#ref()</code> may throw undeclared checked exceptions #loc'
class.new.instance.quickfix:
  text: Replace with 'Class.getConstructor().newInstance()' call
dynamic.regex.replaceable.by.compiled.pattern.display.name:
  text: Dynamic regular expression could be replaced by compiled Pattern
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor:
  text: '<code>#ref()</code> could be replaced with compiled ''java.util.regex.Pattern'' construct #loc'
dynamic.regex.replaceable.by.compiled.pattern.quickfix:
  text: Replace with call to method of compiled 'Pattern' constant
ignore.serializable.option:
  text: Ignore 'java.io.Serializable'
ignore.cloneable.option:
  text: Ignore 'java.lang.Cloneable'
listener.may.use.adapter.display.name:
  text: Class may extend adapter instead of implementing listener
listener.may.use.adapter.problem.descriptor:
  text: 'Class ''''{0}'''' may extend ''''{1}'''' instead of implementing <code>#ref</code> #loc'
listener.may.use.adapter.quickfix:
  text: Replace with ''extends {0}''
listener.may.use.adapter.emtpy.methods.option:
  text: '&Only warn when empty implementing methods are found'
unnecessary.inherit.doc.display.name:
  text: Unnecessary '{'@inheritDoc'}' Javadoc comment
unnecessary.inherit.doc.problem.descriptor:
  text: 'Javadoc comment containing only <code>#ref</code> is unnecessary #loc'
unnecessary.inherit.doc.field.invalid.problem.descriptor:
  text: '<code>#ref</code> is not valid on fields #loc'
unnecessary.inherit.doc.constructor.invalid.problem.descriptor:
  text: '<code>#ref</code> is not valid on constructors #loc'
unnecessary.inherit.doc.class.invalid.problem.descriptor:
  text: '<code>#ref</code> is not valid on classes #loc'
unnecessary.inherit.doc.module.invalid.problem.descriptor:
  text: '<code>#ref</code> is not valid on module declarations #loc'
unnecessary.inherit.doc.constructor.no.super.problem.descriptor:
  text: 'No super method found to inherit Javadoc from #loc'
unnecessary.inherit.doc.quickfix:
  text: Remove unnecessary '{'@inheritDoc'}'
multiple.exceptions.declared.on.test.method.display.name:
  text: Multiple exceptions declared on test method
multiple.exceptions.declared.on.test.method.problem.descriptor:
  text: '<code>#ref</code> could be replaced with ''throws Exception'' #loc'
multiple.exceptions.declared.on.test.method.quickfix:
  text: Replace with 'throws Exception'
unnecessary.javadoc.link.display.name:
  text: Unnecessary Javadoc link
unnecessary.javadoc.link.super.method.problem.descriptor:
  text: '<code>#ref</code> pointing to super method is unnecessary #loc'
unnecessary.javadoc.link.this.method.problem.descriptor:
  text: '<code>#ref</code> pointing to this method is unnecessary #loc'
unnecessary.javadoc.link.this.class.problem.descriptor:
  text: '<code>#ref</code> pointing to containing class is unnecessary #loc'
unnecessary.javadoc.link.quickfix:
  text: Remove unnecessary ''{0}''
thread.local.not.static.final.display.name:
  text: ThreadLocal field not declared static final
thread.local.not.static.final.problem.descriptor:
  text: 'ThreadLocal <code>#ref</code> is not declared ''static final'' #loc'
remove.try.finally.block.quickfix:
  text: Remove 'try-finally' block
remove.finally.block.quickfix:
  text: Remove 'finally' block
remove.leading.zero.to.make.decimal.quickfix:
  text: Remove leading zero to make decimal
convert.octal.literal.to.decimal.literal.quickfix:
  text: Convert octal literal to decimal literal
ignore.single.field.static.imports.option:
  text: Ignore single &field static imports
ignore.single.method.static.imports.option:
  text: Ignore single &method static imports
ignore.methods.with.boolean.return.type.option:
  text: Ignore methods with 'java.lang.&Boolean' return type
ignore.boolean.methods.in.an.interface.option:
  text: Ignore boolean methods in an @&interface
ignore.methods.overriding.super.method:
  text: Ignore methods &overriding/implementing a super method
ignore.nullable.parameters.option:
  text: Ignore @Nullable parameters
ignored.io.resource.types:
  text: Ignored I/O resource types
choose.io.resource.type.to.ignore:
  text: Choose I/O resource type to ignore
ignore.accesses.from.the.same.class:
  text: Ignore accesses from the same class
ignore.accesses.from.equals.method:
  text: Ignore accesses from 'equals()' method
ignore.branches.of.switch.statements:
  text: Ignore branches of 'switch' statements
ignore.equals.hashcode.and.tostring:
  text: Ignore 'equals()', 'hashCode()' and 'toString()' methods
ignore.methods.in.anonymous.classes:
  text: Ignore methods in anonymous classes
class.name:
  text: Class name
method.name.regex:
  text: Method name regex
choose.class:
  text: Choose class
query.column.name:
  text: Query names start with
update.column.name:
  text: Update names start with
assert.keyword.is.considered.an.assertion:
  text: '''assert'' keyword is considered an assertion'
expected.exception.never.thrown.display.name:
  text: Expected exception never thrown in test method body
expected.exception.never.thrown.problem.descriptor:
  text: 'Expected <code>#ref</code> never thrown in body of ''''{0}()'''' #loc'
choose.logger.class:
  text: Choose logger class
logger.class.name:
  text: Logger class name
ignore.exceptions.declared.on.library.override.option:
  text: Ignore exceptions declared on methods overriding a &library method
allow.resource.to.be.opened.inside.a.try.block:
  text: Allow resource to be opened inside a 'try' block
any.method.may.close.resource.argument:
  text: Any method may close resource argument
log.method.name:
  text: Logging method name
log.condition.text:
  text: Log condition text
ignore.if.annotated.by:
  text: Ignore if annotated by
ignore.parameter.if.annotated.by:
  text: Ignore parameter if it is annotated by
only.weaken.to.an.interface:
  text: Only weaken to an interface
unqualified.inner.class.access.display.name:
  text: Unqualified inner class access
unqualified.inner.class.access.problem.descriptor:
  text: '<code>#ref</code> is not qualified with outer class #loc'
unqualified.inner.class.access.quickfix:
  text: Qualify with outer class
unnecessarily.qualified.inner.class.access.problem.descriptor:
  text: '''''{0}'''' is unnecessarily qualified with <code>#ref</code> #loc'
unnecessarily.qualified.inner.class.access.display.name:
  text: Unnecessarily qualified inner class access
unnecessarily.qualified.inner.class.access.quickfix:
  text: Remove qualifier
synchronization.on.static.field.display.name:
  text: Synchronization on 'static' field
synchronization.on.static.field.problem.descriptor:
  text: 'Synchronization on ''static'' field <code>#ref</code> #loc'
assertequals.called.on.arrays.display.name:
  text: '''assertEquals()'' called on array'
assertequals.called.on.arrays.problem.descriptor:
  text: '<code>#ref()</code> called on array #loc'
overly.broad.throws.clause.display.name:
  text: Overly broad 'throws' clause
overly.broad.throws.clause.problem.descriptor1:
  text: '<code>throws #ref</code> is too broad, masking exception ''''{0}'''' #loc'
overly.broad.throws.clause.problem.descriptor2:
  text: '<code>throws #ref</code> is too broad, masking exceptions ''''{0}'''' and ''''{1}'''' #loc'
overly.broad.throws.clause.quickfix1:
  text: Add specific exceptions
overly.broad.throws.clause.quickfix2:
  text: Replace with specific exceptions
overly.broad.throws.clause.ignore.thrown.option:
  text: Ignore exceptions which &hide others but are themselves thrown
unnecessarily.qualified.statically.imported.element.display.name:
  text: Unnecessarily qualified statically imported element
unnecessarily.qualified.statically.imported.element.problem.descriptor:
  text: 'Statically imported element ''''{0}'''' is unnecessarily qualified with <code>#ref</code> #loc'
unnecessarily.qualified.statically.imported.element.quickfix:
  text: Remove unnecessary qualifier
ignore.instanceof.on.library.classes:
  text: Ignore instanceof on library classes
replace.assertequals.quickfix:
  text: Replace with ''{0}''
for.can.be.foreach.option:
  text: Report indexed 'java.util.List' loops
for.can.be.foreach.option2:
  text: Do not report iterations over untyped collections
cast.conflicts.with.instanceof.quickfix1:
  text: Replace ''{0}'' with ''{1}'' in cast
cast.conflicts.with.instanceof.quickfix2:
  text: Replace ''{0}'' with ''{1}'' in instanceof
double.checked.locking.quickfix:
  text: Make ''{0}'' volatile
double.literal.may.be.float.literal.display.name:
  text: '''double'' literal cast to ''float'' could be ''float'' literal'
double.literal.may.be.float.literal.problem.descriptor:
  text: '<code>#ref</code> could be replaced with ''''{0}'''' #loc'
double.literal.may.be.float.literal.quickfix:
  text: Replace with ''{0}''
multiple.declaration.option:
  text: Ignore 'for' loop declarations
simplifiable.annotation.display.name:
  text: Simplifiable annotation
simplifiable.annotation.problem.descriptor:
  text: 'Unnecessary <code>#ref</code> in annotation #loc'
simplifiable.annotation.whitespace.problem.descriptor:
  text: 'Unnecessary whitespace in annotation #loc'
simplifiable.annotation.quickfix:
  text: Simplify annotation
overloaded.methods.with.same.number.parameters.option:
  text: <html>Ignore overloaded methods whose parameter types are definitely incompatible</html>
string.concatenation.in.format.call.display.name:
  text: String concatenation as argument to 'format()' call
string.concatenation.in.format.call.problem.descriptor:
  text: '<code>#ref()</code> call has a String concatenation argument #loc'
string.concatenation.in.format.call.quickfix:
  text: Replace concatenation with separate argument
string.concatenation.in.message.format.call.display.name:
  text: String concatenation as argument to 'MessageFormat.format()' call
string.concatenation.in.message.format.call.problem.descriptor:
  text: 'String concatenation as argument to ''MessageFormat.format()'' call #loc'
shift.out.of.range.quickfix:
  text: Replace ''{0}'' with ''{1}''
boxing.boxed.value.display.name:
  text: Boxing of already boxed value
boxing.boxed.value.problem.descriptor:
  text: 'Boxing of already boxed <code>#ref</code> #loc'
boxing.boxed.value.quickfix:
  text: Remove unnecessary boxing
unnecessary.javadoc.link.option:
  text: Ignore inline links to super methods
constant.junit.assert.argument.display.name:
  text: Constant JUnit assert argument
constant.junit.assert.argument.problem.descriptor:
  text: 'Argument <code>#ref</code> is constant #loc'
test.case.with.no.test.methods.option:
  text: Ignore test cases which have superclasses with test methods
package.dot.html.may.be.package.info.display.name:
  text: '''package.html'' may be converted to ''package-info.java'''
package.dot.html.may.be.package.info.exists.problem.descriptor:
  text: <code>package.html</code> is ignored because <code>package-info.java</code> exists
package.dot.html.may.be.package.info.problem.descriptor:
  text: <code>package.html</code> may be converted to <code>package-info.java</code>
package.dot.html.may.be.package.info.delete.quickfix:
  text: Delete 'package.html'
package.dot.html.may.be.package.info.convert.quickfix:
  text: Convert to 'package-info.java'
choose.super.class.to.ignore:
  text: Choose class
ignore.anonymous.inner.classes:
  text: Ignore anonymous inner classes
try.with.identical.catches.display.name:
  text: Identical 'catch' branches in 'try' statement
try.with.identical.catches.problem.descriptor:
  text: '''''catch'''' branch identical to ''''{0}'''' branch #loc'
if.can.be.switch.display.name:
  text: '''if'' replaceable with ''switch'''
if.can.be.switch.problem.descriptor:
  text: '<code>#ref</code> statement replaceable with ''switch'' statement #loc'
if.can.be.switch.quickfix:
  text: Replace with 'switch'
if.can.be.switch.minimum.branch.option:
  text: 'Minimum number of branches:'
if.can.be.switch.int.option:
  text: Suggest switch on numbers
if.can.be.switch.enum.option:
  text: Suggest switch on enums
if.can.be.switch.null.safe.option:
  text: Only suggest on null-safe expressions
unnecessarily.qualified.inner.class.access.option:
  text: Ignore references for which an import is needed
unqualified.inner.class.access.option:
  text: Ignore references to local inner classes
try.with.identical.catches.quickfix:
  text: Collapse 'catch' blocks
confusing.else.option:
  text: Report when there are no more statements after the 'if' statement
html.tag.can.be.javadoc.tag.display.name:
  text: <code>...</code> can be replaced with '{'@code ...'}'
html.tag.can.be.javadoc.tag.problem.descriptor:
  text: '<code>#ref...\&lt;/code\&gt;</code> can be replaced with ''{@code ...}'' #loc'
html.tag.can.be.javadoc.tag.quickfix:
  text: Replace with '{@code ...}'
try.finally.can.be.try.with.resources.display.name:
  text: '''try finally'' replaceable with ''try'' with resources'
try.finally.can.be.try.with.resources.problem.descriptor:
  text: '<code>#ref</code> can use automatic resource management #loc'
try.finally.can.be.try.with.resources.quickfix:
  text: Replace with 'try' with resources
array.comparison.display.name:
  text: Array comparison using '==', instead of 'Arrays.equals()'
array.comparison.problem.descriptor:
  text: 'Array objects are compared using <code>#ref</code>, not ''Arrays.equals()'' #loc'
array.hash.code.display.name:
  text: '''hashCode()'' called on array'
array.hash.code.problem.descriptor:
  text: '<code>#ref()</code> called on array should probably be ''Arrays.hashCode()'' #loc'
arrays.deep.hash.code.quickfix:
  text: Replace with 'Arrays.deepHashCode()'
arrays.hash.code.quickfix:
  text: Replace with 'Arrays.hashCode()'
method.can.be.variable.arity.method.display.name:
  text: Method can be varargs method
method.can.be.variable.arity.method.problem.descriptor:
  text: '<code>#ref()</code> can be converted to varargs method #loc'
method.can.be.variable.arity.method.ignore.byte.short.option:
  text: Ignore parameters with type byte[] or short[]
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option:
  text: Ignore all primitive array types
method.can.be.variable.arity.method.ignore.multiple.arrays.option:
  text: Ignore methods with multiple array parameters
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option:
  text: Ignore multidimensional array parameters
convert.to.variable.arity.method.quickfix:
  text: Convert to varargs method
mismatched.string.builder.query.update.display.name:
  text: Mismatched query and update of StringBuilder
mismatched.string.builder.updated.problem.descriptor:
  text: 'Contents of {0} <code>#ref</code> are updated, but never queried #loc'
mismatched.string.builder.queried.problem.descriptor:
  text: 'Contents of {0} <code>#ref</code> are queried, but never updated #loc'
math.random.cast.to.int.display.name:
  text: '''Math.random()'' cast to ''int'''
math.random.cast.to.int.problem.descriptor:
  text: '<code>#ref</code> cast to ''''{0}'''' is always rounded down to ''''0'''' #loc'
math.random.cast.to.int.quickfix:
  text: Add parentheses to perform multiplication before cast
boolean.variable.always.inverted.display.name:
  text: Boolean variable is always inverted
boolean.field.always.inverted.problem.descriptor:
  text: 'Boolean field <code>#ref</code> is always inverted #loc'
boolean.variable.always.inverted.problem.descriptor:
  text: 'Boolean variable <code>#ref</code> is always inverted #loc'
unnecessary.explicit.numeric.cast.display.name:
  text: Unnecessary explicit numeric cast
unnecessary.explicit.numeric.cast.problem.descriptor:
  text: '''''{0}'''' unnecessarily cast to <code>#ref</code> #loc'
unnecessary.explicit.numeric.cast.quickfix:
  text: Remove cast
null.thrown.display.name:
  text: '''null'' thrown'
null.thrown.problem.descriptor:
  text: '<code>#ref</code> thrown #loc'
null.thrown.quickfix:
  text: Replace with 'new NullPointerException()'
unnecessary.final.on.local.variable.or.parameter.display.name:
  text: Unnecessary 'final' on local variable or parameter
unnecessary.final.on.local.variable.problem.descriptor:
  text: 'Unnecessary <code>#ref</code> on variable ''''{0}'''' #loc'
unnecessary.final.on.parameter.problem.descriptor:
  text: 'Unnecessary <code>#ref</code> on parameter ''''{0}'''' #loc'
unnecessary.final.report.local.variables.option:
  text: Report local variables
unnecessary.final.report.parameters.option:
  text: Report parameters
unnecessary.final.on.parameter.only.interface.option:
  text: Only warn on abstract or interface methods
choose.exception.class:
  text: Choose Exception class
class.independent.of.module.display.name:
  text: Class independent of its module
class.independent.of.module.problem.descriptor:
  text: 'Class <code>#ref</code> has no dependencies or dependents in its module #loc'
class.only.used.in.one.module.display.name:
  text: Class only used from one other module
class.only.used.in.one.module.problem.descriptor:
  text: 'Class <code>#ref</code> has only dependencies on and/or dependents in module ''''{0}'''' #loc'
empty.directory.display.name:
  text: Empty directory
empty.directories.problem.descriptor:
  text: Empty directory <code>{0}</code>
empty.directories.only.under.source.roots.option:
  text: Only report empty directories located under a source folder
empty.directories.delete.quickfix:
  text: Delete empty directory ''{0}''
simplifiable.equals.expression.display.name:
  text: Unnecessary 'null' check before 'equals()' call
simplifiable.equals.expression.problem.descriptor:
  text: 'Unnecessary ''''null'''' check before ''''{0}()'''' call #loc'
simplifiable.equals.expression.quickfix:
  text: Flip ''.{0}()'' and remove unnecessary ''null'' check
cast.to.concrete.class.option:
  text: Ignore casts to an abstract class type
cast.to.concrete.class.ignore.equals.option:
  text: Ignore in equals()
instanceof.interfaces.option:
  text: Ignore instanceof abstract class
instance.variable.of.concrete.class.option:
  text: Ignore instance fields whose type is an abstract class
local.variable.of.concrete.class.option:
  text: Ignore local variables whose type is an abstract class
method.return.of.concrete.class.option:
  text: Ignore methods whose return type is an abstract class
parameter.of.concrete.class.option:
  text: Ignore parameters whose type is abstract class
static.variable.of.concrete.class.option:
  text: Ignore static fields whose type is an abstract class
class.only.used.in.one.package.display.name:
  text: Class only used from one other package
class.only.used.in.one.package.problem.descriptor:
  text: 'Class <code>#ref</code> has only dependencies on and/or dependents in package ''''{0}'''' #loc'
unnecessary.return.option:
  text: Ignore in then branch of 'if' statement with 'else' branch
usage.of.obsolete.assert.display.name:
  text: Usage of obsolete 'junit.framework.Assert' method
use.of.obsolete.assert.problem.descriptor:
  text: 'Call to <code>#ref()</code> from ''''{0}'''' should be replaced with call to method from ''''org.junit.Assert'''' #loc'
use.of.obsolete.assert.quickfix:
  text: Replace with 'org.junit.Assert' method call
junit5.assertions.converter.problem.descriptor:
  text: 'Call to <code>#ref()</code> from ''''{0}'''' should be replaced with call to method from ''''{1}'''' #loc'
junit5.assertions.converter.quickfix:
  text: Replace with ''{0}'' method call
junit5.assertions.converter.familyName:
  text: Replace with JUnit 5 compatible call
properties.object.as.hashtable.set.quickfix:
  text: Replace with call to 'setProperty()'
properties.object.as.hashtable.get.quickfix:
  text: Replace with call to 'getProperty()'
ignored.junit.test.display.name:
  text: JUnit test annotated with '@Ignore'/'@Disabled'
ignored.junit.test.classproblem.descriptor:
  text: 'Test class ''''{0}'''' annotated with <code>#ref</code> #loc'
ignored.junit.test.method.problem.descriptor:
  text: 'Test method ''''{0}()'''' annotated with <code>#ref</code> #loc'
unclear.binary.expression.display.name:
  text: Unclear expression
unclear.binary.expression.problem.descriptor:
  text: 'Expression could use clarifying parentheses #loc'
unclear.binary.expression.quickfix:
  text: Add clarifying parentheses
new.exception.without.arguments.display.name:
  text: Exception constructor called without arguments
new.exception.without.arguments.problem.descriptor:
  text: '<code>new #ref()</code> without arguments #loc'
new.exception.without.arguments.ignore.option:
  text: Ignore for exceptions that have no constructors with parameters
absolute.alignment.in.user.interface.display.name:
  text: Absolute alignment used in AWT/Swing code
absolute.alignment.in.user.interface.problem.descriptor:
  text: 'Absolute alignment constant <code>{0}.#ref</code> used #loc'
absolute.alignment.in.user.interface.quickfix:
  text: Replace with ''{0}.{1}''
throws.runtime.exception.display.name:
  text: Unchecked exception declared in 'throws' clause
throws.runtime.exception.problem.descriptor:
  text: 'Unchecked exception <code>#ref</code> declared in ''throws'' clause #loc'
throws.runtime.exception.quickfix:
  text: Remove ''{0}'' from ''throws'' clause
throws.runtime.exception.move.quickfix:
  text: Move ''{0}'' to Javadoc ''@throws'' tag
empty.class.ignore.parameterization.option:
  text: Ignore class if it is a parameterization of a super type
ambiguous.field.access.display.name:
  text: Access of inherited field looks like access of element in surrounding code
ambiguous.field.access.hides.local.variable.problem.descriptor:
  text: 'Access of field <code>#ref</code> from superclass ''''{0}'''' looks like access of local variable #loc'
ambiguous.field.access.hides.parameter.problem.descriptor:
  text: 'Access of field <code>#ref</code> from superclass ''''{0}'''' looks like access of parameter #loc'
ambiguous.field.access.hides.field.problem.descriptor:
  text: 'Access of field <code>#ref</code> from superclass ''''{0}'''' looks like access of field from surrounding class #loc'
ambiguous.field.access.quickfix:
  text: Add 'super' qualifier to field access
string.builder.replaceable.by.string.quickfix:
  text: Replace 'StringBuilder' with 'String'
string.buffer.replaceable.by.string.quickfix:
  text: Replace 'StringBuffer' with 'String'
add.0.to.ignore.if.annotated.by.list.quickfix:
  text: Add ''{0}'' to ''Ignore if annotated by'' list
non.final.field.in.enum.display.name:
  text: Non-'final' field in enum
non.final.field.in.enum.problem.descriptor:
  text: 'non-''''final'''' field <code>#ref</code> in enum ''''{0}'''' #loc'
externalizable.without.public.no.arg.constructor.display.name:
  text: Externalizable class without 'public' no-arg constructor
externalizable.without.public.no.arg.constructor.problem.descriptor:
  text: 'Externalizable class <code>#ref</code> has no ''public'' no-arg constructor #loc'
make.constructor.public:
  text: Make constructor 'public'
string.concatenation.missing.whitespace.display.name:
  text: String literal concatenation missing whitespace
string.concatenation.missing.whitespace.problem.descriptor:
  text: 'String literal concatenation missing whitespace #loc'
string.concatenation.missing.whitespace.option:
  text: Ignore when one or both sides are not literals
negated.equality.expression.display.name:
  text: Negated equality expression
negated.equality.expression.problem.descriptor:
  text: 'Negating ''''{0}'''' #loc'
negated.equality.expression.quickfix:
  text: Remove negation
negated.conditional.expression.display.name:
  text: Negated conditional expression
negated.conditional.expression.problem.descriptor:
  text: 'Negating conditional expression #loc'
negated.conditional.expression.quickfix:
  text: Remove negation
suspicious.array.cast.display.name:
  text: Suspicious array cast
suspicious.array.cast.problem.descriptor:
  text: 'Suspicious cast to <code>#ref</code> #loc'
public.constructor.display.name:
  text: '''public'' constructor'
public.default.constructor.problem.descriptor:
  text: Class <code>#ref</code> has 'public' default constructor
public.constructor.problem.descriptor:
  text: 'Public constructor <code>#ref()</code> #loc'
public.constructor.quickfix:
  text: Replace constructor with factory method
junit3.style.test.method.in.junit4.class.display.name:
  text: Old style JUnit test method in JUnit 4 class
junit3.style.test.method.in.junit4.class.problem.descriptor:
  text: 'Old style JUnit test method <code>#ref()</code> in JUnit 4 class #loc'
none:
  text: none
private:
  text: private
package.local.private:
  text: package-private \& private
protected.package.local.private:
  text: protected, package-private \& private
non.final.utility.class.display.name:
  text: Utility class is not 'final'
non.final.utility.class.problem.descriptor:
  text: 'Utility class <code>#ref</code> is not ''final'' #loc'
0.will.no.longer.be.overridable.by.1:
  text: '{0} will no longer be overridable by {1}'
0.will.have.incompatible.access.privileges.with.super.1:
  text: '{0} will have incompatible access privileges with super {1}'
0.will.no.longer.be.visible.from.overriding.1:
  text: '{0} will no longer be visible from overriding {1}'
make.private.quickfix:
  text: Make 'private'
arrays.as.list.with.zero.or.one.argument.display.name:
  text: Call to 'Arrays.asList()' with too few arguments
arrays.as.list.with.one.argument.problem.descriptor:
  text: 'Call to <code>#ref</code> with only one argument #loc'
arrays.as.list.with.zero.arguments.problem.descriptor:
  text: 'Call to <code>#ref</code> with zero arguments #loc'
arrays.as.list.with.one.argument.quickfix:
  text: Replace with call to 'Collections.singletonList()'
arrays.as.list.with.zero.arguments.quickfix:
  text: Replace with call to 'Collections.emptyList()'
ignore.classes.extending.throwable.option:
  text: Ignore classes extending 'Throwable'
string.concatenation.argument.to.log.call.display.name:
  text: Non-constant string concatenation as argument to logging call
string.concatenation.argument.to.log.call.problem.descriptor:
  text: 'Non-constant string concatenation as argument to <code>#ref()</code> logging call #loc'
string.concatenation.argument.to.log.call.quickfix:
  text: Replace concatenation with parameterized log message
placeholder.count.matches.argument.count.display.name:
  text: Number of placeholders does not match number of arguments in logging call
placeholder.count.matches.argument.count.more.problem.descriptor:
  text: 'More arguments provided ({0}) than placeholders specified ({1}) #loc'
placeholder.count.matches.argument.count.fewer.problem.descriptor:
  text: 'Fewer arguments provided ({0}) than placeholders specified ({1}) #loc'
assignment.to.superclass.field.display.name:
  text: Constructor assigns value to field defined in superclass
assignment.to.superclass.field.problem.descriptor:
  text: 'Assignment to field ''''{0}'''' defined in superclass ''''{1}'''' #loc'
junit.rule.display.name:
  text: Malformed @Rule/@ClassRule field
junit.rule.problem.descriptor:
  text: Fields annotated with ''@{0}'' should be {1}
junit.rule.type.problem.descriptor:
  text: Field type should be subtype of 'org.junit.rules.TestRule'
junit.datapoint.display.name:
  text: Malformed @DataPoint field
junit.datapoint.problem.descriptor:
  text: '{1}s annotated with @DataPoint should be {0}'
inner.class.referenced.via.subclass.display.name:
  text: Inner class referenced via subclass
inner.class.referenced.via.subclass.problem.descriptor:
  text: 'Inner class <code>#ref</code> declared in class ''''{0}'''' but referenced via subclass ''''{1}'''' #loc'
inner.class.referenced.via.subclass.quickfix:
  text: Rationalize inner class access
boolean.parameter.display.name:
  text: '''public'' method with ''boolean'' parameter'
boolean.parameter.problem.descriptor:
  text: '''public'' method <code>#ref()</code> with ''boolean'' parameter #loc'
boolean.parameters.problem.descriptor:
  text: '''public'' method <code>#ref()</code> with ''boolean'' parameters #loc'
boolean.parameter.constructor.problem.descriptor:
  text: '''public'' constructor <code>#ref()</code> with ''boolean'' parameter #loc'
boolean.parameters.constructor.problem.descriptor:
  text: '''public'' constructor <code>#ref()</code> with ''boolean'' parameters #loc'
boolean.parameter.only.report.multiple.option:
  text: Only report methods with multiple boolean parameters
unnecessary.unicode.escape.display.name:
  text: Unnecessary unicode escape sequence
unnecessary.unicode.escape.problem.descriptor:
  text: 'Unicode escape sequence <code>#ref</code> can be replaced with ''''{0}'''' #loc'
missing.package.info.display.name:
  text: Missing 'package-info.java'
missing.package.info.problem.descriptor:
  text: Package ''{0}'' is missing a <code>package-info.java</code> file
missing.package.html.problem.descriptor:
  text: Package ''{0}'' is missing a <code>package.html</code> file
package.info.java.without.package.display.name:
  text: '''package-info.java'' without ''package'' statement'
package.info.without.package.problem.descriptor:
  text: '''package-info.java'' does not have a ''package'' statement'
package.info.without.package.quickfix:
  text: add ''package {0};''
package.info.without.package.family.quickfix:
  text: add package statement
auto.closeable.resource.display.name:
  text: AutoCloseable used without 'try'-with-resources
auto.closeable.resource.problem.descriptor:
  text: '''''{0}'''' used without ''''try''''-with-resources statement #loc'
auto.closeable.resource.quickfix:
  text: Ignore 'AutoCloseable' returned by this method
auto.closeable.resource.returned.option:
  text: Ignore AutoCloseable instances returned from all method calls
problematic.varargs.method.display.name:
  text: Non-varargs method overrides varargs method
problematic.varargs.method.override.problem.descriptor:
  text: 'Non-varargs method <code>#ref()</code> overrides varargs method #loc'
negatively.named.boolean.variable.problem.descriptor:
  text: 'Boolean variable <code>#ref</code> is negatively named #loc'
negatively.named.boolean.variable.display.name:
  text: Negatively named boolean variable
invert.quickfix.family.name:
  text: Invert boolean
invert.method.quickfix:
  text: Invert method
invert.quickfix:
  text: Invert ''{0}''
throwable.printed.to.system.out.display.name:
  text: '''Throwable'' printed to ''System.out'''
throwable.printed.to.system.out.problem.descriptor:
  text: '''Throwable'' argument <code>#ref</code> to ''''System.{0}.{1}()'''' call'
suppress.for.tests.scope.quickfix:
  text: Suppress for 'Tests' scope
implicit.default.charset.usage.display.name:
  text: Implicit usage of platform's default charset
implicit.default.charset.usage.problem.descriptor:
  text: Call to <code>#ref()</code> uses the platform's default charset
implicit.default.charset.usage.constructor.problem.descriptor:
  text: '<code>new #ref()</code> call uses the platform''s default charset'
interface.may.be.annotated.functional.display.name:
  text: Interface may be annotated @FunctionalInterface
interface.may.be.annotated.functional.problem.descriptor:
  text: Interface <code>#ref</code> may be annotated with @FunctionalInterface
only.report.public.methods.option:
  text: Only report 'public' methods
lambda.parameter.hides.member.variable.display.name:
  text: Lambda parameter hides field
static.initializer.references.subclass.display.name:
  text: Static initializer references subclass
lambda.parameter.hides.member.variable.problem.descriptor:
  text: 'Lambda parameter <code>#ref</code> hides field in class ''''{0}'''' #loc'
lambda.parameter.hides.member.variable.ignore.invisible.option:
  text: Ignore fields not actually visible from the lambda
shared.thread.local.random.display.name:
  text: '''ThreadLocalRandom'' instance might be shared'
shared.thread.local.random.problem.descriptor:
  text: '''ThreadLocalRandom'' instance might be shared between threads'
native.method.naming.convention.display.name:
  text: '''native'' method naming convention'
native.method.naming.convention.element.description:
  text: '''native'' method'
use.of.obsolete.date.time.api.display.name:
  text: Use of obsolete date-time API
use.of.obsolete.date.time.api.problem.descriptor:
  text: 'Obsolete date-time type <code>#ref</code> used #loc'
warn.on.label:
  text: 'Warn on:'
all.levels.option:
  text: all log levels
warn.level.and.lower.option:
  text: warn level and lower
info.level.and.lower.option:
  text: info level and lower
debug.level.and.lower.option:
  text: debug level and lower
trace.level.option:
  text: trace level
ignored.autocloseable.types.column.label:
  text: Ignored AutoCloseable resource types
choose.autocloseable.type.to.ignore.title:
  text: Choose AutoCloseable resource type to ignore
big.decimal.method.without.rounding.called.display.name:
  text: Call to 'BigDecimal' method without a rounding mode argument
big.decimal.method.without.rounding.called.problem.descriptor:
  text: '''BigDecimal.#ref()'' called without a rounding mode argument'
bigdecimal.legacy.method.display.name:
  text: '''BigDecimal'' legacy method called'
bigdecimal.legacy.method.problem.descriptor:
  text: Call to 'BigDecimal.#ref()' can use 'RoundingMode' enum constant
bigdecimal.legacy.method.quickfix:
  text: Use 'RoundingMode' enum constant
serializable.stores.non.serializable.display.name:
  text: Serializable object implicitly stores non-Serializable object
serializable.lambda.stores.non.serializable.problem.descriptor:
  text: Serializable lambda implicitly stores non-Serializable object of type ''{0}''
serializable.local.class.stores.non.serializable.problem.descriptor:
  text: Serializable local class ''{1}'' implicitly stores non-Serializable object of type ''{0}''
serializable.anonymous.class.stores.non.serializable.problem.descriptor:
  text: Serializable anonymous class implicitly stores non-Serializable object of type ''{0}''
assignment.to.lambda.parameter.display.name:
  text: Assignment to lambda parameter
assignment.to.lambda.parameter.problem.descriptor:
  text: 'Assignment to lambda parameter <code>#ref</code> #loc'
class.with.only.private.constructors.display.name:
  text: Class with only 'private' constructors should be declared 'final'
class.with.only.private.constructors.problem.descriptor:
  text: Class <code>#ref</code> with only 'private' constructors should be declared 'final'
property.value.set.to.itself.display.name:
  text: Property value set to itself
equals.with.itself.display.name:
  text: '''equals()'' called on itself'
equals.with.itself.problem.descriptor:
  text: <code>#ref()</code> called on itself
junit4.method.naming.convention.display.name:
  text: JUnit 4+ test method naming convention
junit4.method.naming.convention.element.description:
  text: JUnit 4+ test method
junit3.method.naming.convention.display.name:
  text: JUnit 3 test method naming convention
junit3.method.naming.convention.element.description:
  text: JUnit 3 test method
introduce.holder.class.quickfix:
  text: Introduce holder class
double.brace.initialization.display.name:
  text: Double brace initialization
double.brace.initialization.quickfix:
  text: Replace with regular initialization
return.of.inner.class.display.name:
  text: Return of instance of anonymous, local or inner class
return.of.anonymous.class.problem.descriptor:
  text: 'Return of instance of anonymous class #loc'
return.of.local.class.problem.descriptor:
  text: 'Return of instance of local class <code>{0}</code> #loc'
return.of.inner.class.problem.descriptor:
  text: 'Return of instance of non-static inner class <code>{0}</code> #loc'
return.of.inner.class.ignore.non.public.option:
  text: Ignore returns from non-public methods
parameter.type.prevents.overriding.display.name:
  text: Parameter type prevents overriding
parameter.type.prevents.overriding.problem.descriptor:
  text: 'Parameter type <code>#ref</code> is located in ''''{0}'''' while super method parameter type is located in ''''{1}'''' preventing overriding #loc'
parameter.type.prevents.overriding.quickfix:
  text: Change type of parameter to ''{0}''
parameter.type.prevents.overriding.family.quickfix:
  text: Change type of parameter
suspicious.getter.setter.display.name:
  text: Suspicious getter/setter
suspicious.setter.problem.descriptor:
  text: 'Setter <code>#ref()</code> assigns field ''''{0}'''' #loc'
suspicious.getter.problem.descriptor:
  text: 'Getter <code>#ref()</code> returns field ''''{0}'''' #loc'
unnecessary.break.display.name:
  text: Unnecessary 'break' statement
unnecessary.break.problem.descriptor:
  text: '<code>#ref</code> statement is unnecessary #loc'
utility.class.can.be.enum.display.name:
  text: Utility class can be 'enum'
utility.class.code.can.be.enum.problem.descriptor:
  text: 'Utility class <code>#ref</code> can be ''enum'' #loc'
utility.class.code.can.be.enum.quickfix:
  text: Convert to 'enum'
non.public.clone.display.name:
  text: '''clone()'' method not ''public'''
non.public.clone.problem.descriptor:
  text: '<code>#ref()</code> method not ''public'' #loc'
only.warn.on.public.clone.methods:
  text: Only warn on 'public' clone methods
only.warn.on.protected.clone.methods:
  text: Only warn on 'protected' clone methods
clone.returns.class.type.display.name:
  text: '''clone()'' should have return type equal to the class it contains'
clone.returns.class.type.problem.descriptor:
  text: '''''clone()'''' should have return type ''''{0}'''' #loc'
clone.returns.class.type.quickfix:
  text: Change return type to ''{0}''
clone.returns.class.type.family.quickfix:
  text: Change return type to class type
use.of.clone.display.name:
  text: Use of 'clone()' or 'Cloneable'
use.of.clone.call.problem.descriptor:
  text: Call to <code>#ref()</code>
use.of.clone.call.method.problem.descriptor:
  text: Implementation of <code>#ref()</code>
use.of.clone.reference.problem.descriptor:
  text: Use of <code>#ref</code>
dangling.javadoc.display.name:
  text: Dangling Javadoc comment
dangling.javadoc.problem.descriptor:
  text: 'Dangling Javadoc comment #loc'
dangling.javadoc.convert.quickfix:
  text: Replace with block comment
dangling.javadoc.delete.quickfix:
  text: Remove dangling comment
equals.replaceable.by.objects.call.display.name:
  text: '''equals()'' expression replaceable by ''Objects.equals()'' expression'
equals.replaceable.by.objects.call.problem.descriptor:
  text: '<code>#ref</code> replaceable by ''Objects.equals()'' expression #loc'
equals.replaceable.by.objects.call.quickfix:
  text: Replace with 'Objects.equals()' expression
equals.replaceable.by.objects.check.not.null.option:
  text: Report only null safe 'equals' calls
array.objects.equals.display.name:
  text: '''Objects.equals()'' called on arrays'
array.objects.equals.problem.descriptor:
  text: '<code>Objects.#ref()</code> on arrays should probably be ''Arrays.equals()'' #loc'
array.objects.deep.equals.problem.descriptor:
  text: '<code>Objects.#ref()</code> on arrays should probably be ''Arrays.deepEquals()'' #loc'
extends.throwable.display.name:
  text: Class directly extends 'java.lang.Throwable'
anonymous.extends.throwable.problem.descriptor:
  text: 'Anonymous class directly extends ''java.lang.Throwable'' #loc'
extends.throwable.problem.descriptor:
  text: 'class <code>#ref</code> directly extends ''java.lang.Throwable'' #loc'
lambda.parameter.naming.convention.display.name:
  text: Lambda parameter naming convention
lambda.parameter.naming.convention.element.description:
  text: Lambda parameter
assert.message.not.string.display.name:
  text: '''assert'' message is not a String'
assert.message.of.type.boolean.problem.descriptor:
  text: '''''assert'''' message of type ''''{0}'''' #loc'
assert.message.not.string.only.warn.boolean.option:
  text: Only warn when 'assert' message is 'boolean' or 'java.lang.Boolean'
suspicious.literal.underscore.display.name:
  text: Suspicious underscore in number literal
suspicious.literal.underscore.problem.descriptor:
  text: 'Group in number literal with underscores does not have length 3 #loc'
unary.plus.quickfix:
  text: Remove unary '+'
super.tear.down.in.finally.display.name:
  text: '''super.tearDown()'' not called from ''finally'' block'
super.tear.down.in.finally.problem.descriptor:
  text: '<code>#ref()</code> not called from ''finally'' block #loc'
confusing.floating.point.literal.option:
  text: Ignore floating point literals in scientific notation
class.may.be.interface.java8.option:
  text: Report classes containing non-abstract methods when using Java 8
simplifiable.boolean.expression.display.name:
  text: Simplifiable boolean expression
unnecessary.initcause.display.name:
  text: Unnecessary call to 'Throwable.initCause()'
unnecessary.initcause.problem.descriptor:
  text: Unnecessary <code>Throwable.#ref()</code> call
unnecessary.initcause.quickfix:
  text: Remove 'Throwable.initCause()' call
consider.static.final.fields.constant.option:
  text: Consider 'static final' fields constant
atomic.field.updater.not.static.final.display.name:
  text: AtomicFieldUpdater field not declared 'static final'
atomic.field.updater.not.static.final.problem.descriptor:
  text: '{0} field <code>#ref</code> is not declared ''''static final'''' #loc'
atomic.field.updater.issues.display.name:
  text: AtomicFieldUpdater issues
field.not.found.in.class.problem.descriptor:
  text: No field named ''{0}'' found in class ''{1}''
field.incorrect.type.problem.descriptor:
  text: Field ''{0}'' does not have type ''{1}''
field.missing.volatile.modifier.problem.descriptor:
  text: Field ''{0}'' does not have ''volatile'' modifier
field.has.static.modifier.problem.descriptor:
  text: Field ''{0}'' has ''static'' modifier
private.field.not.accessible.problem.descriptor:
  text: '''''private'''' field ''''{0}'''' is not accessible from here'
package.local.field.not.accessible:
  text: package-private field ''{0}'' is not accessible from here
protected.field.not.accessible.problem.descriptor:
  text: '''''protected'''' field ''''{0}'''' is not accessible from here'
interface.clashes.with.object.class.display.name:
  text: Interface method clashes with method in 'java.lang.Object'
interface.clashes.with.object.class.problem.descriptor:
  text: <code>#ref()</code> clashes with method in 'java.lang.Object'
optional.used.as.field.or.parameter.type.display.name:
  text: '''Optional'' used as field or parameter type'
optional.used.as.field.type.problem.descriptor:
  text: <code>#ref</code> used as type for field ''{0}''
optional.used.as.parameter.type.problem.descriptor:
  text: <code>#ref</code> used as type for parameter ''{0}''
lambda.unfriendly.method.overload.display.name:
  text: Lambda unfriendly method overload
lambda.unfriendly.method.overload.problem.descriptor:
  text: Lambda unfriendly overload of method <code>#ref()</code>
lambda.unfriendly.constructor.overload.problem.descriptor:
  text: Lambda unfriendly overload of constructor <code>#ref()</code>
optional.contains.collection.display.name:
  text: '''Optional'' contains array or collection'
optional.contains.collection.problem.descriptor:
  text: '''Optional'' contains collection <code>#ref</code>'
optional.contains.array.problem.descriptor:
  text: '''Optional'' contains array <code>#ref</code>'
synchronization.on.get.class.display.name:
  text: Synchronization on 'getClass()'
synchronization.on.get.class.problem.descriptor:
  text: 'Synchronization on <code>#ref()</code> #loc'
object.instantiation.inside.equals.or.hashcode.display.name:
  text: Object instantiation inside 'equals()' or 'hashCode()'
object.instantiation.inside.equals.or.hashcode.problem.descriptor:
  text: 'Object instantiation inside ''''{0}()'''' #loc'
object.instantiation.inside.equals.or.hashcode.problem.descriptor2:
  text: Object instantiation inside ''{0}()'' ({1})#loc
lambda.body.can.be.code.block.name:
  text: Lambda body can be code block
lambda.body.can.be.code.block.quickfix:
  text: Expand lambda body to '{'...'}'
lambda.parameter.type.can.be.specified.name:
  text: Lambda parameter type can be specified
lambda.parameter.type.can.be.specified.descriptor:
  text: Lambda can be expanded to {0} -> '{'...'}'
lambda.parameter.type.can.be.specified.quickfix:
  text: Expand lambda to {0} -> '{'...'}'
lambda.parameter.type.can.be.specified.family.quickfix:
  text: Specify lambda parameter type
diamond.can.be.replaced.with.explicit.type.arguments.name:
  text: Diamond can be replaced with explicit type arguments
diamond.can.be.replaced.with.explicit.type.arguments.quickfix:
  text: Replace '<>' with explicit type arguments
lambda.can.be.replaced.with.anonymous.name:
  text: Lambda can be replaced with anonymous class
lambda.can.be.replaced.with.anonymous.quickfix:
  text: Replace lambda with anonymous class
method.ref.can.be.replaced.with.lambda.name:
  text: Method reference can be replaced with lambda
method.ref.can.be.replaced.with.lambda.quickfix:
  text: Replace method reference with lambda
try.statement.with.multiple.resources.name:
  text: Try statement with multiple resources can be split
try.statement.with.multiple.resources.quickfix:
  text: Split 'try' statement with multiple resources
multi.catch.can.be.split.name:
  text: Multi-catch can be split into separate catch blocks
multi.catch.can.be.split.quickfix:
  text: Split multi-catch into separate 'catch' blocks
assertion.can.be.if.name:
  text: Assertion can be replaced with if statement
assert.can.be.if.quickfix:
  text: Replace 'assert' with 'if' statement
if.can.be.assertion.name:
  text: If statement can be replaced with assertion
if.can.be.assertion.quickfix:
  text: Replace 'if' with 'assert' statement
equality.operator.compares.objects.name:
  text: Objects compared with '=='
equality.operator.compares.objects.descriptor:
  text: Objects compared with ''{0}''
equality.operator.compares.objects.quickfix:
  text: Replace ''{0}'' with ''{1}equals()''
equality.operator.compares.objects.family.quickfix:
  text: Replace equality operator with equals()
equality.operator.compares.objects.safe.quickfix:
  text: Replace ''{0}'' with safe ''{1}equals()''
equality.operator.compares.objects.safe.family.quickfix:
  text: Replace equality operator with safe equals()
single.statement.in.block.name:
  text: Code block contains single statement
single.statement.in.block.descriptor:
  text: '''''{0}'''' contains single statement'
single.statement.in.block.quickfix:
  text: Remove braces from ''{0}'' statement
single.statement.in.block.family.quickfix:
  text: Remove braces from statement
single.element.annotation.name:
  text: Single-element annotation
single.element.annotation.quickfix:
  text: Add 'value='
single.element.annotation.family.quickfix:
  text: Expand annotation to normal form
array.creation.without.new.keyword.name:
  text: Array creation without 'new' expression
array.creation.without.new.keyword.quickfix:
  text: Add ''new {0}''
array.creation.without.new.keyword.family.quickfix:
  text: Add 'new' expression
malformed.set.up.tear.down.display.name:
  text: Malformed 'setUp()' or 'tearDown()' method
malformed.set.up.tear.down.problem.descriptor:
  text: '''#ref()'' has incorrect signature #loc'
method.missing.return.statement.display.name:
  text: Method contains logic but is missing a 'return' statement
method.missing.return.statement.problem.descriptor:
  text: Method <code>#ref</code> contains logic but is missing a 'return' statement
overly.long.lambda.display.name:
  text: Overly long lambda expression
overly.long.lambda.problem.descriptor:
  text: 'Lambda expression is too long (# Non-comment source statements = {0}) #loc'
wait.notify.not.in.synchronized.context.display.name:
  text: '''wait()'' or ''notify()'' while not synchronized'
wait.notify.while.not.synchronized.on.problem.descriptor:
  text: 'Call to <code>#ref</code> while not synchronized on ''''{0}'''' #loc'
junit5.assertions.converter.display.name:
  text: Obsolete assertions in JUnit 5 tests
junit5.converter.display.name:
  text: JUnit 4 test can be JUnit 5
junit5.converter.fix.name:
  text: Migrate to JUnit 5
call.to.suspicious.string.method.display.name:
  text: Call to suspicious String method
call.to.suspicious.string.method.problem.descriptor:
  text: '<code>String.#ref()</code> called in internationalized context #loc'
string.concatenation.replace.fix:
  text: Replace with StringBuilder
string.concatenation.replace.fix.name:
  text: Convert variable ''{0}'' from String to {1}
string.concatenation.introduce.fix:
  text: Introduce StringBuilder
string.concatenation.introduce.fix.name:
  text: Introduce new {1} to update variable ''{0}''
ignored.class.names:
  text: Ignore classes (including subclasses)
junit5.platform.runner.display.name:
  text: '@RunWith(JUnitPlatform.class) without test methods'
junit5.valid.parameterized.configuration.display.name:
  text: JUnit 5 malformed parameterized test
junit5.malformed.repeated.test.display.name:
  text: JUnit 5 malformed repeated test
meta.annotation.without.runtime.retention:
  text: Non-runtime annotation to be used by reflection
